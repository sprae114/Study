해시태크 : #컴퓨터구조

----

# Chapter 01 컴퓨터 구조 시작하기  

## 01-1 구조를 알아야 하는 이유 (P. 31)  
#### 📌요약
- 컴퓨터 구조를 이해하면 **문제 해결 능력이 향상**됌. 
	왜 문제해결 능력이 향상되지? 
	=>같은 코드라도 컴퓨터마다 될때가 있고 안될때가 이때 컴퓨터 구조를 이해하면 문제해결이 가능하다.  또한, 웹 클라우드 서비스를 이용하더라도, 어떤 cpu를 사용할지, 얼마나 메모리를 사용해야할지 알수 있음.  
- 컴퓨터 구조를 이해하면 문법만으로는 알기 어려운 **성능/용량/비용을 고려**하여 개발할 수 있음.

## 01-2 컴퓨터 구조의 큰 그림 (P. 37)  
#### 📌요약
- 컴퓨터가 이해하는 정보에는 **데이터와 명령어**가 있습니다.
- **메모리**는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품입니다.
- **CPU**는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 부품입니다.
- **보조기억장치**는 전원이 꺼져도 보관할 프로그램을 저장하는 부품입니다.
- **입출력장치**는 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품입니다.
- **시스템버스**는 네가지 핵심 부품들이 서로 정보를 주고받는 통로입니다.

#### 📌컴퓨터 구조 그림
- 컴퓨터 구조 그림
![[Pasted image 20221228143932.png]]

- 핵심 부품 연결 그림
![[Pasted image 20221228143952.png]]

- 동작 예시
![[Pasted image 20221228144009.png]]

# Chapter 02 데이터  

## 02-1 0과 1로 숫자를 표현하는 방법 (P. 55)  
#### 📌요약
- **비트**는 0과 1로 표현할 수 있는 가장 작은 정보 단위입니다.
- **바이트**, 킬로바이트, 메가바이트, 기가바이트, 테라바이트는 비트보다 더 큰 정보 단위입니다.
- **이진법**은 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 수를 표현하는 방법입니다.
- 이진법에서 음수는 **2의 보수**로 표현할 수 있습니다. (2의 보수 구하기 => 뒤집고 +1 더하기  )
- **십육진법**은 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법입니다.


##  02-2 0과 1로 문자를 표현하는 방법 (P. 67)  
#### 📌요약
- **문자 집합**은 컴퓨터가 인식할 수 있는 문자의 모음으로, 문자 집합에 속한 문자를 인코딩하여 0과 1로 표현할 수 있습니다.
- 아스키 문자 집합에 0부터 127까지의 수가 할당되어 **아스키코드**로 인코딩됩니다.
- **EUC-KR**은 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식입니다.
- **유니코드**는 여러 나라의 문자들을 광범위하게 표현할 수 있는 통일된 문자 집합이며, UTF-8, UTF-16 UTF-32는 유니코드 문자의 인코딩 방식입니다.
- **완성형 코딩방식**이란 자음, 모음 이렇게 따로가 아닌 한글자 자체를 넣은 것을 말한다


# Chapter 03 명령어  

##  03-1 소스 코드와 명령어 (P. 79)  
#### 📌요약
- **고급 언어**는 사람이 이해하고 작성하기 쉽게 만들어진 언어입니다.
- **저급 언어**는 컴퓨터가 직접 이해하고 실행할 수 있는 언어입니다.
- 저급 언어는 0과 1로 이루어진 명령어로 구성된 **기계어**와 기계어를 사람이 읽기 편한 형태로 번역한 **어셈블리어**가 있습니다.



#### ✔컴파일과 인터프리토차이는?
##### 컴파일러
정의 : 소스코드 전체를 **한번에 번역**해주는 것 ​

장단점
- 컴파일 후에는 모든 소스코드가 기계어로 변환되어 있기 때문에 실행 시간이 빠르다.  
- 규모가 큰 프로그램은 컴파일 시 오래 걸릴 수 있다.  
- C, Java에서 사용  

##### 인터프리토
정의 : 실행하면 **한줄한줄 번역**해주는 것

장단점
- 컴파일과정 없이 바로 실행하기 때문에 수정, 디버깅에 유리하다. 즉 개발속도에 유리  
- 한 줄씩 읽어서 실시간으로 실행하기 때문에 컴파일 언어에 비해 속도가 느리다.  
- Python, Java에서 사용  

![[Pasted image 20221228144557.png]]

##  03-2 명령어의 구조 (P. 91)  
#### 📌요약
- **명령어**는 연산 코드와 오퍼랜드로 구성됩니다.
- **연산 코드**는 명령어가 수행할 연산을 의미합니다.
- **오퍼랜드**는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미합니다.
- **주소 지정 방식**은 연산에 사용할 데이터 위치를 찾는 방법입니다.

#### 📌연산코드와 오퍼랜드의 차이는?
- **연산코드**란? 명령어가 수행할 연산  
- **오퍼랜드**란? 연산에 사용할 데이터/저장된 위치

![[Pasted image 20221228145206.png]]
![[Pasted image 20221228145212.png]]

#### 📌연산코드의 4가지 역할은?
- 대표적인 연산코드 역할
![[Pasted image 20221228145315.png]]

#### 📌주소 지정 방식 개념
#####  주소지정 방식이란? 
=> 유효주소(연산에 사용될 데이터가 저장된 위치 )를 찾기 위해서 사용하는 것  

##### 즉시 주소 지정 방식  
![[Pasted image 20221228151429.png]]
- 데이터의 크기가 작아지지만, 레지스터로 찾는 과정이 없기 때문에 빠르다  

##### 직접 주소 지정방식  
![[Pasted image 20221228151435.png]]
- 오퍼랜드 필드에 유효 주소를 직접 명시하여데이터의 크기가 커짐  

#####  간접 주소 지정 방식  
![[Pasted image 20221228151454.png]]
- 유효주소의 범위를 늘리기 위한 방법  

#  Chapter 04 CPU와 작동 원리  
##   04-1 ALU와 제어장치 (P.105)  
#### 📌용어정리
##### ALU
=>  레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들입니다.
![[Pasted image 20221228151734.png]]
- ALU는 연산 결과와 **플래그**를 내보냅니다.

##### 플러그
=>연산 결과에 대한 추가적인 상태 정보
![[Pasted image 20221228151803.png]]

##### 제어장치
=> 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들입니다.
![[Pasted image 20221228151834.png]]
- 제어장치는 CPU 내부와 외부로 **제어 신호**를 내보냅니다.

매커니즘  
1) 클럭신호를 받아들이기  
2) '해석해야 할 명령어'를 받아들이기  
3) 플래그 레지스터 속 플래그 값 받아드리기  
4) 제어 버스로 전달된 제어 신호 받아드리기  
5) 이후 CPU 내부/외부에 제어 신호 보내기  


##  04-2 레지스터 (P. 113)  
#### 📌요약
- **프로그램 카운터**는 메모리에서 가져올 명령어의 주소, 명령어 레지스터는 해석할 명령어를 저장합니다.
- **메모리 주소 레지스터**는 메모리의 주소, 메모리 버퍼 레지스터는 메모리와 주고받을 데이터를 저장합니다.
- **범용 레지스터**는 데이터와 주소를 모두 저장하고, 플래그 레지스터는 연산 결과 혹은 CPU 상태에 대한 부가 정보를 저장합니다.
- **스택 포인터**는 스택 최상단의 위치를 저장합니다.
- **베이스 레지스터**에 저장된 주소는 기준 주소로서의 역할을 합니다.

#### 📌레지스터 매커니즘
출처 :  [CPU는 어떻게 작동할까?](https://www.youtube.com/watch?v=Fg00LN30Ezg&t=840s)  

![[Pasted image 20221228152104.png]]
- 1) PC의 내용을 메모리 주소 레지스터로 보낸다.  
- 2) 메모리 주소 레지스터는 메모리에 1000번지에 있는 데이터를 가져온다. 이후 메모리 버퍼 레지스터로 넣는다. 이후 PC카운트를 늘린다  
- 3) 메모리 버퍼 레지스터는 1101의 값을 명령어 레지스터로 이동해준다.  
- 4) 명령어 레지스터는 해당 값을 해석하고 제어신호를 발생시킨다  


##  04-3 명령어 사이클과 인터럽트 (P. 127)  
#### 📌요약
- **명령어 사이클**은 하나의 명령어가 처리되는 주기로 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있습니다.
- **인터럽트**는 CPU의 정상적인 작업을 방해하는 신호입니다.
- 인터럽트의 종류에는 **예외와 하드웨어 인터럽트**가 있습니다.
- **인터럽트 서비스 루틴**은 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램입니다.

#### 📌인터럽트란?
=> CPU의 정상적인 작업을 방해하는 신호입니다.
![[Pasted image 20221228152333.png]]

#### 📌인터럽트 동작 매커니즘  
![[Pasted image 20221228152352.png]]


#### 📌인터럽트가 발생하면 이전에 저장된 값은 어떻게 처리하지?  
- 인터럽트 발생전
![[Pasted image 20221228152433.png]]

- 인터럽트 발생하면 스택영역에 이전까지 저장된 정보는 스택영역에 백업을 해놓는다.
![[Pasted image 20221228152440.png]]

#### 📌용어정리  
##### 인터럽트 요청신호  
=> 정상적인 실행 흐름을 끊기 전에 CPU에게 보내는 신호
![[Pasted image 20221228152544.png]]

##### 인터럽트 플래그
=> 인터럽트 유무는 판별
![[Pasted image 20221228152618.png]]

##### 인터럽트 서비스 루틴
=> 인터럽트가 실행 될때, 작용하는 프로그램
![[Pasted image 20221228152647.png]]

##### 인터럽트 백터  
=>  인터럽트 서비스 루틴을 식별하기 위한 정보로, 시작점을 알 수 있음.
![[Pasted image 20221228152709.png]]

#### 📌인터럽트 종류는?  
![[Pasted image 20221228152735.png]]
- **폴트**: 예외처리후, 예외 발생한 명령어부터 다시 실행재개  
- **트랩** : 예외처리후, 예외 발생한 다음 명령어부터 다시 실행재개(디버깅)  
- **소프트 웨어 인터럽트** : 시스템 호출 발생했을때  

#### 📌동기/비동기 인터럽트 차이는?
##### 동기 인터럽트
=> CPU에 의해 발생되는 인터럽트로 예외가 발생했을때 동작함  

##### 비동기 인터럽트
=>입출력장치에 의해 발생되는 인터럽트로 **알람**과 같은 역할을 함.  
![[Pasted image 20221228152752.png]]


#### 📌명령어 사이클  
![[Pasted image 20221228152917.png]]


#  Chapter 05 CPU를 위한 설계 기법  
##   05-1 빠른 CPU를 위한 설계 기법 (P. 145)  
#### 📌용어정리
출처 :  [[10분 테코톡] 🌷 코다의 Process vs Thread - YouTube](https://www.youtube.com/watch?v=1grtWKqTn50)  

##### 클럭  
=> CPU의 속도를 나타내는 단위  
- 클럭속도가 높으면?  
	- 명령어 사이클을 더 빠르게 반복, 부품도 빠르게 작동  (단, 이럴경우 발열문제가 발생할 수 있음.)  
	- 클럭 속도는 일정하게 유지 되는게 X, 성능에 따라 순간 클럭 속도를 조절함.  


#####  코어와 멀티코어(=멀티 프로세서)  
=> **멀티코어 프로세서**란 여러 개의 코어를 포함하는 CPU
=> 코어란  CPU 내에서 명령어를 실행하는 부품
![[Pasted image 20221228213015.png]]
- 멀티 코어로 성능 높이는 방법은?  
	- 코어마다 처리할 연산을 적절히 분배해야함.  (몰아서 주면, 몰아서 준만큼의 성능 밖에 안나옴 )
	- 처리량이 코어 수보다 지나치게 작아도 안됌  (한사람의 할일을, 5명이 나눠갖는 경우랑 비슷 성능차이가 크지 않음)  

##### 스레드
- 스레드란?  실행 흐름의 단위  

##### 하드웨어적 스레드
- 하드웨어적 스레드란?  하나의 코어가 동시에 처리하는 명령어 단위
![[Pasted image 20221228213158.png]]
- ex) 2코어 4쓰레드
![[Pasted image 20221228213214.png]]
CPU가 한번에 4개의 명령어를 처리할 수 있음. 프로그램 입장에서 봤을 때는 한번에 하나의 명령어를 처리하는 CPU가 4개 있는것처럼 보임. 그래서 논리 프로세스라고도 함

- 멀티 스레드 프로세서 = 멀티 스레드 CPU  
	- 위의 그림처럼 하나의 코어로 동시에 여러 명령어를 처리하는 것  

##### 소프트웨어적 스레드란?  
- 하나의 프로그램에서 독립적으로 실행되는 단위
![[Pasted image 20221228213336.png]]
- EX)멀티 스레드
![[Pasted image 20221228213347.png]]
예시로는 입력받은 내용을 화면에 보여주면서, 맞춤법에 맞는지 검사하는 기능

#####  멀티스레드 프로세스  
=> 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU
![[Pasted image 20221228213511.png]]

- 어떻게 두개의 명령어를 동시에 처리할 수 있을까?  
	- 이전에 명령어를 처리했던 방식을 생각해보면, 명령어를 처리하기 위한 부품(PC, 데이터 버퍼 레지스터, 데이터 주소 레지스터)등.. 중요 레지스터가 2개씩 있으면됌  




##   05-2 명령어 병렬 처리 기법 (P. 157)  
#### 📌요약
- **명령어 파이프라이닝**은 동시에 여러 개의 명령어를 겹쳐 실행하는 기법입니다.
- **슈퍼스칼라**는 여러 개의 명령어 파이프라인을 두는 기법입니다.
- **비순차적 명령어 처리 기법**은 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법입니다.

#### 📌명령어 병렬처리 기법을 왜 쓰는거지?
=> 어떻게 명령어를 동시에 처리하여 CPU를 작동시킬까 고민부터 시작함.
![[Pasted image 20221228213843.png]]

---

- 명령어 파이프라인  

- 명령어 처리 과정  
- 인출 -> 해석 -> 실행 -> 저장  


ㅁㅁ 명령어 파이프라인이란?  

- 같은 단계가 겹치지 않는다면 CPU는 '각 단계를 동시에 실행할 수 있다'
![](https://api.transno.com/v3/document_image/0f0d879f-7e6f-49ef-9468-0f38a6573923-10826299.jpg)

![](https://api.transno.com/v3/document_image/e7e3712f-5958-4338-8c02-029e929643ab-10826299.jpg)  


- 만약 파이프라인을 사용하지 않으면?![](https://api.transno.com/v3/document_image/310e33eb-de69-4034-8c4b-39713cf987cf-10826299.jpg)  


- 파이프라인 위험  

- 특정상황에서는 성능 향상에 실패하는 경우를 알아보자  


- 그림![](https://api.transno.com/v3/document_image/d7632d26-471a-423d-a0b4-3e678e07db1f-10826299.jpg)  


- 데이터 위험  
- 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우(데이터 의존성)  


- 제어 위험  
- 프로그램 카운터의 갑작스러운 변화![](https://api.transno.com/v3/document_image/7f78e494-ea24-4369-9b30-17e9fc73ba44-10826299.jpg)  


- 구조적 위험  
- 서로 다른 명령어가 ALU과 같은 CPU 부품을 동시에 사용할때  


- 비순차적 명령어 처리  

- 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법(= 명령어의 합법적인 새치기)  


- 언제 사용될까?(데이터의존성을 가지고 있을때)  

- 사용되는 예시![](https://api.transno.com/v3/document_image/33fb388c-6431-4571-9e90-c0c076e2ee35-10826299.jpg)  


- 사용한 이후![](https://api.transno.com/v3/document_image/1031e325-c6b6-41ea-906a-b3964f8d0bb8-10826299.jpg)  


- 슈퍼스칼라  

- 슈퍼스칼라란?  
- CPU내부에 여러 개의 명령어 파이프라인을 포함한 구조  


- 그림![](https://api.transno.com/v3/document_image/86999427-a132-4f4a-8b5c-d9fefb502752-10826299.jpg)![](https://api.transno.com/v3/document_image/620f33c5-a93d-4889-8d14-91a87af07f2e-10826299.jpg)  


- 05-3 CISC와 RISC (P.167)  

- 요약![](https://api.transno.com/v3/document_image/1bb16a65-a669-40a8-b867-e06e44bfe5c6-10826299.jpg)  


- (배경) CPU에 명령어 병렬처리기법을 하기 위해 명령어 구조  
- 이전에 연산코드, 오퍼랜드는 뭐지?  

- 아 그건 구역을 나눈거고, 어떤 연산코드를 정할지, 오퍼랜드 길이나 방식은 각 회사마다 다름  


- 그래서 인텔과 아이폰 호환 X, 명령어가 달라지면 어셈블리어도 달라지니깐  


- ISA  
- CPU의 언어임과 동시에 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속![](https://api.transno.com/v3/document_image/3e67f6e0-e7e3-4390-92bf-c8c6b274d2eb-10826299.jpg)  


- CISC  

- 복잡하고 다양한 명령어들을 활용하는 CPU설계 방식  


- 명령어의 형태와 길이가 다양함![](https://api.transno.com/v3/document_image/b711be70-02e3-4ee2-932d-e92f1b262793-10826299.jpg)  


- (문제점) 명령어의 크키가 일정하지 않아 시간이 일정하지 않음 -> 파이프라인 효과적 적용 X![](https://api.transno.com/v3/document_image/0aee919b-07ff-4961-81ba-d798bdbec52c-10826299.jpg)  


- RISC  

- 명령어 종류가 적고, 1클럭 내외로 실행되는 명령어  


- 메모리 접근을 단순/최소화하는 대신 레지스터를 적극 활용함  


- 비교![](https://api.transno.com/v3/document_image/745fce68-cef6-46d8-bbf0-c185b6671413-10826299.jpg)  

- Chapter 06 메모리와 캐시 메모리  

- 06-1 RAM의 특징과 종류 (P.179)  

- 요약![](https://api.transno.com/v3/document_image/a148bf37-5783-41a1-95bb-59d396b0f5d5-10826299.jpg)  


- cpu와 작동방식  

- 메모리에 없는 경우![](https://api.transno.com/v3/document_image/19b0cc2d-7879-4317-83e4-b4bdbb16b7ba-10826299.jpg)  


- 메모리에 있는 경우![](https://api.transno.com/v3/document_image/2855114f-4759-4e09-acb9-2a319dcbdef9-10826299.jpg)  


- 따라서 RAM의 용량이 크면 많은 프로그램을 동시에 빠르게 시키는 것이 가능하다.  


- 단, 메모리가 커진다고 해도 메모리 실행시간(=보조 기억장치 가져오는 시간)이 빨라 지는 것은 아님![](https://api.transno.com/v3/document_image/e3cbc445-b2ca-4359-a705-2baff8acfb84-10826299.jpg)  


- DRAM/SRAM/DDR RAM  

- DRAM/SRAM![](https://api.transno.com/v3/document_image/70b5182c-eabf-499f-9b03-9b3a87615d2b-10826299.jpg)  


- DDR RAM![](https://api.transno.com/v3/document_image/0e56a0f4-3c3b-4780-a438-3a8bdb3b02f2-10826299.jpg)  
대역폭(=데이터가 지나가는 길)을 넓혀서 속도를 빠르게 만든 것

- 06-2 메모리의 주소 공간 (P.187)  

- 요약![](https://api.transno.com/v3/document_image/af810b8c-af67-441b-b8f9-953b28ce174b-10826299.jpg)  


- 물리주소와 논리주소  

- 그림![](https://api.transno.com/v3/document_image/14573cfe-6baa-479b-a337-bdbb74743dae-10826299.jpg)  


- 물리주소는 메모리 하드웨어가 사용하는 주소  


- 논리주소는 CPU와 실행 중인 프로그램 사용하는 주소로, 각 논리 주소마다 0번지로 시작함  


- 그러면 CPU는 논리 주소로 작동하는데 문제가 없을까?  

- 문제점![](https://api.transno.com/v3/document_image/4ee4cb3a-b7d7-4882-a7dc-267cd3d54af3-10826299.jpg)  
CPU는 논리주소만 알아서 명령하지만, 실제로 물리 주소로 저장되어 있어서 변환해줘야하는 필요성 생김

- 해결책![](https://api.transno.com/v3/document_image/a865462b-a6ed-4b6c-8dca-7150511b69dc-10826299.jpg)  

- MMU라는 메모리 관리 장치에 의해서 논리 주소를 물리주소로 변환해준다.  


- 베이스 레지스터를 기준(=실행 프로그램의 시작주소)에서 논리주소를 더하면 됌  


- 만약 논리주소를 벗어나게 되면 한계 레지스터(=논리주소의 최대크기)를 벗어나므로 실행 X  


- 06-3 캐시 메모리 (P.197)  

- 요약![](https://api.transno.com/v3/document_image/bf7690b7-cec9-482a-9c33-853490daba9f-10826299.jpg)  


- 캐시 메모리를 사용하는 이유는?  

- 그림![](https://api.transno.com/v3/document_image/1b4aae0f-4a7f-4bcc-b83a-248e2b9daf90-10826299.jpg)  


- CPU의 연산속도를 메모리 접근하는 시간이 따라잡지 못함. 그래서 병목현상을 예방하고자 캐시 사용  


- 메모리 계층 구조  
- 그림![](https://api.transno.com/v3/document_image/bc0cb9b4-db95-4e2d-a09a-29f76d33d43c-10826299.jpg)  


- CPU와 동작하는 방식  
- 그림![](https://api.transno.com/v3/document_image/e531b8b5-d709-4e83-92f1-ef55f72d49f4-10826299.jpg)  
L1, L2는 코어마다 할당되고, L3는 공유하는 형태로 코어의 외부에 존재하게 된다

- 참조 지역성의 원리  
- 캐시메모리에 어떻게 가져와야할까?(=캐시 히트)  

- 1) 최근에 접근했던 메모리 공간에 다시 접근(=시간지역성)  
- 예시) FOR문![](https://api.transno.com/v3/document_image/09079691-c0ef-4b77-a279-3fa393af96f7-10826299.jpg)  


- 2) 접근한 메모리 근처에 접근(=공간지역성)  
- 예시) 배열  


- [[10분 테코톡] 🏖 파피의 Caching(캐싱) - YouTube](https://www.youtube.com/watch?v=JBFT4KyEvoY)  

- Chapter 07 보조기억장치  

- 07-1 다양한 보조기억장치 (P.209)  

- 요약![](https://api.transno.com/v3/document_image/ffd59d48-8eee-4cb2-a223-c5be45a49167-10826299.jpg)  


- 하드디스크  
- 하드디스크가 속독가 느린 이유는?  

- 1)탐색시간 : 데이터의 접근하려면 헤드를 이동시켜야함![](https://api.transno.com/v3/document_image/c2de7edb-6b2e-4981-ae66-e1299e80da9f-10826299.jpg)  


- 2)회전시간: 헤더가 있는 곳으로 플래터를 회전시켜야함![](https://api.transno.com/v3/document_image/cb52b704-583e-4f12-a968-ec66296e00e7-10826299.jpg)  


- 3) 전송시간: 하드디스크와 컴퓨터 간에 데이터를 전송하는 시간![](https://api.transno.com/v3/document_image/cec03740-2ec1-47d2-8044-1bd83fcb5a2d-10826299.jpg)  


- 플래시 메모리  

- 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장장치  


- USB, SSD에 사용됌  


- 그림![](https://api.transno.com/v3/document_image/88e3a5f5-b75d-4146-8b98-3cda4e1d75be-10826299.jpg)  


- 1비트를 저장할 수 있는 타입  

- 요약![](https://api.transno.com/v3/document_image/29418039-5088-41b8-95ff-9f9a10b251bf-10826299.jpg)  
같은 집에 몇명이 사는지로 생각해보자

- SLC![](https://api.transno.com/v3/document_image/c6ec6254-71cf-4bf6-b232-1eca97b4c54e-10826299.jpg)  


- MLC![](https://api.transno.com/v3/document_image/804f2cd9-bd22-41ff-ba8d-7228aeea281c-10826299.jpg)  


- TLC![](https://api.transno.com/v3/document_image/a4aa0add-9a8e-4e25-8f87-82185d6962a5-10826299.jpg)  


- 플래시 메모리의 문제점은?  

- 그림![](https://api.transno.com/v3/document_image/541cc67c-94b7-4902-b217-66f3c5d76000-10826299.jpg)![](https://api.transno.com/v3/document_image/a22b16c4-d855-4601-b307-f5939ec668a8-10826299.jpg)  
저장은 OK, BUT 플래시 메모리는 덮어 쓰기가 불가능 하므로 데이터를 지우지 못함

- 그래서 SSD는 가비지컬렉션 도입![](https://api.transno.com/v3/document_image/acfaf680-6ce3-4a54-97a3-935d9a5a58ca-10826299.jpg)  


- 07-2 RAID의 정의와 종류 (P.221)  

- 요약![](https://api.transno.com/v3/document_image/f29c057b-83da-4bd2-9a29-2a3946866488-10826299.jpg)  


- RAID는?  

- 그림![](https://api.transno.com/v3/document_image/7c20868c-5545-48c6-8722-4acfffea4957-10826299.jpg)  


- 하드디스크와 SSD에 사용하는 기술로, 데이터의 안정성과 성능 향상을 위해서 여러개의 보조 기억장치를 하나의 논리적 보조기억 장치로 사용하는 기술  


- RAID 0  

- 그림![](https://api.transno.com/v3/document_image/b6fb5e6c-d909-4689-aa83-1c3a88ee9228-10826299.jpg)  


- 장점 -> 읽고 쓰는 속도 향상  


- 단점 -> 저장 정보 안전 x WHY? 하나 고장나면 다 날라감  


- RAID 1  

- 그림![](https://api.transno.com/v3/document_image/c1249bb6-d667-4696-b773-c63a1d47002a-10826299.jpg)  


- 장점 -> 안전하게 정보 저장  


- 단점 -> 많은 양의 하드 디스크가 필요함으로, 비용증가  


- RAID 4  

- 그림![](https://api.transno.com/v3/document_image/6df830bb-fde4-4c4a-a358-257f6020e1a3-10826299.jpg)  


- 오류 검출하고 복구하기 위한 패리티 정보를 저장  


- RAID 6  

- 그림![](https://api.transno.com/v3/document_image/6d1c9d73-c616-49a5-b38e-4fc7870ed553-10826299.jpg)  


- 패리티를 나눠서 갖는 방식  


- 속도는 조금 떨어지지만, 데이터를 좀더 안정적으로 보관  

- Chapter 08 입출력장치  

- 08-1 장치 컨트롤러와 장치 드라이버 (P. 233)  

- 요약![](https://api.transno.com/v3/document_image/00a2c027-ca7c-45dd-a562-d82350dbe962-10826299.jpg)  


- 장치드라이버  
- 그림![](https://api.transno.com/v3/document_image/fbd07ac2-7adb-47b0-a0c0-4c95cd399a1f-10826299.jpg)  


- 08-2 다양한 입출력 방법 (P.241)  
- DYDIR![](https://api.transno.com/v3/document_image/44d764a2-d757-44c4-bee6-22db57f7c5d7-10826299.jpg)  

- Chapter 09 운영체제 시작하기  

- 09-1 운영체제를 알아야 하는 이유 (P. 261)  

- 요약![](https://api.transno.com/v3/document_image/d34735f4-24bb-401f-82a1-93ca849ddb7f-10826299.jpg)  
운영체제도 프로그래미여서 메모리에 적재되어서 실행되어야함

- 용어정리  

- 자원?  
- 프로그램 실행에 필요한 시스템 자원  


- 커널영역과 사용자 영역?  

- 그림![](https://api.transno.com/v3/document_image/8fb14f27-1222-42b2-a38e-056e662896e8-10826299.jpg)  


- 커널영역은 운영체제가 실행되는 메모리 공간, 그외에는 사용자 영역이라고 함.  


- 운영체제의 역할은?  

- 그림![](https://api.transno.com/v3/document_image/2fb1f1dc-9d09-4aef-8c7d-a911c7dfcfed-10826299.jpg)  


- 프로그램에 메모리 자원 할당  
- 그림![](https://api.transno.com/v3/document_image/ca75efb5-991c-4a86-9a7c-5be0105d7fd2-10826299.jpg)  


- 프로그램에 CPU 자원 할당  
- 그림![](https://api.transno.com/v3/document_image/21f754be-1f04-4c69-944f-f36f1bbb3094-10826299.jpg)  


- 09-2 운영체제의 큰 그림 (P. 269)  

- 요약![](https://api.transno.com/v3/document_image/9102584e-f6c8-438b-9d38-5db9b7b3ccdf-10826299.jpg)  


- 이중모드  

- 운영체제 역할![](https://api.transno.com/v3/document_image/1c9e4e06-ce4a-4483-b112-65402593d5c6-10826299.jpg)![](https://api.transno.com/v3/document_image/54f681d0-78c7-47c6-85f6-e515d30c40f0-10826299.jpg)  
운영체제는 문지기 역할을 한다. 이러면 당연히 두가지 행동으로 나뉠 수 있는데,  
​운영체제 서비스를 받을수 없는 사용자 모드와 서비스를 받을 수 있는 커널모드로 나뉜다.

- 이중모드![](https://api.transno.com/v3/document_image/18a06007-5b0e-45ec-a96c-cd367071ae5b-10826299.jpg)  


- 그러면 사용자 모드는 자원을 못 받는 것인가? NO 시스템 호출을 통해 요청할 수 있음  
- 시스템 호출그림![](https://api.transno.com/v3/document_image/9932149e-a9f1-4817-8585-1a75dc78f805-10826299.jpg)  


- 운영체제 핵심 서비스  

- 프로세스 관리  

- 그림![](https://api.transno.com/v3/document_image/f7191796-fd23-4ad1-9fb9-94d92db697fb-10826299.jpg)  


- 프로세스란? 실행중인 프로그램  


- 자원(CPU, 메모리,..) 접근 및 할당  

- 프로그램이 얼마나 오래 CPU를 사용할지 결정  


- 새로운 프로세스가 어느 주소에 적재될지 결정  


- 파일 시스템 관리  

- Chapter 10 프로세스와 스레드  

- 10-1 프로세스 개요 (P.285)  

- 요약![](https://api.transno.com/v3/document_image/82f88a60-a80e-4c45-94da-7043e64c217f-10826299.jpg)  


- 프로세스란?  

- 그림![](https://api.transno.com/v3/document_image/366a2f66-82fe-43f9-b071-67ad6609ba40-10826299.jpg)  


- 보조기억 장치에서 메모리에 적재하고 실행하는 그 프로그램을 지징함  


- 프로세스 종류  

- 포그라운드 프로세스  
- 사용자가 보는 앞에서 실행되는 프로세스  


- 백그라운드 프로세스(=데몬, 서비스)  
- 사용자가 보지 못하는 뒤편에서 실행되는 프로세스  


- 프로세스 제어블록(PCB)  

- 그림![](https://api.transno.com/v3/document_image/625db89e-23ad-49eb-bb06-2a209e49b18a-10826299.jpg)  
모든 프로그램이 CPU를 동시에 사용할 수 없으니깐 프로세스의 실행순서를 관리하고 자원 관리를 해야함

- PCB는 커널영역에 생성  


- 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기  


- PCB에 담기는 정보는 어떤것이 있을까?  

- 그림![](https://api.transno.com/v3/document_image/38660b96-9738-4f59-873a-21bfb89b99ea-10826299.jpg)![](https://api.transno.com/v3/document_image/fd82e1fa-f54c-48e7-a6a4-f5f5190c392b-10826299.jpg)  


- PID  
- 특정 프로세스를 식별하기 위해 부여하는 고유번호  


- 레지스터 값  
- 이전에 사용했던 레지스터 값을 복원하기 위함  


- 프로세스 상태  
- 현재 프로세스 상태가 정보. 대기상태인지, 종료상태인지 ...  


- CPU 스케줄링 정보  
- 어떤 순서로 CPU를 할당 받을지  


- 문맥교환(컨텍스트 스위칭)  

- 문맥이란?  
- 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보  


- 문맥교환이란?  

- 그림![](https://api.transno.com/v3/document_image/35ae45c4-5b0b-4279-9d3a-43b1a0729f54-10826299.jpg)![](https://api.transno.com/v3/document_image/8472249d-5c8f-4e82-bf91-671eed5597e4-10826299.jpg)  


- 기존의 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것  


- 사용자 영역에서는 무슨일이 일어날까?  

- 그림![](https://api.transno.com/v3/document_image/21bee89a-581f-4230-8298-5df862bbd19a-10826299.jpg)  


- 코드영역  
- 기계어로 이루어진 명령어 저장  


- 데이터 영역  
- 프로그램이 실행되는 동안 유지할 데이터 EX)전역변수  


- 힙영역  
- 프로그래머가 직접 할당할 수 있는 저장공간  


- 스택영역  
- 데이터를 일시적으로 저장하는 공간  


- 10-2 프로세스 상태와 계층 구조 (P. 297)  

- 요약![](https://api.transno.com/v3/document_image/f5c160f6-08ae-4914-b9a8-4984239d4217-10826299.jpg)  


- 프로세스 상태  

- 그림![](https://api.transno.com/v3/document_image/96d8526d-7c07-45a3-8590-89de8aeb0924-10826299.jpg)  


- 생성상태  
- 메모리에 적재되어 PCB를 할당 받은 상태  


- 준비상태  
- CPU를 할당 받으면 당장이라도 실행 할 수 있는 상태  


- 실행상태  
- 실행 상태인 프로세스가 할당된 일정 시간동안만 CPU를 사용하는 상태  


- 대기상태  
- 요청 프로세스를 기달리는 상태  


- 종료상태  
- 종료된 상태  


- 계층구조  
- PPID  
- 부모 프로세스  


- 프로세스 생성 기법  

- 그림![](https://api.transno.com/v3/document_image/17d29e00-8ab1-4116-af59-c8d0ad9668fa-10826299.jpg)  
부모 프로세스를 통해 생성된 자식프로세스들은 복제와 옷 갈아입기를 통해 실행됨

- FORK  
- 자기 자신 프로세스의 복사본을 만드는 시스템 호출  


- EXEC  
- 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출  


- 10-3 스레드 (P. 307)  

- 요약![](https://api.transno.com/v3/document_image/b0032eed-78f1-4517-9665-74ffe454bd83-10826299.jpg)  


- 스레드  

- 그림![](https://api.transno.com/v3/document_image/92820570-66ab-49a6-8a45-721e3088ffff-10826299.jpg)  


- 프로세스를 구성하는 실행의 흐름 단위  


- 단일 프로세스 VS 멀티 프로세스  

- 단일![](https://api.transno.com/v3/document_image/e7c31a3a-7bfb-44b5-8773-a1f2feb65a5e-10826299.jpg)  
실행 흐름이 하나인 것

- 멀티![](https://api.transno.com/v3/document_image/977bce00-7981-45e7-abfc-f3a812bfed64-10826299.jpg)  
여러 명령어를 동시에 수행할 수 있음

- 멀티 프로세스 VS 멀티 쓰레드  

- 구조  

- 멀티 프로세스![](https://api.transno.com/v3/document_image/02d4075d-39c1-4c11-ad0f-a99fc0d69b27-10826299.jpg)  
자원을 공유하지 않기 때문에 독립적으로 동작함

- 멀티 쓰레드![](https://api.transno.com/v3/document_image/502163c0-3e20-40b8-88c2-81e35ac7d4a6-10826299.jpg)  
자원을 공유하여 사용하기 때문에 하나의 스레드가 문제가 생기면 나머지 쓰레드도 영향 받음

- 실제 실행 했을떄는 어떤 차이가 있을까?![](https://api.transno.com/v3/document_image/3da5f095-ef00-4690-93e6-55c882fbb917-10826299.jpg)  
멀티 프로세스는 같은 프로그램을 실행하기 위해 위의 그림과 같이 메모리에 동알한 내용을 중복해서 존재하게 된다.  
멀티 쓰레드는 같은 프로세스 내에서는 자원을 공유하여 메모리 소모가 적음

- 그러면 멀티 프로세스는 공유할 수 있는 방법이 아예 없나?  

- 프로세스 간의 통신  
파일을 통한 프로세스 간의 통신

- 공유 메모리![](https://api.transno.com/v3/document_image/61a8d043-3e5a-4831-ac18-a63d890c2ee0-10826299.jpg)  
공유할 수 있는 메모리 영역 만들기
- Chapter 11 CPU 스케줄링  

- 11-1 CPU 스케줄링 개요 (P. 317)  

- 요약![](https://api.transno.com/v3/document_image/8d0da5d8-bcf4-4729-9dc5-08a8d24ef660-10826299.jpg)  


- CPU 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/7163e2ca-2704-4cf3-82c5-ebf712a0d1dc-10826299.jpg)  


- 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하기 위함  


- 어떻게 CPU 자원을 배분할까?  
- PCB에 적힌 우선순위 + 입출력 < CPU 프로세스에 순서![](https://api.transno.com/v3/document_image/c10ce9ca-a969-41bd-bc07-ef32f2336b1a-10826299.jpg)  


- 우선순위 PCB를 일일히 찾아야 할까?  

- 상황![](https://api.transno.com/v3/document_image/31203b31-c1d4-42e9-ab27-72b13f07fe22-10826299.jpg)  
일일히 찾는 것은 오리 걸리니깐 줄서서 기다리게 함. 이것이 스케줄링 큐

- 스케쥴링 큐 있으면![](https://api.transno.com/v3/document_image/bc4f931b-aaff-4e5d-9106-5c9e72c226af-10826299.jpg)![](https://api.transno.com/v3/document_image/55e0a7b2-11cf-4b15-9b6a-37891afface0-10826299.jpg)  


- 갑자기 급한 프로세스가 오면 어떻게 해야할까?  

- 상황![](https://api.transno.com/v3/document_image/4ccd5b2b-477a-4b26-9251-5cfaf73eec03-10826299.jpg)  


- 방법1) 강제로 뺏어서 먼저 실행하는 선점형 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/216d6936-c27d-422a-9cc4-3056b36bbe3a-10826299.jpg)  


- 독점 불가능 WHY? 뺏을 수 있으니깐  


- 문맥 교환 과정에서 오버헤드 발생 할 수 있음  
- 오버헤드란 간접시간  


- 방법 2) 종료되기만 기다리는 비선점형 스케줄링  

- 그림 ![](https://api.transno.com/v3/document_image/2835344a-d322-4060-847a-11c8d71948b4-10826299.jpg)  


- 자원 독점 가능  


- 11-2 CPU 스케줄링 알고리즘 (P. 329)  

- 요약![](https://api.transno.com/v3/document_image/f256a766-4abc-4808-9936-f554fea9907e-10826299.jpg)  


- 스케쥴링 알고리즘  

- 선입 선출 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/7bd53f89-63c2-4ef1-9e02-7296db3d55b3-10826299.jpg)  


- 먼저 들어간 프로세스부터 처리하는 알고리즘  


- 기다리는 시간이 길어질 수 있음  


- 최단 작업 우선 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/c3597a52-b9a2-45b6-9bd5-1440124279d4-10826299.jpg)  


- CPU 이용 시간이 짧은 프로세스부터 실행하는 비선점형 스케줄링  


- 라운드 로빈 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/d4ad0aac-52b9-40ec-937a-04e831cb7eb7-10826299.jpg)  


- 타임슬라스(정해진 CPU 사용시간)만큼 시간 동안 돌아가며 사용하는 선점형 스케줄링  


- 문맥교환 비용이 커질 수 있음  


- 최소 잔여 시간 우선 스케줄링  
- 최단 작업 우선 스케줄링을 선점형으로 바꾼 스케줄링(라운드 로빈도 사용)  


- 우선순위 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/ba504f64-9139-4446-87d5-758c27ed38d2-10826299.jpg)  


- 가장 높은 우선순위를 가진 프로세스부터 실행하는 선점형 스케줄링  


- 뒤로 계속 밀릴수 있음(=기아현상) 그래서 오래 대기하면 우선순위 높여줌(=에이징기법)  


- 다단계 큐 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/7d158962-2cdb-45ed-8ef6-3dff9811343e-10826299.jpg)  


- 우선 순위별로 준비 큐를 여러개 사용하여 구현하는 방법  


- 큐마다 다른 스케줄링 알고리즘 사용가능  


- 다단계 피드백 큐 스케줄링  

- 그림![](https://api.transno.com/v3/document_image/8ac9e758-1588-4800-a5ff-9eee6e0005ab-10826299.jpg)  


- 다단계 큐에서 큐 사이를 이동할 수 있게 보완한 스케줄링  

- Chapter 12 프로세스 동기화  

- 12-1 동기화란 (P. 341)  

- 요약![](https://api.transno.com/v3/document_image/fc577c6c-e793-48a9-a5ae-def0f79807a1-10826299.jpg)  


- 동기화란?  

- 그림![](https://api.transno.com/v3/document_image/b72f67f0-58f0-4218-8065-e2c707c2550b-10826299.jpg)  


- 프로세스의 실행 순서와 자원의 일관성을 보장하기 위함(실행순서 제어 + 상호 배제)  


- 실행순서 제어란?  

- 그림![](https://api.transno.com/v3/document_image/8f2aab2c-c72b-4d06-9deb-5ee765779321-10826299.jpg)  


- 읽고 난후 쓰기가 가능한것 처럼 올바른 순서 보장하게 해줌  


- 상호배제란?  

- 동시 접근 금지  


- IF 동시에 접근하게 되면?  
- 그림![](https://api.transno.com/v3/document_image/8937ca67-6ee5-4862-9b82-d074cfc6fb6e-10826299.jpg)  
A, B가 2,5만원을 더해서 17만원이 되어야 되는데. 데이터를 동시에 사용하여 데이터 사용이 끝나기도 전에 접근해서

- 공유자원과 임계구역  

- 그림![](https://api.transno.com/v3/document_image/163001b3-8077-41d3-b2d6-cd0354a4509f-10826299.jpg)  


- 임계구역  
- 동시에 실행하면 문제가 발생하는 코드 영역  


- 레이스 컨디션  

- 레이스 컨디션이란?  
- 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우  


- 레이이스 컨디션이 발생하면 데이터의 일관성이 깨짐  


- 언제 발생하게 될까?  
- 그림![](https://api.transno.com/v3/document_image/5d380133-de2d-4d86-ac08-184b4cba4e56-10826299.jpg)  


- 상호 배제를 위한 동기화 3가지 원칙  

- 상호배제  
- 임계 구역에 진입했다면 다른 프로세스는 접근할 수 없음  


- 진행  
- 임계 구역에 프로세스가 없다면, 진입할 수 있어야함  


- 유한 대기  
- 한 프로세스가 임계구역에 진입하고 싶다면, 임계 구역에 들어올 수 있어야함. 무한정 대기 X  


- 12-2 공유 자원과 임계 구역 (P. 351)  

- 요약![](https://api.transno.com/v3/document_image/5640401a-01cd-48bc-8332-cf56957c0f6b-10826299.jpg)  


- 동기화를 시키는 방법에 알아보자  


- 뮤텍스 락  

- 그림![](https://api.transno.com/v3/document_image/94f7aad6-428d-4f7c-8b29-3e28ac1ede31-10826299.jpg)  
탈의실을 열어보고 자물쇠가 있다면 기다리기 아니면 탈의실 이용하기

- 단, 탈의실 문을 잠겼는지 계속 반복함(바쁜대기)  


- 하나의 공유 자원에 접근하는 방식  


- 코드![](https://api.transno.com/v3/document_image/9c737aae-86d0-4bac-abdc-11e82e87b4ef-10826299.jpg)![](https://api.transno.com/v3/document_image/f9e54643-7704-4d66-b5b5-6a5408a896f3-10826299.jpg)  
lock -> 자물쇠 역할  
​acquire -> 임계구역을 잠그는 역할  
release -> 임계구역의 잠금을 해제하는 역할  


- 세마포  

- 그림![](https://api.transno.com/v3/document_image/8ec1e739-67e7-49c3-a452-302ce86d9acb-10826299.jpg)  
탈의실이 여러 개 있는 상황처럼 공유자원이 여러개 있을때 각각 공유 자원에 접근 가능

- 용어![](https://api.transno.com/v3/document_image/33686937-04ba-4f07-92d7-06a2a4be94cf-10826299.jpg)  


- 대기 방식(대기 -> 준비)  

- 해당 프로세스를 대기상태로 만들기  


- PCB를 대기큐에 넣기  


- SINGNAL 함수가 호출하면 대기큐에서 제거하기  


- 준비상태로 바꾸기  


- 준비 큐로 옮기기  


- 모니터  

- 그림![](https://api.transno.com/v3/document_image/97faa0a4-fb2e-47b0-be5d-e90961966ece-10826299.jpg)  


- 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리함. 그리고 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근  


- 조건변수를 통해서 프로세스 실행 순서를 제어함  

- Chapter 13 교착 상태  

- 13-1 교착 상태란 (P.367)  

- 요약![](https://api.transno.com/v3/document_image/f332a310-bc88-4d21-9817-0e898c0021b2-10826299.jpg)  


- 교착상태  

- 그림![](https://api.transno.com/v3/document_image/bf66019f-9f70-47d8-bf83-79b83895769c-10826299.jpg)![](https://api.transno.com/v3/document_image/f940a17a-7e05-4741-abdb-c850805e2bc5-10826299.jpg)  
프로세스는 원,  
​자원 종류는 사각형,  
​사용중이면 프로세스쪽 화살표,  
대기중이면 자원쪽 화살표

- 두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다린다면 그 어떤 프로세스도 더이상 진행할 수 없는 교착상태가 됌  


- 교착상태 발생 조건  

- 4가지 모두가 만족해야지 발생할 가능성이 생김  


- 상호배제  
- 하나의 자원은 하나의 프로세스만 이용가능  


- 점유대기  
- 자원을 보유한채 다른 자원을 기다림  


- 비선점  
- 다른 프로세스가 강제로 자원을 뺏을 수 없음  


- 원형대기  
- 프로세스들의 요청과 자원이 원의 형태  


- 13-2 교착 상태 해결 방법 (P. 377)  

- 요약![](https://api.transno.com/v3/document_image/a7fd459a-9ba2-4d2c-95b3-965975fe061b-10826299.jpg)  


- 교착상태 예방  

- 상호배제를 없애면?  
- 모든 자원 공유하면.. 말이 안됌![](https://api.transno.com/v3/document_image/1e05dfc4-7506-4a75-8a6d-6de1d9b5fb3f-10826299.jpg)  


- 점유와 대기를 없애면?  
- 자원의 활용율 낮아짐 + 많은 자원을 필요로하는 프로세스가 더 많이 기다리게 되는 현상  


- 비선점 조건을 없애면?  
- 프린트를 예로 들면 프린트 출력중 갑자기 뺏어서 사용한다고? 말이 안됌  


- 원형 대기 조건을 없애면?  
- 모든 자원을 순서있게 정렬하자 OK![](https://api.transno.com/v3/document_image/6f7179fd-756d-4d90-a06b-79c51c191552-10826299.jpg)  


- 교착 상태 회피  

- 예시 매커니즘  

- 1) 해당 자원을운영체제에 요청  


- 2) 자원 할당 받기  


- 3) 자원 사용이 끝났으면 사용한 모든 자원 반환하기  


- 안정상태 예시  

- 교착상태가 발생하지 않는 상태  


- 순서 : P2 -> P1 -> P3![](https://api.transno.com/v3/document_image/ab2a5270-252d-4ecc-b9f6-1fa09e3ad04e-10826299.jpg)  


- 불완전상태 예시  

- 교착상태가 발생한는 상태  


- 순서 : P2 -> P1 -> P3![](https://api.transno.com/v3/document_image/9b5c1a2d-ab21-4adf-aab9-dba638039ac2-10826299.jpg)  


- 교착 상태 검출 후 회복  

- 1)선점을 통한 회복  
- 다른 프로세스로부터 자원을 강제로 빼앗고 다른 프로세스에게 할당하는 방식  


- 2)프로세스 강제 종료를 통한 회복  
- 교착 상태가 없어질 때까지 한 프로세스씩 종료하는 방식  


- 3)타조알고리즘  
- 교착상태 무시하기  

- Chapter 14 가상 메모리  

- 14-1 연속 메모리 할당 (P. 391)  

- 요약![](https://api.transno.com/v3/document_image/a5321585-346c-4e09-802e-579a1feef1c9-10826299.jpg)  


- 배경  
- 우리는 지금까지 메모리가 연속적으로 적재되어있는 경우를 고려했다. 이를 위해서 고려해야 될점과 문제점은 어떤 것이 있는지 알아보자![](https://api.transno.com/v3/document_image/b4a98219-1c1e-4212-886c-6512e35bd5c6-10826299.jpg)  


- 스와핑  

- 스와핑이란?  
- 대기상태, 오랫동안 사용되지 않은 프로세스를 메모리에서 보조기억장치로 보내고, 새로 생긴 공간에 다른 메모를 적재하는 방식  


- 스왑영역?  

- 쫓겨난 영역  


- 그림![](https://api.transno.com/v3/document_image/f9172d61-a51e-4e2e-8eba-63ffa52cf816-10826299.jpg)![](https://api.transno.com/v3/document_image/00f333e1-5544-478c-aa1b-3ddce76ca70a-10826299.jpg)  


- 메모리 할당  

- 메모리 내에 빈 공간이 있다면 어디에 배치를 해야할까?  


- 그림![](https://api.transno.com/v3/document_image/f3f3fc12-b9e1-4568-9b28-ea53941f9a83-10826299.jpg)  


- 1)최초 적합  
- 빈 공간을 순서대로 검색하다가 발견하면 바로 배치하는 방식  


- 2) 최적 적합  
- 빈 공간을 모두 검색한 후, 남은 공간중에서 가장 작은 공간에 배치하는 방식  


- 3) 최악 적합  
- 빈 공간을 모두 검색한 후, 남은 공간중에서 가장 큰 공간에 배치하는 방식  


- 외부 단편화  

- 프로세스를 할당하기 어려울 만큼 작은 메모리 공간으로 메모리가 낭비되는 현상  


- 그림![](https://api.transno.com/v3/document_image/e79ffc3e-1a1e-4037-a18d-5ad0fec4544a-10826299.jpg)  
남은 공간이 50MB이라도 50MB 프로세스가 적재할 수 없는 형태가 됌

- 해결방안 -> 압축  

- 흩어져 있는 작은 빈공간을 모아서 하나의 큰 공간으로 만들기  


- 그림![](https://api.transno.com/v3/document_image/15cde5b5-503b-41b1-97ec-229be698ffce-10826299.jpg)  


- 단점은 하던일을 중지 + 오버헤드 발생  


- 14-2 페이징을 통한 가상 메모리 관리 (P. 403)  

- 요약![](https://api.transno.com/v3/document_image/a41867a0-c331-42cb-aa3e-5dee922ecba1-10826299.jpg)  


- 메모리 연속적으로 할당하는 방식은 2가지 문제점  

- 외부 단편화![](https://api.transno.com/v3/document_image/e79ffc3e-1a1e-4037-a18d-5ad0fec4544a-10826299.jpg)  


- 물리 메모리보다 큰 프로세스를 실행할 수 X![](https://api.transno.com/v3/document_image/682ec857-e0ad-4c27-b672-4f88b481c021-10826299.jpg)  


- 페이징  

- 페이징이란?  
- 메모리의 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 페이지를 프레임에 할당하는 기법  


- 그림![](https://api.transno.com/v3/document_image/35b8019e-8e1a-4b16-bc5f-531dc1a2beba-10826299.jpg)  


- 스왑인/아웃 설명![](https://api.transno.com/v3/document_image/cac05da9-07c2-4a81-bf03-8f2f1cb95713-10826299.jpg)  


- 페이지 테이블  

- 프로세스가 불연속적으로 배치되면 CPU입장에서는 다음에 실행할 명령어 찾기 힘든 문제점  


- 페이지 테이블  
- 논리 주소는 연속적으로 배치하는 방법  


- 그림![](https://api.transno.com/v3/document_image/5036181e-ddf6-4e16-a227-2ae5c5c710d3-10826299.jpg)  


- 페이지 테이블 베이스 레지스터(PTBR) -> 각 프로세스의 페이지 테이블이 적재된 주소![](https://api.transno.com/v3/document_image/cc45bb35-69c9-4c93-aaf2-0423bfa30014-10826299.jpg)  


- (문제점) CPU는 총 메모리 사용을 2번하게 된다. 그래서 메모리 접근시간을 늘릴 필요가 있음  

- 그림![](https://api.transno.com/v3/document_image/209b15ca-e0a3-4c1b-8a57-b69329eb4bd4-10826299.jpg)  


- 해결책  
- CPU 곁에 TLB라는 페이지 테이블의 캐시 메모리에 둠![](https://api.transno.com/v3/document_image/73331554-2c80-4e8d-b66f-99badbf8bad9-10826299.jpg)  


- (문제점) 접근까지 OK 이제 해당 주소를 어떻게 찾아야 될까?  

- 그림![](https://api.transno.com/v3/document_image/e60b31fd-b4ed-45b5-ae6d-5f841e68ea18-10826299.jpg)  
1) 접근 하려는 페이지 OR 프레임 알아야함  
​2) 접근 주소가 프로세스 내에서 얼마나 떨어져 있는지 알아야됌

- (해결책) 1번은 페이지/프레임 번호 , 2번은 변위![](https://api.transno.com/v3/document_image/38c7de09-3663-4dc7-90d7-9c9ad0c4a953-10826299.jpg)  


- 예시) 논리주소(<5, 2>)는 몇번지 물리주소인가? 10번지![](https://api.transno.com/v3/document_image/0f6226cb-fa6d-45e0-a711-292210be482e-10826299.jpg)  


- 페이지 테이블 엔트리  

- 페이지/프레임 번호, 변위 외의 중요 정보는 어떤게 있을까?  


- 페이지 테이블 엔트리 -> 테이블의 행을 의미함![](https://api.transno.com/v3/document_image/4fe45bd9-deee-4a49-84a4-712282fbfe2b-10826299.jpg)  


- 유효비트  
- 현재 페이지가 메모리에 있는지/보조기억장치에 있는지 알려줌  


- 보호 비트  
- 접근 권한 설정![](https://api.transno.com/v3/document_image/7612e11e-b88d-4844-92d3-0735519842e4-10826299.jpg)  


- 참조 비트  
- 접근한적 있는지 확인  


- 수정 비트  
- 수정한 적 있는지 WHY? 보조기억 장치 작업을 해야되는지 확인하기 위함  


- 14-3 페이지 교체와 프레임 할당(P. 425)  

- 그림![](https://api.transno.com/v3/document_image/7c27389d-d043-43fd-ba14-8ce47f7c0c66-10826299.jpg)  


- (배경) 프로세스의 프레임은 어느정도 차치하게 정해야될까?? 어떤 페이지를 내보내야할까?  
- 그림![](https://api.transno.com/v3/document_image/c3e96e09-8d46-46df-b057-015ed6751c62-10826299.jpg)  


- 요구페이징이란?  
- 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법  


- 페이지 교체 알고리즘이란?  
- 페이지 폴트를 가장 적게 일어나는 알고리즘  


- FIFO 페이지 교체 알고리즘  

- 그림![](https://api.transno.com/v3/document_image/02a5c453-9c28-4176-81f9-0333a2946477-10826299.jpg)  


- 적재된 페이지 순서대로 교체하는 알고리즘  


- 단점 -> 자주 사용하는 페이지가 오래되었다는 이유로 내보내줄 수 있음  


- 해결법 -> 참조비트를 참고해서 기회 한번 더 주기  


- 최적 페이지 교체 알고리즘  

- 그림![](https://api.transno.com/v3/document_image/7e5454e6-92d7-4987-b0cf-20984ed12c14-10826299.jpg)  


- 앞으로의 사용 빈도가 낮은 페이지를 교체하는 알고리즘  


- 어떻게 앞으로 사용할지 안할지 알까?  
- 현실적으로 불가능해서 성능 평가 용도로 사용함  


- LRU 페이지 교체 알고리즘  

- 그림![](https://api.transno.com/v3/document_image/2c73eada-fb8a-46d1-b0ff-71fc6873b2d0-10826299.jpg)  


- 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘  


- 스래싱과 프레임 할당  

- 페이지 폴트가 발생하는 또다른 이유  
- 프레임 수의 차이![](https://api.transno.com/v3/document_image/69f46f74-7ac1-4452-b5ca-a8d7942d4209-10826299.jpg)  


- 스래싱이란?  

- 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제  


- 그림![](https://api.transno.com/v3/document_image/760e97d6-3fed-4558-89e0-2096c18be131-10826299.jpg)  


- 프레임 할당 방식  

- 균등 할당  


- 비례 할당  
- 프로세스 크기에 따라 비례해서 프레임 할당하는 방식  


- 작업 집합 모델  
- 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 페이지 교체 방지하는 방식  


- 페이지 폴트 빈도 방식  
- 페이지 폴트율의 상한선과 하한선을 정하고 그 범위 안에서 프레임 할당하는 방식  

- Chapter 15 파일 시스템  

- 15-1 파일과 디렉터리  


- 15-2 파일 시스템