[대규모 서비스를 지탱하는 기술 1~5장 (문제 해결을 위한 근본 접근법) (tistory.com)](https://jeong-pro.tistory.com/235)
[[웹 개발자를 위한 대규모 서비스를 지탱하는 기술] (tistory.com)](https://emgc.tistory.com/122)

# 1. 대규모 웹 서비스 개발  

#### 📌대규모의 정의는?  
- 트래픽이나 저장된 데이터의 용량이 일정 기준을 넘었냐가 기준이 아니다.  
- 서버 1대로 원활한 서비스를 제공할 수 없어 **스케일아웃(scale-out)이 필요한 경우**를 대규모로 정의한다. (책이 아닌 필자 개인 의견)  
- 그 이유는 웹 서버, DB, ... 등 여러 미들웨어를 포함하여 확장이 일어날 때 고려해야할 것들이 굉장히 많아지고 시행착오를 겪기 때문이다.  
![[Pasted image 20230517203627.png]]


#### 📌소규모 서비스와 대규모 서비스의 차이는?
1. **확장성 확보, 부하분산 필요**  
- 스케일아웃을 가정하고 고민해볼만한 것  
	- 요청을 어떻게 **여러 서버에 분산**할 것인가?  
	- DB를 분산했을 때 **데이터 동기화 문제처리**는 어떻게 할 것인가?  
	- 분산 환경에서 주는 **네트워크 지연시간**(latency)은 어떻게 처리할까?  
	- 서비스간 **트랜잭션 처리**, 장애 복구는 어떻게 할까?  
	- 여러 대 운용은 어떻게 **자동화**할 것인가?  

2. **다중성 확보**  
- 서버가 고장나더라도 혹은 급격하게 부하가 올라갈 경우에도 **견딜 수 있는 시스템**을 구성할 필요  

3. **효율적 운용 필요**  
- 서버 일정 숫자 넘어가면 소프트웨어를 사용하고 정보관리를 위한 툴을 사용하는 등 **자동화**해야함  
- 부하는 괜찮은지  
- 고장 난 부분은 없는지  
- 디스크 용량은 아직 충분한지  
- 보안설정에 미비한 점은 없는지  

4. 개발자 수, **개발방법의 변화**  
- 혼자서는 개발이나 운용이 어려워지므로 여러 기술자가 **역할을 분담**  
- 프로그래밍 언어를 통일하고  
- 라이브러리나 프레임워크를 통일하고  
- 코딩 규약을 정해서 표준화하고  
- 소스코드 관리를 버전관리 시스템  


#### 📌대규모 데이터량에 대한 대처방안은?
▶컴퓨터 처리 과정  
- **디스크→메모리→캐시 메모리→레지스터(CPU)** 와 같이 몇 단계를 경유해서 처리  
- BUT 속도차이 심함 그래서 이 속도차를 흡수하기 위해 OS는 이런저런 방법을 사용하게 됩니다.  
- 예를 들면 디스크로부터 읽어들인 데이터를 메모리에 캐싱해둠으로써 전반적으로 디바이스간 속도차가 체감속도에 영향을 주지 않도록 하고 있습니다  

▶데이터량이 많아지면?  
- 처음부터 **캐시 미스**(cache miss)가 많이 발생하게 되고, 그 결과로 저속의 디스크로의 **I/O가 많이 발생**하게 됩니다. 디스크 I/O 대기에 들어선 프로그램은 다른 리소스가 비어 있더라도 읽기가 완료되기까지는 다음 처리를 수행할 수가 없습니다. 이것이 시스템 전체의 **속도저하**를 의미함.


# 2. 대규모 데이터 처리 입문  

#### 📌대규모 데이터로(예시를 3억개 정도)의 쿼리정도 되면?  
```
mysql> select url from entry use index(hoge) where eid= -9615899;
=> 200초를 기다려도 결과가 출력되지 않는다.(부하걸림)
```


#### 📌메모리와 디스크 관점에서 대규모 데이터의 어려운 점은?
 대규모 데이터의 어려움은 **메모리 내에서 계산할 수 없다**는 점이다. 메모리 내에서 계산할 수 없게 되면 디스크에 있는 데이터를 검색할 필요가 있다.  그래서 I/O가 필요하다. 하지만 디스크는 느리므로 I/O(Input/Output)에 시간이 걸린다.  


#### 📌왜 디스크가 메모리보다 느리지?  
![[Pasted image 20230520064143.png]]
▶탐색속도  
- 헤드의 이동과 원반의 회전이라는 **물리적 이동을 필요함**. (메모리가 10⁵~10⁶배정도 빠름)

▶전송속도  
- 데이터를 **디스크에서 메모리로 보내야**하기 때문임. (메모리가 100배정도 빠름)  


#### 📌부하의 종류는?  
1.  **CPU 부하**: 대규모 **연산** 작업, 예를 들어 복잡한 수학적 계산이나 대량의 데이터를 처리하는 머신러닝 작업 등이 CPU 부하를 많이 발생시킬 수 있습니다. 이러한 작업은 CPU 시간을 많이 소모하므로, CPU 사용률이 100%에 가까워질 수 있습니다.

2.  **메모리 부하**: 많은 양의 데이터를 **메모리에 로드**해야 하는 작업, 예를 들어 대용량 데이터베이스를 메모리에 로드하거나, 매우 큰 데이터 구조를 메모리에 유지해야 하는 경우 메모리 부하가 높아질 수 있습니다. 이러한 상황에서는 가용 메모리가 거의 없어질 수 있습니다.

3.  **디스크 I/O 부하**: 대량의 **데이터를 읽고 쓰는 작업**, 예를 들어 대용량 로그 파일을 생성하거나, 대규모 데이터베이스 작업을 수행하는 경우 디스크 I/O 부하가 높아질 수 있습니다. 이러한 작업은 디스크의 읽기/쓰기 작업을 많이 발생시키므로 디스크 I/O 부하가 증가합니다.

4.  **네트워크 부하**: 대량의 네트워크 **트래픽을 처리**해야 하는 작업, 예를 들어 동시에 많은 사용자가 웹 사이트에 액세스하거나, 대용량 파일을 다운로드 받는 경우 네트워크 부하가 높아질 수 있습니다. 이런 경우에는 네트워크 대역폭이 크게 사용되므로 네트워크 부하가 증가합니다.


#### 📌Load Average란?
- Load Average란 **시스템 전체의 부하상황을 나타내는 지표**로, top 또는 uptime 등의 명령어로 시스템 전체에 부하상황을 확인한다.  


#### 📌부하의 병목 찾아내는 과정은?
1. **Load Average 확인**
- Load Average가 높지 않다면? 네트워크, 원격 호스트등에 문제가 없는지 확인한다.  (**컴퓨터 외부**에서 찾기)
- Load Average가 높다면? CPU인지 I/O인지 확인한다.  (**컴퓨터 내부**에서 찾기)


#### 📌AP서버와 DB서버란?
- **AP 서버**란?   용자 요청을 처리하는 애플리케이션 로직을 실행하는 서버입니다. HTTP 뿐 아니라 TCP, UDP 등 **다양한 프로토콜을 전달**해줍니다.
- **DB 서버**란?   데이터베이스를 호스팅하는 서버로, **데이터 관리와 처리**를 담당합니다.

#### 📌웹 애플리케이션은 어디서 부하가 걸릴까?
![[Pasted image 20230517193601.png]]  
1) 2번의 **AP서버에서 CPU부하 걸림**  
=> 해결책 : 무상태 프로토콜이니깐 요청만 **로드 밸런서 장치로 균등하게 분배**해주면됌  
​  
2) 3번 **DB서버에서 I/O부하가 걸림**  
=> 성능적 개선과 동기화적 문제를 해결해야하는 복잡적인 상황


#### 📌I/O부하 걸릴때, 성능적 개선하는 방법은?
1. **하드웨어 업그레이드**: 더 빠른 디스크나 SSD로 업그레이드하거나, I/O 속도를 향상시키는 데 도움이 되는 다른 하드웨어 개선을 고려해 볼 수 있습니다. 예를 들어, RAID 설정은 여러 디스크 간에 데이터를 분산시켜 I/O 작업을 빠르게 처리하는 데 도움이 될 수 있습니다.

2. **소프트웨어 최적화**: I/O 작업을 줄이는 방법으로 애플리케이션을 최적화할 수 있습니다. 예를 들어, 데이터베이스 쿼리를 최적화하거나, 불필요한 파일 작업을 줄이는 등의 방법이 있습니다.

3. **캐싱**: 자주 액세스하는 데이터를 메모리에 캐시하는 것은 디스크 I/O를 크게 줄일 수 있습니다. 이는 데이터베이스의 경우 특히 유용한 전략이 될 수 있습니다.

4. **비동기 I/O**: 가능하다면, 비동기 I/O를 사용하는 것이 좋습니다. 이렇게 하면 프로세스가 I/O 작업을 기다리는 동안 다른 작업을 계속할 수 있습니다.

5. **분산 시스템**: 큰 규모의 시스템에서는, I/O 부하를 여러 서버나 디스크에 분산시키는 것이 효과적일 수 있습니다. 이는 특히 클라우드 환경에서 유용합니다.

#### 📌I/O 동기화문제 해결 방법은?
=> 동기화 문제는 멀티 스레드나 멀티 프로세스 환경에서 **공유 자원에 대한 접근을 제어**하는 과정에서 발생하는 문제를 말합니다. 동기화를 통해 여러 프로세스 또는 스레드가 동시에 같은 자원에 접근하는 것을 방지하거나, 순서를 제어하여 데이터의 일관성을 유지하고 경쟁 조건(race condition)을 방지하는 것이 목표입니다.

1. **뮤텍스(Mutex)**: Mutex는 'Mutual Exclusion'의 줄임말로, 한 번에 하나의 스레드만이 공유 자원에 접근할 수 있도록 하는 기본 도구입니다. 스레드는 뮤텍스를 '잠그고(lock)', '푸는(unlock)' 과정을 거쳐 자원에 접근합니다. 

2. **세마포어(Semaphore)**: 세마포어는 뮤텍스와 유사하지만, 한 번에 여러 스레드가 공유 자원에 접근할 수 있게 해주는 도구입니다. 세마포어는 '시그널(signal)', '대기(wait)' 과정을 통해 자원에 접근합니다.

3. **모니터(Monitor)**: 모니터는 공유 자원에 대한 접근을 제어하는 추상화된 방식으로, 특정 객체 또는 메서드에 대한 동시 접근을 제어합니다.


#### 📌대규모 데이터를 다루는 3가지 중점은?
1) 어떻게 하면 **메모리에서 처리**를 마칠수 있을까?  
- 왜 메모리지? 디스크가 아니고? 디스크 seek 횟수를 최소화하기 위해 메모리 활용하자  

2) 데이터량 증가에 강한 **알고리즘** 사용하자  
- 선형검색 -> 이분검색, Q(n) -> Q(log(n))

3) **데이터 압축이나 검색기술**과 같은 테크닉이 활용하자  
- 압축하면 데이터량 줄어서 seek횟수 적어짐,메모리 캐싱 쉬워짐  
- 특정 용도에 특화된 검색엔진 만들어서 속도 확보하자  


#### 📌대규모 데이터를 다루기 전 3개의 전제지식은?
1. OS 캐시(→ 제3장)  
2. 분산을 고려한 RDBMS 운용(→ 제4장)  
3. 알고리즘과 데이터 구조(제5장)

# 3. OS 캐시와 분산  
#### 📌OS의 구조를 알아야하는 이유는?
=> 디스크와 메모리 간 속도차는 10⁵~10⁶배 이상 차이가 남. 그래서 메모리를 이용해서 디스크 액세스를 줄이고자 한다. 

#### 📌I/O 부하를 줄이는 방법은?
1. **캐싱:** 캐싱은 자주 사용되는 데이터를 빠른 접근 가능한 저장소에 보관하는 프로세스입니다. 일반적으로 이 저장소는 메인 메모리(RAM)나 고속 SSD와 같은 빠른 스토리지 장치입니다. 캐시를 사용하면 데이터를 처음부터 다시 읽지 않아도 되기 때문에 I/O 요청이 크게 줄어듭니다. 이는 디스크 I/O 부하를 크게 줄일 수 있습니다.

    예를 들어, 웹 서버가 자주 접근하는 웹 페이지를 캐시에 저장하면, 해당 페이지에 대한 후속 요청을 처리할 때 디스크에서 페이지를 다시 읽을 필요가 없습니다. 따라서 I/O 부하가 줄어들고 응답 시간이 단축됩니다.

2. **데이터 압축:** 데이터 압축은 데이터의 크기를 줄여 저장 공간을 절약하고 I/O 요청을 줄이는 데 도움이 됩니다. 압축된 데이터를 읽거나 쓸 때는 압축 해제나 압축 과정이 필요하므로 CPU 부하가 증가할 수 있지만, 데이터 전송량과 디스크 공간 사용량이 줄어들기 때문에 I/O 부하는 감소합니다.

    예를 들어, 데이터베이스 서버는 대량의 데이터를 압축하여 저장할 수 있습니다. 이 경우, 디스크에서 데이터를 읽을 때 필요한 I/O 작업이 줄어들어 성능이 향상될 수 있습니다. 

이러한 전략들은 상황에 따라 적용하며, 시스템의 특성, 워크로드의 특성 등을 고려해야 합니다. 예를 들어, CPU 부하가 이미 높은 시스템에서는 데이터 압축을 과도하게 사용하면 성능이 저하될 수 있습니다. 이런 경우 캐싱이 더 효과적일 수 있습니다. 이와 같이, 가장 효과적인 전략은 각각의 시스템과 워크로드에 따라 다를 수 있습니다.


#### 📌데이터 압축을 하는 방법은?
각 압축 알고리즘은 **특정 패턴을 찾아 데이터를 더 효율적인 형식으로 재표현**합니다. 예를 들어, 런-길이 코딩은 같은 값이 연속으로 나오는 것을 감지하여, 예를 들면 **'AAAABBBB'를 '4A4B'로 압축**합니다. 이러한 방법을 통해 데이터를 더 작은 공간에 저장할 수 있습니다.


#### 📌데이터 압축의 종류는?
1. **비손실 압축:** 이 방법은 원본 데이터를 완벽하게 복원할 수 있도록 데이터를 압축합니다. 이 방법은 텍스트 파일, 스프레드시트, 코드 등과 같은 데이터에 주로 사용됩니다. 대표적인 비손실 압축 알고리즘으로는 Huffman 코딩, 런-길이 코딩, ZIP, GZIP, Lempel–Ziv–Welch (LZW) 등이 있습니다.

2. **손실 압축:** 이 방법은 압축 과정에서 일부 데이터를 손실하는 방식입니다. 손실 압축은 보통 오디오, 비디오, 이미지 등의 데이터에서 사용되며, 이러한 데이터는 약간의 품질 저하가 허용되는 경우가 많습니다. 대표적인 손실 압축 알고리즘으로는 JPEG(이미지), MP3(오디오), MPEG(비디오) 등이 있습니다.


#### 📌OS에 대한 내용 정리
[[가상메모리 배경지식 정리]]


#### 📌메모리에 1.5GB 정도 여유가 있을때, 4GB 파일을 캐싱할 수 있을까?
![[Pasted image 20230522103931.png]]
=> 사용할 디스크 상에 배치되어 있는 **블록만 읽어냄으로 캐싱**이 가능함.  만약 4GB 파일을 전부 읽게 되면, LRU로 과거 부분은 날라가게 되고 새로운 것만 남겨놓는 형태


#### 📌웹 애플리케이션 요청 매커니즘은?
![[Pasted image 20230522115721.png]]
1. 클라이언트의 요청: 사용자(클라이언트)는 웹 애플리케이션에 특정 작업을 요청합니다. 이 요청은 HTTP 요청 등의 형태로 웹 서버에 전달됩니다.

2. 프록시 서버: 클라이언트의 요청이 먼저 프록시 서버를 거치게 됩니다. 프록시 서버는 요청을 보안 검사하거나 캐시된 응답이 있는지 확인하는 등의 역할을 합니다. 캐시된 응답이 없고 요청이 유효하다면, 요청은 AP 서버로 전달됩니다.

3. AP 서버: AP 서버는 웹 애플리케이션의 로직을 처리하는 곳입니다. 이 서버는 클라이언트의 요청을 분석하고, 필요한 계산을 수행하거나 DB 서버에 데이터를 요청하는 등의 작업을 합니다.

4. DB 서버: AP 서버가 데이터를 필요로 할 경우, 이 요청은 DB 서버로 전달됩니다. DB 서버는 요청 받은 데이터를 검색하거나 수정하고, 그 결과를 AP 서버에게 반환합니다.

5. 응답 반환: AP 서버는 DB 서버로부터 받은 데이터를 바탕으로 최종 결과를 생성하고, 이를 클라이언트에게 응답 형태로 전달합니다. 이 응답은 다시 프록시 서버를 거쳐 클라이언트에게 전달됩니다.


#### 📌프록시, AP서버, DB서버의 역할은?
1. **프록시 서버 (Proxy Server):** 프록시 서버는 클라이언트와 인터넷 사이에 위치한 서버로서, **클라이언트의 요청을 대신 전달하고 응답을 받아 클라이언트에게 전달하는 역할**을 합니다. 프록시 서버는 보안, 익명성 보장, 캐시를 통한 성능 향상 등의 이점을 제공합니다. 프록시는 종류에 따라 HTTP 프록시, SOCKS 프록시, 전송 프록시, 리버스 프록시 등으로 나뉠 수 있습니다.

2. **AP 서버 (Application Server):** AP 서버는 클라이언트와 데이터베이스 사이에서 클라이언트의 요청을 처리하고 **데이터베이스와 상호작용하는 애플리케이션을 실행하는 서버**입니다. 일반적으로 웹 애플리케이션, 엔터프라이즈 소프트웨어 등의 백엔드 로직이 실행되는 곳입니다. AP 서버는 데이터 처리, 비즈니스 로직 처리, 인증, 권한 관리 등의 기능을 제공합니다.

3. **DB 서버 (Database Server):** DB 서버는 **데이터베이스 관리 시스템(DBMS)를 실행하는 서버**로, 데이터의 저장, 검색, 수정 등을 담당합니다. 사용자 또는 애플리케이션의 요청에 따라 데이터를 처리하고 결과를 반환합니다. DB 서버는 데이터의 무결성, 보안, 백업 등을 보장합니다.


#### 📌로드 밸런싱과 서버의 관계는?
서버로 들어오는 요청이 여러 서버 사이에 균등하게 분산되도록 하는 기술입니다.

1. **프록시 서버에서의 로드 밸런싱:** 프록시 서버를 통한 로드 밸런싱은 클라이언트의 요청을 여러 서버 사이에 분산하는 방법입니다. 프록시 서버는 클라이언트의 요청을 받고, 이 요청을 처리할 서버를 선택하여 요청을 전달합니다. 이를 통해 각 서버에 가해지는 부하를 줄이고, 서버 장애 발생시 서비스 중단 없이 다른 서버로 요청을 전달할 수 있습니다.

2. **AP 서버에서의 로드 밸런싱:** AP 서버에서 로드 밸런싱을 사용하는 경우, 클라이언트의 요청을 여러 AP 서버 사이에 분산합니다. 이 방식은 고성능의 웹 사이트나 애플리케이션에서 자주 사용되며, 많은 양의 트래픽을 처리하기 위해 필요합니다. 로드 밸런서는 클라이언트의 요청을 받아 여러 AP 서버 중 부하가 가장 적은 서버로 요청을 전달합니다.


#### 📌캐싱할 수 없는 대규모의 데이터인 경우에는?
=> 복수의 서버로 확장시켜야함. 이때 각 서버에 따라 서버를 늘려야 하는 이유가 다름
![[Pasted image 20230522115457.png]]
1) AP서버 : **CPU부하를 낮추고** 분산 시키기 위함
2) DB서버 : **캐시 용량**을 늘리고자 할때, **효율**을 늘리고자 할때


#### 📌DB서버에 단순히 확장성만 하면 안되는 이유는?
![[Pasted image 20230522133111.png]]


#### 📌캐시 용량을 늘리기 위해 여러 대의 서버로 확장시키는 방법은?
![[Pasted image 20230522134302.png]]
=> **액세스 패턴**을 이용해서 분산해보자.

예를 들어, 하테나 북마크를 보면 '인기 엔트리' 페이지를 표시하는 경우에는 인기 엔트리용 데이터베이스의 캐시 테이블을 많이 액세스하지만, 자신의 북마크 테이블을 액세스할 때, 즉 id naoya(필자 자신)의 북마크 테이블에 액세스하는 것과는 액세스 패턴이 전혀 다르다. 여기서 인기 엔트리로 액세스할 때는 DB 서버 1의 1, 그렇지 않을 때는 DB 서버 2 의 2'로 요청을 분배한다. 그렇게 하면 액 세스 A는 DB 서버의 1, 액세스 B는 DB 서버의 2'로 각각 분산된다. 이와 같이 분배하면 2로의 액세스는 사라진다. 그러면 2의 부분을 더 확보할 수 있게 됌.


#### 📌국소성을 고려한 분산하는 방법은?
1) RDBMS의 **테이블 단위 분할**
=> 4개의 테이블이 있다고 하면 1,2와 3,4를 각기 다른 서버로 관리하는 방법. 테이블이 서로 액세스 많이하는 경우에 같은 서버로 하는 것이 유리함.
![[Pasted image 20230522140234.png]]

2) **테이블 데이터 분할**
=> 특정 테이블 하나를 여러 개의 작은 테이블로 분할하는 방법임. 예를 들어, 첫문자를 기준으로 아래 그림과 같이 각기 다른 서버에 분할함. 하지만 데이터를 조절할때 번거로움이 있음.
![[Pasted image 20230522140607.png]]

3) **요청 패턴**에 의해 '섬'으로 분할
=>URL와 같은 HTTP 요청을 기준으로 나누는 방식. 이렇게 되면 캐싱하기 쉬운 요청, 어려운 요청(ex검색)을 기준으로 나뉘게 되고 높은 캐시 적중률을 낼 수 있음.
![[Pasted image 20230522140757.png]]


# 4.분산을 고려한 MYSQL 운용  

#### 📌분산을 고려한 MYSQL의 운용 3가지 포인트는?
1) OS 캐시 활용
=> 데이터량 < 물리 메모리 유지하자, 메모리가 부족할 경우에는 증설하자

2) 인덱스를 적절하게 설정
=> 인덱스를 만들면 B+트리 데이터 구조 생성. (선형탐색 -> 이분탐색으로 바뀜)

3) 확장을 전제로한 설계
=> 스키마 설계가 데이터 크기에 미치는 영향을 고려하자. 예를 들어, 3억개의 레코드가 있다고 생각하자. 칼럼을 하나만 추가한다며, 3억Ⅹ8bit=3GB로 데이터가 증가한다.


#### 📌정규화를 활용한다면?
![[Pasted image 20230522145903.png]]
=> 3번에서 잘라서 분할한다면 레코드가 많을수록 용량이 줄어든다. 단 쿼리가 복잡해져서 속도가 떨어지는 경우가 있음. 그래서 속도와 데이터 크기 간의 트레이드오프를 생각해야함.

#### 📌데이터를 저장할때, 이분트리보다 B트리가 더 좋은 이유는?
이진 트리에서는 노드마다 하나의 키 값을 가집니다. 이진 트리에 이들을 저장하면 다음과 같은 구조가 됩니다:
```
     50
   /   \
 30     70
 / \   /  \
20  40 60  80
```
검색을 하려면, 루트부터 시작하여 키 값이 찾는 값보다 작으면 왼쪽으로, 크면 오른쪽으로 이동하면 됩니다. 이는 매우 효율적인 방법이지만, 이진 트리가 균형을 잃게 되면 검색 시간이 길어질 수 있습니다.

B-트리에서는 노드마다 여러 키 값을 가질 수 있습니다. 예를 들어 위의 숫자들을 3차 B-트리에 저장하면 다음과 같은 구조가 됩니다:
```
       50
     /   \
 20   30 40  60 70  80
```
검색을 하려면, 루트부터 시작하여 각 노드의 키 값들을 차례로 비교하고, 찾는 값이 키 값보다 작으면 왼쪽, 크면 오른쪽으로 이동하면 됩니다. B-트리는 **항상 균형을 유지**하기 때문에 검색 시간이 일정합니다. **Q(log N)의 계산량**
또한, B-트리의 노드는 **디스크의 한 블록 크기와 일치**하므로, 디스크에서 노드를 읽는 데 필요한 **I/O 작업이 최소화**됩니다. 

#### 📌MySQL의 레플리케이션이란?
=>한 MySQL 서버(마스터)의 데이터 변경 사항을 다른 MySQL 서버(슬레이브)에 복제하는 기능입니다. 이렇게 되면 참조계열은 확장 가능하고, 갱신계열은 확장하지 못함.
![[Pasted image 20230522155230.png]]

#### 📌레플리케이션을 사용의 이점은?

1. **부하 분산**: 읽기 쿼리(read query)를 슬레이브에 분산시켜 마스터의 부하를 줄일 수 있습니다. 이를 통해 대규모 읽기 작업이 많은 애플리케이션의 성능을 향상시킬 수 있습니다.

2. **데이터 백업**: 슬레이브는 마스터의 백업 역할을 수행할 수 있습니다. 마스터에 문제가 발생하면, 슬레이브에서 데이터를 복원하거나 슬레이브를 새로운 마스터로 승격시킬 수 있습니다.

3. **고가용성**: 슬레이브를 이용해 데이터를 실시간으로 복제하므로, 마스터에 장애가 발생하더라도 서비스 중단 없이 데이터베이스 서비스를 계속할 수 있습니다.


#### 📌슬레이브는 변경사항을 어떻게 알까?
1. **마스터에서의 변경**: 사용자가 마스터 서버에서 새로운 레코드를 추가하거나 기존 레코드를 변경하거나 삭제하는 SQL 쿼리를 실행합니다. 예를 들어, 사용자가 "INSERT INTO orders (id, product) VALUES (1, 'Apple')"라는 쿼리를 실행했다고 가정합시다.

2. **바이너리 로그 기록**: 마스터 서버는 이 변경 사항을 바이너리 로그에 기록합니다. 바이너리 로그는 레코드 추가, 변경, 삭제 등의 모든 데이터베이스 변경 사항을 시간 순서대로 기록하는 로그 파일입니다.

3. **슬레이브의 IO 쓰레드**: 슬레이브 서버의 IO 쓰레드는 마스터의 바이너리 로그를 지속적으로 읽어서 슬레이브 서버의 릴레이 로그에 복사합니다.

4. **슬레이브의 SQL 쓰레드**: 슬레이브의 SQL 쓰레드는 릴레이 로그에 기록된 이벤트를 순서대로 실행합니다. 위의 예에서는 슬레이브도 "INSERT INTO orders (id, product) VALUES (1, 'Apple')" 쿼리를 실행하여 동일한 레코드를 추가합니다.

이렇게 슬레이브는 마스터의 변경 사항을 실시간으로 받아들이고, 그 변경 사항을 적용함으로써 마스터와 동일한 상태를 유지합니다. 이 과정은 사용자가 마스터에서 쿼리를 실행할 때마다 반복됩니다.


#### 📌MySQL의 스케일 아웃 전략은?
1) 데이터가 메모리에 올라가는 크기 O -> 기존 서버 사용
2) 데이터가 메모리에 올라가는 크기 X  -> 메모리 증설하기, 불가능하면 파티셔닝


#### 📌파티셔닝이란?
![[Pasted image 20230522163809.png]]
**큰 데이터베이스 테이블을 더 작은, 더 관리하기 쉬운 부분으로 분할하는 프로세스**를 말합니다. 이는 데이터베이스의 성능을 향상시키고, 관리를 용이하게 하는데 도움을 줍니다.

1. **수평 파티셔닝(Horizontal Partitioning)**: 데이터베이스 테이블의 행을 여러 개의 테이블로 나누는 것입니다. 각 파티션은 테이블의 일부 행을 가지고 있으며, 독립적으로 관리됩니다. 이러한 분할은 일반적으로 데이터베이스의 특정 열을 기준으로 수행됩니다.

	어떤 온라인 쇼핑몰이 수백만 개의 주문을 처리하고 있는 상황을 생각해봅시다. 이 경우 주문 테이블을 수평 파티셔닝할 수 있습니다. 가령, **주문 번호에 따라** 주문 테이블을 여러 개의 파티션으로 나눌 수 있습니다. 주문 번호 1에서 500,000까지는 첫 번째 파티션, 500,001에서 1,000,000까지는 두 번째 파티션 등으로 분할하는 것입니다.

2. **수직 파티셔닝(Vertical Partitioning)**: 데이터베이스 테이블의 열을 여러 개의 테이블로 나누는 것입니다. 각 파티션은 테이블의 일부 열을 가지며, 독립적으로 관리됩니다. 이는 특정 열이 자주 액세스되는 경우 유용할 수 있습니다.

	같은 온라인 쇼핑몰의 상품 테이블이 상품 ID, 이름, 가격, 설명, 제조업체, 재고 수량 등 여러 열을 가지고 있다고 가정해봅시다. 이 중에서 일부 열(예: 상품 ID, 이름, 가격)만 자주 조회되는 경우, 이 **열들을 별도의 테이블로 분할**하면 쿼리 성능을 향상시킬 수 있습니다.

3. **범위 파티셔닝(Range Partitioning)**: 범위 파티셔닝은 테이블을 여러 부분으로 분할하되, 각 부분이 특정 값의 범위를 포함하도록 하는 방법입니다. 예를 들어, 날짜 열을 기준으로 테이블을 분할할 수 있으며, 각 파티션은 특정 연도 또는 월의 데이터를 포함하게 됩니다.

	쇼핑몰의 주문 테이블을 다시 생각해봅시다. **주문 날짜를 기준으로 범위** 파티셔닝을 할 수 있습니다. 예를 들어, 2021년 주문은 첫 번째 파티션, 2022년 주문은 두 번째 파티션 등으로 분할하는 것입니다. 이렇게 하면 특정 연도의 주문을 쉽게 검색할 수 있습니다.


#### 📌파티셔닝의 주의점은?
=> 서로 **다른 서버에 있는 테이블을 JOIN하는 기능이 없다**. 그래서 JOIN 쿼리는 대상 대상이 되는 테이블을 앞으로도 서버 분할하지 않을 것이라는 보장이 있어야함.


ㅁㅁ 파티셔닝의 이점은?
=> 국소성이 늘어나서 캐시 효과가 높아짐. 


ㅁㅁ 국소성이란?
프로그램의 명령어나 데이터에 대한 **참조 패턴이 주로 특정 지역에 집중된다는 특성을 설명**합니다. 국소성의 원리는 캐싱, 메모리 관리, 가상 메모리 등 다양한 시스템 최적화 기법에서 중요한 역할을 합니다. 데이터나 명령어를 캐시에 미리 로드해두면, 그들이 다시 참조될 때 시스템의 성능을 향상시킬 수 있기 때문입니다.

1. **시간적 국소성 (Temporal Locality):** 한 번 참조된 데이터나 명령어는 곧바로 다시 참조될 가능성이 높다는 원리입니다. 예를 들어, 반복문의 실행은 시간적 국소성을 보여줍니다. 동일한 코드 블록이 계속해서 실행되기 때문에, 한 번 사용된 명령어는 곧바로 다시 사용됩니다.

2. **공간적 국소성 (Spatial Locality):** 한번 참조된 데이터의 근처 데이터가 곧 참조될 가능성이 높다는 원리입니다. 예를 들어, 연속적으로 저장된 배열의 요소를 차례로 참조하는 것은 공간적 국소성의 예입니다.


ㅁㅁ 다중화에 필요한 서버 대수는 몇대일까?
=> 4대를 1세트라고 생각하자
![[Pasted image 20230523100725.png]]