# 개념잡기
## 간단 정리
[세선 기반 인증과 토큰 기반 인증(JWT) 차이점 (velog.io)](https://velog.io/@jun7867/%EC%84%B8%EC%84%A0-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D%EA%B3%BC-%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9DJWT-%EC%B0%A8%EC%9D%B4%EC%A0%90)

▶세션 기반 인증과 토큰 기반 인증
![[Pasted image 20230921162527.png]]

![[Pasted image 20230921162532.png]]

▶스프링 시큐리티에서 세션 기반 인증
![[Pasted image 20230830022417.png]]

## 로그인 처리하는 방법은?
1) 세션 기반 인증
세션 기반 인증은 클라이언트가 서버에 로그인 요청을 보내면 **서버에서는 사용자의 정보를 확인하고, 해당 사용자를 식별할 수 있는 고유한 값을 생성**합니다

하지만, 세션 기반 인증에서 **세션 클러스터링이 필요한 경우**(즉, 여러 서버에 걸쳐 세션 정보를 공유해야 하는 경우)에 메모리 그리드 기술을 활용할 수 있습니다.
**Redis, DB 와 같은 외부 저장소를 사용**하여 세션 정보를 여러 서버 간에 공유할 수 있게 해줍니다.

2) 토큰 기반 인증
**사용자의 상태를 저장하는 대신 서버는 암호화된 문자열인 토큰을 발급**하여 클라이언트에게 전달합니다. 이 토큰은 사용자의 신원 정보와 권한 등을 담고 있으며, 클라이언트는 요청 시마다 이 토큰을 함께 보냅니다. **서버는 받은 토큰을 해독하여 사용자의 권한과 신원 등을 확인**합니다.


## 세션과 인증
**스프링의 인증을 유지시켜주기 위해서는 session 을 이용**하는 것이 개발자에게는 여러모로 편리합니다. 이후 인증은 서버가 메모리를 소모해서 세션객체를 가지고 유지시켜주는 작업을 하도록 할 수 있습니다. **세션은 브라우저의 쿠키에 JSESSIONID 값을 심어놓고, 브라우저와 서버가 이 값을 주고 받으면서 세션을 보장**받을 수 있습니다.

그래서 시큐리티에서 **인증 처리는 세션과는 별도로 동작**하도록 설계되어 있습니다. 그래서 session 을 사용하건 사용하지 않건 같은 `Authentication`과 `AuthenticationProvider`를 사용할 수 있습니다.


## 두 필터가 필요한 이유는?
**서버의 세션 정책과 스프링의 인증 체계가 서로 맞물려 동작**하도록 하려면 `SecurityContextPersistenceFilter` 와 `RememberMeAuthenticationFilter`, `AnonymousAuthenticationFilter` 등과 같이 **인증을 보조해 주는 다른 필터들의 도움**을 받아야 합니다.


## SecurityContextPersistenceFilter
**HTTP 요청이 시작될 때 `SecurityContext`를 로드하고 요청이 끝날 때 해당 `SecurityContext`를 저장하는 역할**합니다. 즉, `SecurityContextRepository` 에 저장된 `SecurityContext` 를 Request의 LocalThread에 넣어주었다가 뺏는 역할을 함.
![[Pasted image 20230830042034.png]]

`SecurityContext`는 현재 인증된 사용자의 세부 정보와 권한 등을 포함하며, 이 정보는 보통 서버의 세션에 저장되어 관리됩니다.

따라서 이 필터 덕분에 개발자들은 **각 HTTP 요청 사이에서도 인증 상태를 유지**(세션 기반 인증)하거나 변경할 수 있습니다.


## SecurityContextPersistenceFilter가 작동하는 주요 과정
![[Pasted image 20230830022417.png]]
1. HTTP 요청이 들어오면, 필터는 먼저 세션에서 `SecurityContext`를 찾아서 로드합니다. 만약 세션에 저장된 `SecurityContext`가 없으면 새로운 (비어있는) `SecurityContext`를 생성합니다.

2. 그 다음, 이 필터는 로드한 (또는 새로 생성한) `SecurityContext`를 현재 스레드와 연결시킵니다. 이렇게 해서 다른 컴포넌트들이 동일한 스레드 내에서 현재 인증된 사용자 정보에 접근할 수 있게 됩니다.

3. HTTP 요청 처리가 모두 끝나면, 필터는 변경된 (만약 있다면) `SecurityContext`를 다시 세션에 저장합니다.


## RememberMeAuthenticationFilter
**로그인했을 때 해당 사용자의 인증 상태를 유지하는 데 사용**됩니다.

이 필터는 요청이 들어올 때마다 "Remember Me" 쿠키를 확인하고, 쿠키가 존재하며 유효한 경우에 `SecurityContext`에 인증 객체를 설정합니다. 이렇게 하면 세션이 만료되거나 브라우저가 닫힌 후에도 사용자의 로그인 상태가 유지됩니다.

`RememberMeAuthenticationFilter`는 `RememberMeServices` 인터페이스의 구현체와 함께 작동합니다. `RememberMeServices` 구현체는 "Remember Me" 쿠키를 생성하고 처리하는 방법을 정의합니다. 예를 들어, `TokenBasedRememberMeServices`는 각각의 사용자 이름과 비밀번호, 그리고 특정 키로부터 파생된 해시 값을 포함하는 쿠키를 생성합니다.

주요한 점은 "remember me" 기능은 단순히 편의성을 제공하기 위한 것이며, 완전한 인증 세션과 동일한 수준의 보안을 제공하지 않습니다. 따라서 중요 정보에 대한 접근 등은 별도로 다시 인증 과정을 거치도록 설계해야 합니다.

# 코드로 보기
## 구현 목표


## 코드
securityPractice/ 참고



# 궁금한점
## 인스턴스가 두개인 서버 상황에서 필터를 써서 로그인을 유지할 수 있어?
`SecurityContextPersistenceFilter`만으로 여러 대의 서버 인스턴스에서 로그인 상태를 유지하기 위해선 **추가적으로 분산 세션 관리 기술을 함께 사용**해야 합니다.

각 서버 인스턴스는 자체적인 세션을 가지므로, 사용자가 로그인한 후 다른 서버 인스턴스로 요청이 전달되면 그 서버 인스턴스는 사용자의 로그인 정보를 알 수 없습니다.

따라서 이런 환경에서 **로그인 상태를 유지하려면 세션 클러스터링 또는 세션 리플리케이션이 필요**합니다. 이것은 모든 서버 인스턴스가 같은 세션 정보에 접근할 수 있도록 하는 기술입니다. 예를 들어, 스프링 세션(Spring Session) 프로젝트와 Redis 등의 분산 캐시 시스템을 함께 사용하여 이 문제를 해결할 수 있습니다.