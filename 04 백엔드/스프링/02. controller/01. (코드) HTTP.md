
----
## HTTP 
[[02. HTTP]] 에서 공부하기

## (코드) HTTP 헤더 정보 파헤치기
```java
@Slf4j  
@RestController  
public class RequestHeaderController {  
  
    @RequestMapping("/headers")  
    public String headers(HttpServletRequest request,  
                          HttpServletRequest response,  
                          HttpMethod httpMethod,  
                          Locale locale,  
                          @RequestHeader MultiValueMap<String, String> headerMap,  
                          @RequestHeader("host") String host,  
                          @CookieValue(value = "myCookie", required = false) String cookie  
                          ) {  
  
        log.info("request={}", request);  
        log.info("response={}", response);  
        log.info("httpMethod={}", httpMethod);  
        log.info("locale={}", locale);  
        log.info("headerMap={}", headerMap);  
        log.info("header host={}", host);  
        log.info("myCookie={}", cookie);  
        return "ok";  
    }  
}
```

▶ 출력
![[Pasted image 20221221115002.png]]


▶ `HttpServletRequest request`
현재 **HTTP 요청**에 대한 모든 정보를 포함하는 `HttpServletRequest` 객체

▶ `HttpServletRequest response`
현재 **HTTP 응답**에 대한 모든 정보를 포함하는 `HttpServletResponse` 객체

▶ `HttpMethod httpMethod`
현재 HTTP **요청의 메소드**(GET, POST 등)를 나타내는 `HttpMethod` 객체

▶ `Locale locale`
Locale 정보를 조회하여 **언어**를 확인

▶ `@RequestHeader MultiValueMap<String, String> headerMap`
**모든 HTTP헤더를 MultiValueMap 형식**으로 조회

▶ `@RequestHeader("host") String host`
"host"라는 이름의 **요청 헤더 값**을 `String`으로 받습니다.

▶ `@CookieValue(value = "myCookie", required = false) String cookie`: 
"myCookie"라는 이름의 **쿠키** 값을 `String`으로 받습니다. 이 쿠키가 없으면 `required = false`에 의해 에러를 발생시키지 않고 `null`을 반환합니다.


## HTTP 응답 
[Spring : ResponseEntity를 사용해야 하는 이유 - Tech Blog (dev-splin.github.io)](https://dev-splin.github.io/spring/Spring-ResponseEntity/#responseentity%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)
[ResponseEntity의 사용법 및 유지보수 — 이로운 개발하기 (tistory.com)](https://stir.tistory.com/343#ResponseEntity%EB%A-%BC%--%EC%--%B-%EB%-A%--%C-%A-%EC%-D%B-%EC%-C%A-)

#### ResponseEntity
Spring **MVC에서 HTTP 응답을 생성**하는데 사용하는 클래스입니다. 이 클래스를 사용하면 응답 본문, 상태 코드, 헤더 등을 상세하게 설정할 수 있습니다

▶ 상태 코드 200 (OK) + 응답 본문 : "Hello, World!"
```java
@GetMapping("/example")
public ResponseEntity<String> example() {
	return ResponseEntity.ok("Hello, World!");
}
```

▶ 상태 코드(400) + 응답 본문 : "Bad Test!!!"
```java
@GetMapping("/response2")  
public ResponseEntity<String> example2() {  
    return new ResponseEntity<>("Bad Test!!!", HttpStatus.BAD_REQUEST);  
}
```


#### HttpServletResponse
Servlet API의 `HttpServletResponse` 객체를 사용하여 응답을 직접 작성할 수도 있습니다. 이 방법은 Spring **MVC보다 낮은 수준의 API를 제공**하므로 더 많은 제어를 원할 때 유용합니다. 

▶ "Hello, World!"라는 응답 본문을 전송
```java
@GetMapping("/example")
public void example(HttpServletResponse response) throws IOException {
	response.getWriter().write("Hello, World!");
}
```

▶ 상태코드(403) + 메시지 : Bad Request!!!!
```java
@GetMapping("/response3")  
public void example3(HttpServletResponse response) throws IOException {  
    response.sendError(HttpServletResponse.SC_FORBIDDEN, "Bad Request!!!!");  
}
```


#### @ResponseBody
`@ResponseBody` 애노테이션을 메서드에 추가하면, **메서드의 반환 값을 HTTP 응답 본문에 직접 사용**하게 됩니다. 이 방법은 간단한 RESTful API를 빠르게 구현하는 데 유용합니다. 

▶ 응답 본문 : "Hello, World!"
```java
@GetMapping("/example")
@ResponseBody
public String example() {
	return "Hello, World!";
}
```