## 단위 테스트란?
단위 테스트(Unit Test)는 **하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트**이다. 여기서 모듈은 애플리케이션에서 작동하는 하나의 기능 또는 메소드로 이해할 수 있다. 예를 들어 웹 애플리케이션에서 로그인 메소드에 대한 독립적인 테스트가 1개의 단위테스트가 될 수 있다.


## 통합테스트란?
통합 테스트(Integration Test)는 **모듈을 통합하는 과정에서 모듈 간의 호환성을 확인**하기 위해 수행되는 테스트이다.

일반적으로 애플리케이션은 여러 개의 모듈들로 구성이 되고, 모듈들끼리 메세지를 주고 받으면서(함수 호출) 기능을 수행한다.


## 단위 테스트가 필요한 이유는?
- 테스팅에 대한 시간과 비용을 절감할 수 있다.
- 새로운 기능 추가 시에 수시로 빠르게 테스트 할 수 있다.
- 문제가 생겼을 때, 어디가 문제인지 테스트 코드를 수시로 빠르게 돌리면서 문제를 파악할 수 있다.


## 단위 테스트 적용의 문제점은?
어떤 객체가 자체적으로 모든 일을 처리한다면 문제가 없겠지만, 일반적인 애플리케이션에서는 1개의 기능을 처리하기 위해 다른 객체들과 메세지를 주고 받아야 한다. 하지만 단위 테스트는 해당 모듈에 대한 **독립적인 테스트이기 때문에 다른 객체와 메세지를 주고 받는 경우에 문제가 발생**한다. 그렇기 때문에 **다른 객체 대신에 가짜 객체(Mock Object)를 주입하여 어떤 결과를 반환하라고 정해진 답변을 준비**시켜야 하는데, 이를 stub이라고 한다.

예를 들어 데이터베이스에 새로운 데이터를 추가하는 코드를 테스트한다고 하면, 가짜 데이터베이스(Mock Database)를 주입하여 insert 처리 시에 반드시에 1을 반환하도록 해주는 것이 stub이다.


## 좋은 단위 테스트의 특징은?
1. **독립성**: **각 단위 테스트는 다른 테스트와 독립적으로 실행**될 수 있어야 합니다. 이렇게 하면, 한 테스트가 실패하더라도 다른 테스트에 영향을 미치지 않습니다.

예시)`testMethodA`와 `testMethodB`는 서로 독립적으로 실행됩니다. 하나가 실패하더라도 다른 테스트에 영향을 미치지 않습니다.
```java
@Test
public void testMethodA() {
    // Test only method A
}

@Test
public void testMethodB() {
    // Test only method B
}
```

2. **소규모**: 단위 테스트는 작은 코드 조각을 검사합니다. 일반적으로 이것은 함수나 메서드를 의미하지만, 클래스나 모듈도 포함될 수 있습니다.

예시) `Calculator` 클래스의 `add` 메서드만을 테스트합니다.
```java
@Test
public void testAddition() {
    Calculator calculator = new Calculator();
    assertEquals(5, calculator.add(2, 3));
}
```

3. **명확성**: 각 단위 테스트의 목적이 명확해야 합니다. 이것은 주로 이름에서 나타낼 수 있으며, 실패할 경우 어떤 부분이 문제인지 쉽게 파악할 수 있어야 합니다.

예시)테스트 이름은 목적을 명확하게 설명합니다: "2와 3을 더했을 때 결과값이 5가 되어야 한다."
```java
@Test 
public void whenAdding2And3_thenResultShouldBe5() { 
    Calculator calculator = new Calculator(); 
    assertEquals(5, calculator.add(2, 3)); 
}
```

4. **유지보수 용이성**: 코드가 변경되더라도 관련된 단위테스팅 코드도 쉽게 변경 및 유지보수 할 수 있어야 합니다.


## 자바 단위테스트 라이브러리 종류는?
- JUnit5: 자바 단위 테스트를 위한 테스팅 프레임워크이다. 애노테이션을 사용하여 테스트 메서드를 정의하고, 다양한 assert 메서드를 제공하여 예상 결과를 검증합니다.

- AssertJ: 자바 테스트를 돕기 위해 다양한 문법을 지원하는 라이브러리이다. 테스트 **코드의 가독성**을 높여줍니다.

- Mockito : 외부 시스템과의 **의존성 없이 서비스 레이어나 데이터베이스 호출** 등을 모방(mock)할 수 있는 프레임워크입니다.

## given/when/then 패턴
1개의 단위 테스트를 3가지 단계로 나누어 처리하는 패턴으로, 각각의 단계는 다음을 의미한다.

- given(준비): 어떠한 데이터가 준비되었을 때
- when(실행): 어떠한 함수를 실행하면
- then(검증): 어떠한 결과가 나와야 한다.

## given/when/then 패턴 예시

예시) 로또 생성 코드
```java
public class LottoNumberGenerator {  
  
    public List<Integer> generate(final int money) {  
        if (!isValidMoney(money)) {  
            throw new RuntimeException("올바른 금액이 아닙니다.");  
        }  
        return generate();  
    }  
  
    private boolean isValidMoney(final int money) {  
        return money == 1000;  
    }  
  
    private List<Integer> generate() {  
        return new Random()  
                .ints(1, 45 + 1)  
                .distinct()  
                .limit(6)  
                .boxed()  
                .collect(Collectors.toList());  
    }  
  
}
```


테스트1) 로또 번호 갯수 테스트
```java
@DisplayName("로또 번호 갯수 테스트")  
@Test  
void lottoNumberSizeTest() {  
    // given : 로또 및 금액 생성
    final LottoNumberGenerator lottoNumberGenerator = new LottoNumberGenerator();  
    final int price = 1000;  
  
    // when : 로또에 금액 투입
    final List<Integer> lottoNumber = lottoNumberGenerator.generate(price);  
  
    // then : 로또 번호 갯수 확인
    assertThat(lotto.size()).isEqualTo(6);  
}
```


테스트2) 로또 번호 범위 테스트
```java
@DisplayName("로또 번호 범위 테스트")  
@Test  
void lottoNumberRangeTest() {  
    // given : 로또 및 금액 생성
    final LottoNumberGenerator lottoNumberGenerator = new LottoNumberGenerator();  
    final int price = 1000;  
  
    // when : 로또에 금액 투입
    final List<Integer> lotto = lottoNumberGenerator.generate(price);  
  
    // then : 로또 생성 번호 범위 확인
    assertThat(lotto.stream().allMatch(v -> v >= 1 && v <= 45)).isTrue();  
}
```


테스트3) 잘못된 로또 금액 테스트
```java
@DisplayName("잘못된 로또 금액 테스트")  
@Test  
void lottoNumberInvalidMoneyTest() {  
    // given : 로또 및 금액 생성 
    final LottoNumberGenerator lottoNumberGenerator = new LottoNumberGenerator();  
    final int price = 2000;  
  
    // when : 로또에 옳바르지 않은 금액 투입
    final RuntimeException exception = assertThrows(RuntimeException.class, () -> lottoNumberGenerator.generate(price));  
  
    // then : 예외 출력 확인
    assertThat(exception.getMessage()).isEqualTo("올바른 금액이 아닙니다.");  
}
```