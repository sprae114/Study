## 생명주기 콜백이 왜 필요할까?
-   보통 TCP/IP 통신을 하면 handshake 등 시간이 오래 걸리기 때문에 서버를 띄울 때 **DB 커넥션**도 같이 받아놓고 빨리 응답을 주도록 한다. 이런 커넥션은 **애플리케이션이 종료**될 때 함께 안전하게 종료해줘야 한다. 이렇게 하려면 객체의 초기화와 종료 작업이 필요하다.  

- ![예시](https://api.transno.com/v3/document_image/52a81019-ddf8-4100-90f1-3d6bebec5768-10826299.jpg)  
    객체가 생성될때는 URI = null인 상태로 객체 생성됌.  

- [ ] 객체의 생성과 초기화를 분리하자. SRP의 원칙  
	- 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다.  
	- 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행함.  

## [스프링 빈의 이벤트 라이프사이클(생성자 주입을 안하는 경우!!)](https://dodeon.gitbook.io/study/kimyounghan-spring-core-principle/08-lifecycle)  
-   스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링종료  

- [ ]   초기화 콜백이란?  
	-   빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출  

- [ ]   소멸전 콜백이란?  
	-   빈이 소멸되기 직전에 호출  

## 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원하는 방법? 
- [ ]   인터페이스(InitializingBean, DisposableBean)  
	-   동작 방법?  
		-   의존 관계 주입이 끝나면 자동적으로 메서드를 호출함.![](https://api.transno.com/v3/document_image/195c68be-a0d0-453f-861d-35d2f9900aea-10826299.jpg)  
	-   단점  
		-   스프링 전용 인터페이스이므로 코드가 **스프링 전용 인터페이스**에 의존한다.  
		-   초기화, 소멸 메서드의 **이름을 변경할 수 없다.**  
- [ ]   설정 정보에 **초기화 메서드, 종료 메서드 지정**  
	-   동작 방법?  
		-   @ Bean(initMethod = "init", destroyMethod = "close")를 쓰면 초기화, 소멸 메서드를 직접 지정
		- ![](https://api.transno.com/v3/document_image/473a4033-5c4e-4bd6-9ffc-b9b59612182b-10826299.jpg)  
	-   특징
		-   메서드 이름을 자유롭게 줄 수 있다.  
		-   설정 정보를 이용하므로 코드를 고칠 수 없는 **외부 라이브러리**에도 적용할 수 있다.  
- [ ]   `@PostConstruct`, `@PreDestroy` **애노테이션** 지원  
	-   동작 방법?  
		-   해당 빈을 등록해주면 애너테이션에 붙은 메서드를 생명 주기에 따라 실행(컴포넌트도 사용가능)
		- ![](https://api.transno.com/v3/document_image/5edf5c6e-bf10-49d8-8590-602d19c67b0a-10826299.jpg)  
	
	-   특징
		-   애너테이션 하나만 붙이면 되므로 편리  
		-   스프링에 종속적인 게 아니라 자바 표준  
- [ ]   언제 뭘 써야될까?  
	1)  @ PostConstruct, @ PreDestroy 애노테이션을 사용하자  
	2)   코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @ Bean 의 initMethod , destroyMethod를 사용하자.