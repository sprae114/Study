[(14) [10분 테코톡] 🤔 조엘의 GC - YouTube](https://www.youtube.com/watch?v=FMUpVA0Vvjw)
## 간단한 정리
- GC는 사용하지 않는 메모리를 회수해 성능을 향상시킨다.
- 자바에서는 자동으로 처리함으로, 이해만하자. 

## GC란?
page.36
자동 메모리 관리 기능 중 하나로, **사용하지 않는 메모리를 자동으로 회수**하여 메모리 누수를 방지하고 **메모리 사용 효율을 향상**시키는 역할을 합니다.

C언어에서는 명시적으로 메모리를 건드리고 참조할 수 있다.
자바에서는 GC는 주로 **가비지 컬렉터라 불리는 알고리즘을 통해** 메모리를 회수하며, 가비지 컬렉터는 일정 주기로 수행되어 **메모리를 모니터링하고 사용되지 않는 객체를 식별한 후 메모리를 회수**합니다. 그래서 메모리 처리를 위한 로직 만들면 안됌.


## GC 알고리즘
#### Reference Counting
![[Pasted image 20230725114554.png]]

- Root space: Heap 영역 참조를 들고 있는 공간  
    Reference Counting은 힙 영역 객체들이 각각 `레퍼런스 카운트`라는 숫자를 가지고 있다고 생각하면 된다. 레퍼런스 카운트는 몇가지 방법으로 해당 객체에 접근할 수 있는가를 나타낸다.  
    레퍼런스 카운트가 0이면 가비지 컬렉션의 대상이 된다.

- 레퍼런스 카운트의 한계 - 순환참조 문제  
    Root space에서 Heap Space의 참조를 모두 끊으면, 사용하지 않은 메모리 영역이 순환 참조로 인해 해제되지 못할 수 있다.

#### Mark and sweep
Java , JS는 마크앤스윕으로 동작한다.
![[Pasted image 20230725114708.png]]
위 이미지는 root 부터 그래프 순회를 통해 연결된 객체를 찾아내는 Mark 과정이다.
![[Pasted image 20230725114717.png]]
위 이미지는 연결이 끊어진 객체를 지우는 Sweep을 나타낸다.  
Sweep 이후에 분산되어있던 메모리는 위 초록 네모들처럼 예쁘게 정렬된다. 이를 Compaction이라고 하는데, 메모리 파편화를 막는 것을 말한다.

- 장점
    - Mark and Sweep 방식을 사용하면 루트로부터 연결이 끊긴 순환 참조되는 객체들도 지울 수 있다.

- 단점
    - 의도적으로 GC를 실행시켜야한다.
    - 어플리케이션 실행과 GC 실행이 병행된다.


## GC의 원리
page.38
[[Java] 자바의 메모리 구조 · Challengist (shinjekim.github.io)](https://shinjekim.github.io/java/2020/01/06/%EC%9E%90%EB%B0%94%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/)
JVM의 힙 메모리(heap memory)는 객체를 저장하기 위한 공간으로 사용되며, 이 힙 메모리는 크게 두 가지 영역으로 나뉩니다: Young 영역과 Old 영역입니다. 
![[Pasted image 20230724115535.png]]

1. **객체 생성**: 자바 프로그램에서 처음 생성되는 객체는 모두 Young 영역의 **Eden 공간에 할당**됩니다. 이 단계에서는 메모리에 공간이 충분한지 확인하며, 공간이 부족한 경우 GC(Garbage Collection)이 실행될 수 있습니다.

2. **객체 이동**: **Minor GC(Young GC)가 수행될 때,** Young 영역의 가비지 객체들이 회수되고, **살아남은 객체들은 한 Survivor 영역(S0 또는 S1)으로 이동**됩니다. 할당 동안 살아남은 객체들은 여러 번의 GC 프로세스를 거치게 됩니다.

3. **객체 이동 및 프로모션**: 프로세스를 **여러 번 거쳐 살아남은 객체들**은 **다른 Survivor 영역으로 이동되거나, 때에 따라 Old 영역으로 프로모션**됩니다. 이 과정에서 객체는 기본 설정된 임계값(최대 GC 임계값)에 따라 결정되며, 이 임계값을 넘는 객체가 발견되면 객체는 Old 영역으로 옮겨집니다.


## GC의 종류
- **마이너 GC** : Young 영역에서 발생하는 GC
- **메이저 GC** : Old 영역이나 Perm 영역에서 발생하는 GC

GC가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할 때 애플리케이션의 병목이 발생하면서 성능에 영향을 줌.


## 4가지 GC 방식
page.41
1. **Serial GC Serial** 
GC는 **단일 스레드로 실행**되며, **전체 Heap 공간을 모두 스캔해서 가비지를 회수하는 방식**입니다. 이 방식은 높은 효율성을 보장하지만, GC가 **실행되는 동안 모든 애플리케이션 작업이 중지**되는(STW: Stop-The-World) 단점이 있습니다. 주로 힙 메모리가 작고 CPU 코어의 개수가 적은 경우에 사용됩니다.

2. **Parallel GC Parallel** 
GC는 Serial GC와 유사하지만, **여러 스레드를 사용**해서 가비지 컬렉션을 수행합니다. 이 방식은 애플리케이션의 효율성을 크게 향상시키지만, **GC 작업이 병렬로 처리된다는 점을 제외**하고는 Serial GC와 유사한 단점이 있습니다(**STW 발생**). 주로 힙 메모리가 크거나 CPU 코어의 개수가 많은 경우에 사용됩니다.

3. Concurrent Mark Sweep (**CMS**) 
GC CMS GC는 **가비지 컬렉션 작업을 애플리케이션이 실행되는 데 거의 영향을 주지 않도록** 할 수 있습니다. CMS는 가비지를 식별하고 객체를 조사하며 동시에 애플리케이션을 실행합니다. **초기 표시(Mark), 다시 마킹(Remark) 및 가비지 정리(Sweep) 단계는 STW로 수행**되지만, CMS GC는 GC 일시 정지 시간을 크게 줄이는 데 도움이 됩니다. 이 방식은 고성능의 고가용성 애플리케이션에 적합합니다.

4. **G1(Garbage First) GC G1** 
GC는 통합을 억제하기 위해 가비지 컬렉션 간격을 늘리는 데 초점을 맞춥니다. 이는 애플리케이션의 일시 정지 시간을 크게 줄이고, 그럼에도 높은 메모리 사용 효율성은 유지합니다. 전체 힙 공간을 더 작은 부분으로 나누고 동시 처리를 병렬적으로 수행하며, 가비지가 많은 영역을 우선적으로 정리합니다. G1 GC는 대형 힙을 가진 애플리케이션에 적합하며, 더 짧은 GC 일시 정지 시간 및 높은 메모리 처리 능력을 제공합니다

## 강제로 GC 시키기
page.47
웹 기반 시스템에서는 절대 사용하면 안됌. 

1. **성능 저하**: GC 작업 중에는 CPU 자원과 메모리를 사용하므로, 애플리케이션의 성능에 부정적인 영향을 미칠 수 있습니다. 특히 Serial GC나 Parallel GC와 같이 STW(Stop-The-World) 방식의 GC를 강제로 호출하면 애플리케이션의 응답 시간이 급격하게 늘어날 수 있습니다.

2. **불필요한 작업**: JVM(Java Virtual Machine)은 가비지 컬렉션을 자동으로 관리하고 최적화하도록 설계되었습니다. JVM은 가비지를 회수할 적절한 시기를 스스로 결정하여 사용하지 않는 객체를 삭제합니다. 그러므로 GC를 강제로 호출하면 이미 최적화된 프로세스를 방해할 수 있습니다.

