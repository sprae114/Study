[자바 프로그래머가 자주 실수 하는 10가지 - 1 | bestalign's dev blog](https://bestalign.github.io/translation/top-10-mistakes-java-developers-make-1/)

## 개념
- List, Set, Map의 공통 개념
자료의 길이가 동적으로 늘어나거나 줄어들 수 있음.
![[Pasted image 20221104235945.png]]

![[Pasted image 20221101230933.png]]

## 정보
```java
List<String> list1 = new ArrayList<String>(Arrays.asList("1", "2", "3", "4", "6"));  

System.out.println(list1.size());  
System.out.println(list1.isEmpty());
```

출력
```
5
false
```

## CRUD
#### 등록(create)
```java
/* 생성 */  
String[] arr = {"자료1", "자료2", "자료3"};  
  
List<String> list1 = new ArrayList<String>(Arrays.asList("1", "2", "3","4","6"));
List<Integer> list2 = Arrays.asList(new Integer[] {1232, 222, 34});  
  
System.out.println(list1);  
System.out.println(list2);  

/* 개별 등록 및 일괄 등록 */
List<String> list3 = new ArrayList<>();  
  
list3.add("a");  
list3.addAll(1, new ArrayList<>(Arrays.asList("자료1", "자료2", "자료3")));  
list3.add(3, "b");  
  
System.out.println(list3);


/* 생성방법 */
List<String> s5 = Arrays.asList("1", "2", "3");  
List<String> s6 = List.of("1", "2", "3");  
System.out.println(s5);  
System.out.println(s6);
```

결과
```
[1, 2, 3, 4, 6]
[1232, 222, 34]

[a, 자료1, 자료2, b, 자료3]

[1, 2, 3]
[1, 2, 3]
```

🧨제네릭스(<>)는 '기본형'의 타입은 불가능하며, Wrapper클래스를 사용해야함. 
```
List<int> //오류 
List<Integer>
```

❓Wapper클래스는?
![[Pasted image 20221104171552.png]]
[[Java] 래퍼 클래스(Wrapper Class)란 무엇인가? (박싱, 언박싱) (tistory.com)](https://coding-factory.tistory.com/547)

❓ [Java - Arrays.asList vs List.of 차이는? ](https://jaehoney.tistory.com/144)
=> Arrays.asList()로 반환된 list는 변경(삭제x)이 가능합니다. 하지만, List.of()에서 반환된 메서드는 변경이 불가능

❓[new ArrayList<>() vs Arrays.asList() 차이는??](https://tecoble.techcourse.co.kr/post/2020-05-18-ArrayList-vs-Arrays.asList/)
=> 원소 추가/삭제를 `new ArrayList<>()`는 할 수 있고, `Arrays.asList()` 할 수 없다.


#### 수정, 조회
```java
List<String> list1 = new ArrayList<String>(Arrays.asList("1", "2", "3","4","6"));  
  
/* 수정 */
list1.set(4, "5");  
System.out.println(list1);    

/*조회*/  
System.out.println(list1.get(2));

/* iterator로 접근 */
Iterator<String> iterator = list1.iterator();  
  
while(iterator.hasNext()){  
    String str = iterator.next();  
    System.out.print(str + " ");  
}
```

결과
```
[1, 2, 3, 4, 5]
3
1 2 3 4 5 
```


#### 삭제
```java
List<String> list1 = new ArrayList<>(Arrays.asList("1", "2", "3","4","6","!@","123","1241"));  
  
/* 삭제 */
list1.remove("1");  //요소 삭제
System.out.println(list1);  
  
list1.remove(0);  //인덱스 삭제
System.out.println(list1);  
  
/* 일괄 삭제*/  
List<String> list2 = Arrays.asList("3","4","123","1241");  
list1.removeAll(list2);  
System.out.println(list1);

/* 람다식 이용한 삭제*/  
List<Integer> list4 = new ArrayList<>(Arrays.asList(1,2,3,4,5,5,6,7,8));  
list4.removeIf(r -> r % 2 == 1);  
System.out.println(list4);
```

출력
```
[2, 3, 4, 6, !@, 123, 1241]
[3, 4, 6, !@, 123, 1241]

[6, !@]

[2, 4, 6, 8]
```

🧨제거 및 추가할때는 new ArrayList일때만 가능함

🧨[[Java]UnsupportedOperationException 에러 (tistory.com)](https://qh5944.tistory.com/152)
=> Array.asList 로 생성한 리스트는 고정되어 있어 원소를 제거 할 수 없다

🧨일괄 삭제하고자 할땐, 앞에서부터 삭제하면 인덱스에 영향을 줘 원하는 결과값을 얻을 수 없음. 따라서 뒤에서부터 삭제해줘야함
![[Pasted image 20221105000209.png]]

🧨자료 중복이 있을때는 요소 삭제로 하면 원하는 결과 얻을 수 없음. 그래서 인덱스로 지정해줘야함

## 추출
```java
ArrayList<String> list3 = new ArrayList<>(Arrays.asList("apple", "apple","grape","banana", "kiwi"));  
ArrayList<String> list4 = new ArrayList<>(Arrays.asList("apple","kiwi", "melon"));  

/* index를 활용한 추출*/
List<String> subList1 = list3.subList(1,4);
System.out.println(subList1);  

/*공통 요소만 추출*/  
list3.retainAll(list4);  
  
System.out.println(list3);  
System.out.println(list4);
```

결과
```
[apple, grape, banana]
[apple, apple, kiwi]
[apple, kiwi, melon]
```

❓요소가 Integer 타입인 경우에는?
```java
List list = new ArrayList();  
list.add(4);  
list.add(3);  
list.add(1);  
list.add(2);  
list.add(2);  
list.add(1);  
  
System.out.println(list);  
/** 인덱스로 삭제 */  
list.remove(1);  
System.out.println(list);  
  
/** 자료값으로 삭제 */  
list.remove(new Integer(2));  //같은게 있는 경우 앞에서부터 삭제
System.out.println(list);
```

출력
```
[4, 3, 1, 2, 2, 1]
[4, 1, 2, 2, 1]
[4, 1, 2, 1]
```

## 찾기
#### 포함여부
```java
List<String> list1 = new ArrayList<String>(Arrays.asList("1", "2", "3","4","6"));  
  
/* 개뱔 포함여부 */
boolean contains1 = list1.contains("1");  
boolean contains2 = list1.contains("5");  
  
System.out.println(contains1);  
System.out.println(contains2);  
  
/* 일괄 포함여부 */
boolean containsAll1 = list1.containsAll(Arrays.asList("2", "3"));  
boolean containsAll2 = list1.containsAll(Arrays.asList("2", "555"));  
  
System.out.println(containsAll1);  
System.out.println(containsAll2);
```

결과
```
true
false

true
false
```

#### 해당 인덱스 위치 찾기
```java
List<String> list1 = new ArrayList<String>(Arrays.asList("1", "2", "3","4","6"));  

int a = list1.indexOf("2");  
int x = list1.indexOf("88");  
System.out.println(a);  
System.out.println(x);
```

출력
```
1
-1
```

## 복사
복사의 종류
- Shallow Copy -> 두 변수가 참조하는 메모리 주소 동일
- Deep Copy -> 참조하는 메모리 주소가 다르다(**깊은 복사는 ArrayList만 가능**)

```java
String[] s = {"a","b","c","d"};  
ArrayList<String> list1 = new ArrayList<String>(Arrays.asList(s));  
  
/** 객체복사 Shallow Copy */  
List<String> copyList1 = list1;  
  
/** 객체복사 Deep Copy */  
ArrayList list2 = (ArrayList) list1.clone();  
  
list1.set(0,"1");  
  
System.out.println(list1);  
System.out.println(list2);
```

출력
```
[1, b, c, d]
[a, b, c, d]
```

🧨깊은 복사할 때, (타입)을 붙여줘야함 why? clone을 object를 반환함

## 정렬
#### 기본정렬
```java
/** 숫자 자료구조 생성 */  
List<Integer> list1 = new ArrayList<Integer>(Arrays.asList(new Integer[] {5, 3, 4, 1, 2}));  
  
Collections.sort(list1);  
System.out.println(list1);  
  
/** 문자열 자료구조 생성 */  
List<String> list2 = new ArrayList<String>(Arrays.asList(new String[] {"나", "가", "a", "k", "D", "P", "1", "3"}));  
  
Collections.sort(list2);  
System.out.println(list2);
```

출력
```
[1, 2, 3, 4, 5]
[1, 3, D, P, a, k, 가, 나]
```

🛠[Java에서 정렬과 lambda (velog.io)](https://velog.io/@g00dluckroon/Java%EC%97%90%EC%84%9C-%EC%A0%95%EB%A0%AC%EA%B3%BC-lambda)

#### 사용자 클래스 기본정렬
String, Integer는 기본적으로 Comparable 인터페이스를 구현한 클래스임으로 정렬 기준이 존재함. But MemberVo는 정렬 기준 존재하지 않음.
=> Comparable 인터페이스 구현을 통해 정렬을 해야함.

- 정렬 기준 정의하는 방법
1) Comparable 인터페이스 구현
2) Comparable 인터페이스내의 추상 메소드 구현
3) 정렬 기준 정의 


```java
public static void main(String[] args) {  
  
   /** List에 MemberVo 타입을 정렬 */  
   List<MemberVo> list = new ArrayList<MemberVo>();  
   list.add(new MemberVo("p001","아메리카노",4000));  
   list.add(new MemberVo("p002","까페모카",4500));  
   list.add(new MemberVo("p003","까페라떼",4300));  
  
   Collections.sort(list);  
   System.out.println(list);  
}  
  
/** 기본정렬을 정의하기 위해 Comparable 인터페이스 구현 */  
public static class MemberVo implements Comparable<MemberVo> {  //1번
  
   private String productId;  
   private String productName;  
   private int price;  
  
   public MemberVo(String productId, String productName, int price){  
      this.productId = productId;  
      this.productName = productName;  
      this.price = price;  
   }  
  
   @Override  
   public String toString() {  
      return "MemberVo [" + productId + ", " + productName  
                     + ", " + price + "]";  
   }  
  
   /** Comparable 인터페이스에 정의된 추상메소드 구현 */  
   @Override  
   public int compareTo(MemberVo o) {  //2번
  
      /** 기본정렬에 대한 정렬기준 정의 */  //3번
      if(this.price > o.price){ return 1; }  
      else if(this.price == o.price){    return 0; }  
      else{ return -1;   }  
   }  
}
```
[Java - Comparator로 정렬(Sorting)하는 방법, Comparable과의 차이점 (codechacha.com)](https://codechacha.com/ko/java-sorting-comparator/)
#### 사용자 정렬 기준 정의
```java
public static void main(String[] args) {  
   List<MemberVo> list = new ArrayList<MemberVo>();  
   list.add(new MemberVo("p001","아메리카노",4000));  
   list.add(new MemberVo("p002","까페모카",4500));  
   list.add(new MemberVo("p003","까페라떼",4300));  
   System.out.println("\t정렬 전\t"+list);  
  
   /** 이름으로 내림차순정렬 */  
   Collections.sort(list, new Comparator<MemberVo>(){  
      @Override  
      public int compare(MemberVo o1, MemberVo o2) {  
         String name1 = o1.productName;  
         String name2 = o2.productName;  
         if(name1==null && name2==null){ return 0; }  
         else if(name1==null && name2!=null){ return -1; }  
         else if(name1!=null && name2==null){ return 1; }  
         else if(name1!=null && name2!=null){  
            return name1.compareTo(name2);  
         }  
         return 0;  
      }  
   });  
   System.out.println("\t정렬 후\t"+list);  
}  
  
public static class MemberVo  {  
  
   private String productId;  
   private String productName;  
   private int price;  
  
   public MemberVo(String productId, String productName, int price){  
      this.productId = productId;  
      this.productName = productName;  
      this.price = price;  
   }  
  
   @Override  
   public String toString() {  
      return "MemberVo [" + productId + "," + productName  
                     + ", " + price + "]";  
   }  
}
```

출력
```
정렬 전	[MemberVo [p001,아메리카노, 4000], MemberVo [p002,까페모카, 4500], MemberVo [p003,까페라떼, 4300]]
정렬 후	[MemberVo [p003,까페라떼, 4300], MemberVo [p002,까페모카, 4500], MemberVo [p001,아메리카노, 4000]]
```

[Java - 리스트 정렬, 3가지 방법 (codechacha.com)](https://codechacha.com/ko/java-sort-list/)

## 오토박싱
- 오토박싱
List는 기본형 자료의 경우 해당 Wrapper 클래스로 자동 변환후 저장됌.

- 오토언박싱
List에 저장된 Integer의 타입 자료는 결과값을 자동으로 int로 변환하여 처리함.

```java
/** List 객체생성 */  
List<Integer> list = new ArrayList<Integer>();  
  
/** 오토박싱 : int → Integer 자동변환 */  
int data1 = 1;  
list.add(data1);  
Object data2 = list.get(0);  
System.out.println("오토박싱 : " + data2 + ", 타입 : " + data2.getClass());  
  
/** 언오토박싱 : Integer → int 자동변환 */  
int data3 = list.get(0);  
System.out.println("언오토박싱 : " + data3);
```

[Java - 문자열을 Char로 변환하는 방법 (codechacha.com)](https://codechacha.com/ko/java-convert-string-to-chararray/)