-   1. 대규모 웹 서비스 개발  
    
    -   대규모의 정의는?  
        -   트래픽이나 저장된 데이터의 용량이 일정 기준을 넘었냐가 기준이 아니다.  
            -   서버 1대로 원활한 서비스를 제공할 수 없어 스케일아웃(scale-out)이 필요한 경우를 대규모로 정의한다. (책이 아닌 필자 개인 의견)  
                -   그 이유는 웹 서버, DB, ... 등 여러 미들웨어를 포함하여 확장이 일어날 때 고려해야할 것들이 굉장히 많아지고 시행착오를 겪기 때문이다.  
                    
    
    -   소규모 서비스와 대규모 서비스의 차이  
        
        -   1. 확장성 확보, 부하분산 필요  
            -   스케일아웃을 가정하고 고민해볼만한 것  
                
                -   요청을 어떻게 여러 서버에 분산할 것인가?  
                    
                
                -   DB를 분산했을 때 데이터 동기화 문제처리는 어떻게 할 것인가?  
                    
                
                -   분산 환경에서 주는 네트워크 지연시간(latency)은 어떻게 처리할까?  
                    
                
                -   서비스간 트랜잭션 처리, 장애 복구는 어떻게 할까?  
                    
                
                -   여러 대 운용은 어떻게 자동화할 것인가?  
                    
        
        -   2. 다중성 확보  
            -   서버가 고장나더라도 혹은 급격하게 부하가 올라갈 경우에도 견딜 수 있는 시스템을 구성할 필요  
                
        
        -   3. 효율적 운용 필요  
            -   서버 일정 숫자 넘어가면 소프트웨어를 사용하고 정보관리를 위한 툴을 사용하는 등 자동화해야함  
                
                -   부하는 괜찮은지  
                    
                
                -   고장 난 부분은 없는지  
                    
                
                -   디스크 용량은 아직 충분한지  
                    
                
                -   보안설정에 미비한 점은 없는지  
                    
        
        -   4. 개발자 수, 개발방법의 변화  
            -   혼자서는 개발이나 운용이 어려워지므로 여러 기술자가 역할을 분담  
                
                -   프로그래밍 언어를 통일하고  
                    
                
                -   라이브러리나 프레임워크를 통일하고  
                    
                
                -   코딩 규약을 정해서 표준화하고  
                    
                
                -   소스코드 관리를 버전관리 시스템  
                    
    
    -   대규모 데이터량에 대한 대처  
        
        -   컴퓨터 처리 과정  
            
            -   디스크→메모리→캐시 메모리→레지스터(CPU)와 같이 몇 단계를 경유해서 처리  
                
            
            -   BUT 속도차이 심함 그래서 이 속도차를 흡수하기 위해 OS는 이런저런 방법을 사용하게 됩니다.  
                
            
            -   예를 들면 디스크로부터 읽어들인 데이터를 메모리에 캐싱해둠으로써 전반적으로 디바이스간 속도차가 체감속도에 영향을 주지 않도록 하고 있습니다  
                
        
        -   데이터량이 많아지면 ?  
            -   처음부터 캐시 미스(cache miss)가 많이 발생하게 되고, 그 결과로 저속의 디스크로의 I/O가 많이 발생하게 됩니다. 디스크 I/O 대기에 들어선 프로그램은 다른 리소스가 비어 있더라도 읽기가 완료되기까지는 다음 처리를 수행할 수가 없습니다. 이것이 시스템 전체의 속도저하  
                
-   2. 대규모 데이터 처리 입문  
    
    -   대규모 데이터로(예시를 3억개 정도)의 쿼리정도 되면?  
        -   쿼리문을 날리면 부하걸림![](https://api.transno.com/v3/document_image/1e63233a-a6b1-4b39-85d4-d22c8125e103-10826299.jpg)  
            
    
    -   대규모 데이터의 어려운 점(메모리와 디스크 관점)  
        
        -   대규모 데이터의 어려운 점  
            -   어려운점![](https://api.transno.com/v3/document_image/92c5f7ff-a2cc-4a5e-b8c4-cc0e9c6fa802-10826299.jpg)  
                
        
        -   왜 디스크가 느리지?  
            
            -   탐색속도  
                
                -   헤드의 이동과 원반의 회전이라는 물리적 이동을 필요로해서![](https://api.transno.com/v3/document_image/041b9bc0-d7dd-4e4f-870c-159dd0ca28f7-10826299.jpg)  
                    
                
                -   os레벨에서 커버하기  
                    -   데이터를 1바이트씩 잃는 것이 아니라 4KB정도를 한번에 읽도록 해 회전수를 줄임  
                        
            
            -   전송속도  
                -   데이터를 디스크에서 메모리로 보내야하기 때문![](https://api.transno.com/v3/document_image/e47355f6-950e-4f94-ba8c-bbae15b72f16-10826299.jpg)  
                    
    
    -   부하에 대해서  
        
        -   부하의 종류는?  
            
            -   CPU 부하  
                -   동영상 인코딩, 대규모 데이터 통계와 같은 계산 등  
                    
            
            -   I/O 부하  
                -   대규모 쓰기 또는 전문 검색 등  
                    
        
        -   부하의 병목 찾아내는 과정  
            
            -   Load Average 확인  
                
                -   Load Average란 시스템 전체의 부하상황을 나타내는 지표로, top 또는 uptime 등의 명령어로 시스템 전체에 부하상황을 확인한다.  
                    
                
                -   Load Average가 높지 않다?  
                    -   소프트웨어의 설정이나 네트워크, 원격 호스트등에 문제가 없는지 확인한다.  
                        
                
                -   Load Average가 높다?  
                    -   CPU인지 I/O인지 확인한다.  
                        
            
            -   CPU, I/O 중 어디에 병목인지 확인  
                -   sar 또는 vmstat 으로 시간 경과에 따른 CPU 사용률, I/O 대기율의 추이를 확인한다.  
                    
                    -   CPU 사용률이 높다?  
                        
                        -   사용자 애플리케이션 프로세스의 문제인지, 시스템 프로세스가 문제인지 확인한다. (top , strace , oprofile)  
                            
                        
                        -   CPU 부하가 높은데 디스크나 메모리 용량에 문제가 없다면 그냥 프로그램이 필요 이상으로 폭주하고 있는 것으로 봐야한다.  
                            
                    
                    -   I/O 대기율이 높다?  
                        
                        -   극단적으로 메모리를 소비하는 프로세스가 있는지 확인한다.  
                            
                        
                        -   프로그램 오류로 메모리를 사용하는 프로그램을 개선한다.  
                            
                        
                        -   메모리 크기 자체가 모자라면 증가시킨다.  
                            
        
        -   p45, 51 나중에 다시  
            
    
    -   규모조정의 요소  
        
        -   웹 애플리케이션 부하의 관계![](https://api.transno.com/v3/document_image/75c8f975-cade-40a4-8d29-08d68bb3d04b-10826299.jpg)  
            2번의 AP서버에서는 CPU부하만 걸림  
            무상태 프로토콜이니깐 요청만 로드 밸런서 장치로 균등하게 분해해주면됌  
            ​  
            3번 I/O부하가 걸림  
            3번과 3'번의 동기화를 어떻게 할것인가??
            
            -   AP 서버란?  
                -   HTTP 뿐 아니라 TCP, UDP 등 다양한 프로토콜을 전달해주는 서버  
                    
            
            -   DB 서버란?  
                -   데이터베이스 저장만을 담당하는 서버  
                    
        
        -   중요내용![](https://api.transno.com/v3/document_image/4d200413-c560-4cd3-987a-0dfd021d4cd1-10826299.jpg)  
            
    
    -   대규모 데이터를 다루기 위한 기초지식(P.72)  
        
        -   대규모 데이터를 다루는 3가지 중점  
            
            -   1)어떻게 하면 메모리에서 처리를 마칠수 있을까?  
                -   왜 메모리지? 디스크가 아니고?  
                    -   디스크 seek 횟수를 최소화하기 위해 메모리 활용하자  
                        
            
            -   2) 데이터량 증가에 강한 알고리즘 사용하자  
                
            
            -   3) 데이터 압축이나 검색기술과 같은 테크닉이 활용하자  
                
                -   압축하면 데이터량 줄어서 seek횟수 적어짐,메모리 캐싱 쉬워짐  
                    
                
                -   특정 용도에 특화된 검색엔진 만들어서 속도 확보하자  
                    
            
            -   요약![](https://api.transno.com/v3/document_image/6587b077-73ca-494a-8181-d65fa6be3a6f-10826299.jpg)  
                
        
        -   대규모 데이터를 다루기 전 3개 전제지식  
            -   알아야할 3가지 지식![](https://api.transno.com/v3/document_image/fb7693d9-3f06-41f4-b2dc-59304794e7f2-10826299.jpg)  
                
-   3. OS 캐시와 분산  
    
    -   OS의 캐시 구조(P.80)  
        
        -   OS의 캐시 구조를 알자  
            -   OS의 구조를 알아야하는 이유![](https://api.transno.com/v3/document_image/f1a8efc2-9ea0-4f63-bb36-c5df91c46000-10826299.jpg)  
                
        
        -   OS는 어떤 구조를 가졌나?  
            
            -   가상메모리 구조란? 논리적인 선형 어드레스를 물리적인 어드레스로 변환하는 것![](https://api.transno.com/v3/document_image/de2f5d09-ed81-4ad7-a761-48be07ed08ec-10826299.jpg)  
                
            
            -   가상메모리 자세히 알아보기  
                
                -   요약![](https://api.transno.com/v3/document_image/5fc0e64e-e1c9-4696-8680-6aa61e0308d2-10826299.jpg)  
                    
                
                -   가상메모리 구조 그림![](https://api.transno.com/v3/document_image/0841c276-335e-400b-bd82-e4878026724c-10826299.jpg)  
                    왜 이렇게 사용하는 거지? 물리적인 하드웨어를 OS에서 추상화 하기 위함
                
                -   [짧게 개념만 이해하는! 가상 메모리 구조 - YouTube](https://www.youtube.com/watch?v=rmm2_MkAuxk)  
                    
                    -   가상 == 논리적  
                        
                    
                    -   가상메모리를 사용하므로써 , 자원사용이 끝났을 때 자원을 회수 할 수 있음  
                        -   PROCESS의 가상메모리 사용이 끝나면 OS는 물리 메모리가 어디 사용 되었는지 알고 있음![](https://api.transno.com/v3/document_image/8fd0a752-d323-4fd5-b45b-08c1862b397e-10826299.jpg)  
                            
                
                -   [[운영체제] 가상 메모리의 이해 (tistory.com)](https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4)  
                    
            
            -   리눅스 페이징  
                
                -   요약![](https://api.transno.com/v3/document_image/43721a5b-e571-42be-98cf-4bf9ff4c0c67-10826299.jpg)  
                    
                
                -   페이지 캐시 그림![](https://api.transno.com/v3/document_image/f436e520-f596-4073-8796-ed0526f27207-10826299.jpg)  
                    리눅스가 한번 읽을 데이터는 캐싱이 된다.
            
            -   메모리보다 큰 파일을 어떻게 캐싱할 수 있을까?  
                
                -   그림![](https://api.transno.com/v3/document_image/e05c9b95-0343-498c-bac2-3d020d0fc231-10826299.jpg)  
                    모든 부분을 캐싱하는 것이 아니라 블록 단위로 캐싱범위를 정한다
                
                -   IF 전부 읽게 된다면 어떤일이 일어나지?  
                    -   구조는 LRU로 오래된 것을 파기하는 형태이다. 그래서 과거 부분은 날라가게 되고, I/O가 발생할 가능성이 높아짐  
                        
        
        -   가상메모리  
            
            -   요약![](https://api.transno.com/v3/document_image/c686e747-51de-40ca-954d-c8bd936c60af-10826299.jpg)  
                
            
            -   [[10분 테코톡] 🧚🏻 배럴의 가상 메모리 - YouTube](https://www.youtube.com/watch?v=5pEDL6c--_k&t=221s)  
                
                -   개념과 장점![](https://api.transno.com/v3/document_image/dea7bfaa-7e88-4955-82a2-45bee0baeb79-10826299.jpg)  
                    
                
                -   컴퓨터 구조![](https://api.transno.com/v3/document_image/d167d314-bd2b-41fa-9c4a-5fb4dbb4133a-10826299.jpg)  
                    cpu가 연산할려면 메모리의 값을 참조해야함. 그래서 레지스터, 메인 메모리의 값을 참조함.  
                    ​보조 기억장치(disk)의 값을 참조할려면 OS의 도움을 받아 IO작업을 해야함.  
                    
                
                -   프로그램이 실행되는 것이란?![](https://api.transno.com/v3/document_image/0e9784fa-e50b-4049-85e5-eee9cd1fc0ae-10826299.jpg)![](https://api.transno.com/v3/document_image/bc723bac-8e61-444d-98ce-0a239e3202cd-10826299.jpg)![](https://api.transno.com/v3/document_image/1222955e-01e8-47dd-ad07-9c479883e73e-10826299.jpg)  
                    CPU는 메인 메모리의 값까지만 참조 가능함.  
                    ​그래서 프로그램이 실행되기 위해서는 정보가 메모리에 올라와야함.  
                    ​하지만 디스크에 정보가 메모리가 원하는 프로세스 형태로 올라와야 함.  
                    그래서 fork와 exec를 통해서 프로세서 형태로 메모리에 올림.
                
                -   논리주소![](https://api.transno.com/v3/document_image/c00017d8-6d0e-46d3-b398-b878b6fe167b-10826299.jpg)  
                    프로세스를 실행하면 각 단계마다 cpu가 독자적인 주소 공간을 생성함. 이것을 논리 주소라고함
                
                -   주소 바인딩![](https://api.transno.com/v3/document_image/3739226d-264b-4f22-b0d7-c26c4ac622c6-10826299.jpg)  
                    주소 바인딩이란 논리 주소가 물리적 메모리의 특정 위치로 맵핑되는 것을 의미함
                
                -     
                    
    
    -   [💵 캐시가 동작하는 아주 구체적인 원리](https://parksb.github.io/article/29.html)  
        
-   4.분산을 고려한 MYSQL 운용  
    
    -   인덱스를 올바르게 운용하기  
        
        -   분산을 고려한 MYSQL의 운용 3가지 포인트는?  
            -   요약![](https://api.transno.com/v3/document_image/a2615c85-be27-4140-b14c-f6f106ddb457-10826299.jpg)  
                
        
        -   OS 캐시 활용  
            
            -   요약![](https://api.transno.com/v3/document_image/ddc00c32-b333-4596-9b36-a061bafd74d9-10826299.jpg)  
                
            
            -   IF 레코드가 3억개 정도 되면, 칼럼 하나만 추가해도 8bit * 3억 정도의 데이터가 필요함  
                
        
        -   정규화는 써야 될까?  
            
            -   [정규화란?](https://mangkyu.tistory.com/110)  
                
            
            -   속도와 데이터 크기의 트레이드 오프로 생각하자  
                
            
            -   정규화 O => 데이터의 크기가 줄어들 수 있음  
                
            
            -   정규화 X => 쿼리가 단순해져 속도 빠름  
                
        
        -   인덱스의 중요성  
            
            -   MYSQL의 인덱스 구조는? B+트리 구조![](https://api.transno.com/v3/document_image/14ce731c-af82-4e4b-b844-ff53eb6e983b-10826299.jpg)  
                
                -   자식 여러개인 다분 + 치우침이 없는 평형  
                    
                
                -   디스크 탐색 시 SEEK 횟수를 최소화 하는 구조  
                    
            
            -   왜 이분트리를 쓰지 않는 거지?  
                
                -   이분 트리는 데이터 크기를 4KB를 하는 것이 어려움 그래서 한블럭씩 찾는 디스크에서는 B트리가 유리함  
                    
                
                -   그림![](https://api.transno.com/v3/document_image/1a59efee-a36d-49c2-9078-b26ef12d2970-10826299.jpg)  
                    
        
        -   인덱스 효과 예시  
            
            -   인덱스 O VS 인덱스 X 예시![](https://api.transno.com/v3/document_image/ead05ae6-2498-4336-9c09-a80fd1bd2cfb-10826299.jpg)  
                
            
            -   인덱스 작용했는지 확인해보자  
                -   explain 명령어를 통해서 알아볼 수 있음![](https://api.transno.com/v3/document_image/47c0f2d8-7818-491a-9622-7af11d9967c4-10826299.jpg)  
                    
    
    -   MYSQL의 분산  
        
        -   레플리케이션이란?  
            
            -   두 개의 이상의 DBMS 시스템을 Mater / Slave로 나눠서 동일한 데이터를 저장하는 방식![](https://api.transno.com/v3/document_image/319b1181-83a2-4b72-b307-18c0e2938606-10826299.jpg)  
                이때, 갱신 쿼리는 마스터로 직접 던진다.  
                ​참조쿼리는 로드밸린서를 통해서 분할 할 수 있도록함.
            
            -   O/R 매퍼로 제어함  
                
        
        -   마스터/슬레이브의 특징  
            
            -   갱신 쿼리는 어떻게 분산할 것인가?  
                
                -   대부분(90%)이상은 참조쿼리기 때문에 필요한 경우 많지 않음  
                    
                
                -   그럼에도 불구하고 분산해야 한다면, 테이블 분할을 활용한 분산사용  
                    
            
            -   참조 쿼리는 어떻게 분산할 것인가?  
                
                -   서버 대수를 늘리면 로드밸린서가 알아서 트래픽 관리해줌  
                    
                
                -   단순히 대수 늘리는 것이 아닌 메모리가 늘어나도록 하는 것이 중요함  
                    
        
        -   MYSQL의 스케일 아웃 전략은?  
            -   요약![](https://api.transno.com/v3/document_image/202de244-ce1b-4058-83ec-54842003a8a3-10826299.jpg)  
                
        
        -   파티셔닝  
            
            -   [[DB] DB 파티셔닝(Partitioning)이란 - Heee's Development Blog (gmlwjd9405.github.io)](https://gmlwjd9405.github.io/2018/09/24/db-partitioning.html)  
                
            
            -   파티셔닝이란? 테이블을 작은 단위의 파티션으로 나눠 관리하는 기법![](https://api.transno.com/v3/document_image/73fe9f34-c180-4bdd-b76d-c44f6bea6faf-10826299.jpg)  
                
            
            -   파티셔닝의 문제점은? 두 테이블을 함께 사용하고자 할때 즉 JOIN이 안됌  
                
                -   해결법은? JOIN을 쓰지 않고 쿼리를 날리자  
                    
                
                -   TAG의 포함된 데이터를 ENTRY에서 찾을때![](https://api.transno.com/v3/document_image/b6d9f762-f401-42a6-a882-06833e675c6b-10826299.jpg)  
                    
                
                -   WHERE ... IN 을 사용하자![](https://api.transno.com/v3/document_image/e2df806d-6654-4890-b936-7cb4aa614ae2-10826299.jpg)  
                    
            
            -   파티셔닝의 장점은?  
                
                -   부하가 내려감  
                    
                
                -   국소성이 증가  
                    -   공간적으로 멀리 떨어져있는 두 물체는 절대 서로 직접적으로 영향을 줄 수 없다는 원리  
                        
            
            -   파티셔닝의 단점은?  
                
                -   서버가 늘어남에 따라 운용 복잡해짐  
                    
                
                -   고장률이 높아짐  
                    
        
        -   다중화에 필요한 서버의 대수는?  
            -   서비스가 중지 없이 유지하기 위한 최소 대수는 4대를 한세트로 묶어야함![](https://api.transno.com/v3/document_image/67993921-881a-4ec8-a689-73439858b187-10826299.jpg)  
                
-   5.대규모 데이터 처리 실전 입문  
    
    -   대량의 데이터에 접근하고자 하는 경우에는 어떻게 해결할 것인가? EX) 전문검색, 키워드 검색 등...  
        
    
    -   인덱스와 시스템 구성  
        -   용도특화형 인덱싱 매커니즘![](https://api.transno.com/v3/document_image/bf414d4f-f626-4a6b-a44b-03e4df180eb6-10826299.jpg)  
            1) 배치 처리로 데이터 추출  
            2) 별도 인덱스 서버를 만들어서 웹 API 등으로 쿼리