-   Chapter 01 컴퓨터 구조 시작하기  
    
    -   01-1 구조를 알아야 하는 이유 (P. 31)  
        -   요약![](https://api.transno.com/v3/document_image/a0bbe22d-6016-42ab-b7f7-30bbe3476353-10826299.jpg)  
            왜 문제해결 능력이 향상되지? 같은 코드라도 컴퓨터 마다 될때가 있고 안될때가 이때 컴퓨터 구조를 이해하면 문제해결이 가능하다.  
            또한, 웹 클라우드 서비스를 이용하더라도, 어떤 cpu를 사용할지, 얼마나 메모리를 사용해야할지 알수 있음.  
            
    
    -   01-2 컴퓨터 구조의 큰 그림 (P. 37)  
        
        -   요약![](https://api.transno.com/v3/document_image/f714b69c-def5-4c84-81d7-5fc6b0a589a4-10826299.jpg)  
            
        
        -   컴퓨터 구조 그림![](https://api.transno.com/v3/document_image/dc08a537-f299-4c46-8a85-0f3c800277b7-10826299.jpg)  
            
        
        -   핵심 부품 연결 그림![](https://api.transno.com/v3/document_image/f2c858c4-9162-466f-9058-036fefde5478-10826299.jpg)  
            
        
        -   동작 예시![](https://api.transno.com/v3/document_image/afe177af-526c-4d32-9a15-1920da3fd243-10826299.jpg)  
            
-   Chapter 02 데이터  
    
    -   02-1 0과 1로 숫자를 표현하는 방법 (P. 55)  
        -   요약![](https://api.transno.com/v3/document_image/8f2111ce-fad0-457a-bc3f-f9aff48f5f00-10826299.jpg)  
            2의 보수 구하기 => 뒤집고 +1 더하기  
            
    
    -   02-2 0과 1로 문자를 표현하는 방법 (P. 67)  
        -   요약![](https://api.transno.com/v3/document_image/23507cf0-be09-4e39-aeaa-cfe7771757dd-10826299.jpg)  
            완성형 코딩방식이란? 자음, 모음 이렇게 따로가 아닌 한글자 자체를 넣은 것을 말한다
-   Chapter 03 명령어  
    
    -   03-1 소스 코드와 명령어 (P. 79)  
        
        -   컴파일과 인터프리토  
            
            -   동작 방식![](https://api.transno.com/v3/document_image/8ca1550f-7dcc-4950-8a31-f39148f38ccd-10826299.jpg)  
                컴파일러는 소스코드 전체를 한번에 번역해주는 것  
                ​인터프리토는 실행하면 한줄한줄 번역해주는 것
            
            -   컴파일러 장단점  
                
                -   컴파일 후에는 모든 소스코드가 기계어로 변환되어 있기 때문에 실행 시간이 빠르다.  
                    
                
                -   규모가 큰 프로그램은 컴파일 시 오래 걸릴 수 있다.  
                    
                
                -   C, Java에서 사용  
                    
            
            -   인터프리토 장단점  
                
                -   컴파일과정 없이 바로 실행하기 때문에 수정, 디버깅에 유리하다. 즉 개발속도에 유리  
                    
                
                -   한 줄씩 읽어서 실시간으로 실행하기 때문에 컴파일 언어에 비해 속도가 느리다.  
                    
                
                -   Python, Java에서 사용  
                    
        
        -   요약![](https://api.transno.com/v3/document_image/d039c901-afdd-41cb-a592-15f6be4bfb52-10826299.jpg)  
            
    
    -   03-2 명령어의 구조 (P. 91)  
        
        -   요약![](https://api.transno.com/v3/document_image/26524c4b-1fba-4011-842b-d49129260b70-10826299.jpg)  
            
        
        -   연산코드와 오퍼랜드![](https://api.transno.com/v3/document_image/10b2c9e3-0c42-4354-ad30-b207dd22b126-10826299.jpg)![](https://api.transno.com/v3/document_image/a2661a6d-a4ff-464d-9795-0e61930c2798-10826299.jpg)  
            연산코드란? 명령어가 수행할 연산  
            오퍼랜드란? 연산에 사용할 데이터/저장된 위치
        
        -   연산코드의 4가지 역할?  
            -   예시![](https://api.transno.com/v3/document_image/035b2cf2-f792-4575-b547-2d9e7b115776-10826299.jpg)  
                
        
        -   주소 지정 방식  
            
            -   주소지정 방식은 유효주소를 찾기 위해서 사용하는 것  
                
            
            -   유효주소란?  
                -   연산에 사용될 데이터가 저장된 위치  
                    
            
            -   즉시 주소 지정 방식  
                
                -   그림![](https://api.transno.com/v3/document_image/636cd286-86fb-4611-9989-5587c3fd3f12-10826299.jpg)  
                    
                
                -   데이터의 크기가 작아지지만, 레지스터로 찾는 과정이 없기 때문에 빠르다  
                    
            
            -   직접 주소 지정방식  
                
                -   그림![](https://api.transno.com/v3/document_image/fcf0b0af-4ff6-4a76-b9b0-5038429d75ff-10826299.jpg)  
                    
                
                -   오퍼랜드 필드에 유효 주소를 직접 명시하여데이터의 크기가 커짐  
                    
            
            -   간접 주소 지정 방식  
                
                -   그림![](https://api.transno.com/v3/document_image/c1cef610-6a89-47cc-8d37-55e2a859f916-10826299.jpg)  
                    
                
                -   유효주소의 범위를 늘리기 위한 방법  
                    
-   Chapter 04 CPU와 작동 원리  
    
    -   04-1 ALU와 제어장치 (P.105)  
        
        -   요약![](https://api.transno.com/v3/document_image/2e88d267-cadc-4b0f-9a12-584f9c4b1a49-10826299.jpg)  
            
        
        -   ALU  
            -   그림![](https://api.transno.com/v3/document_image/5a47729e-62d4-4ebd-baf2-5570cf334806-10826299.jpg)  
                
        
        -   플래그란?  
            
            -   그림![](https://api.transno.com/v3/document_image/48c705ff-28c0-404c-bfa1-4c8e78449e81-10826299.jpg)  
                
            
            -   연산 결과에 대한 추가적인 상태 정보  
                
        
        -   제어장치란?  
            
            -   그림![](https://api.transno.com/v3/document_image/5e798274-4b69-42ee-a350-d3f30127d76e-10826299.jpg)  
                
            
            -   매커니즘  
                
                -   1) 클럭신호를 받아들이기  
                    
                
                -   2) '해석해야 할 명령어'를 받아들이기  
                    
                
                -   3) 플래그 레지스터 속 플래그 값 받아드리기  
                    
                
                -   4) 제어 버스로 전달된 제어 신호 받아드리기  
                    
                
                -   5) 이후 CPU 내부/외부에 제어 신호 보내기  
                    
    
    -   04-2 레지스터 (P. 113)  
        
        -   요약![](https://api.transno.com/v3/document_image/8dc9af8d-bd9a-495f-beb6-60382b103bc8-10826299.jpg)  
            
        
        -   직접 설명해보기![](https://api.transno.com/v3/document_image/bb01e725-9d40-41f3-b484-2a74f258fdfa-10826299.jpg)  
            
            -   1) PC의 내용을 메모리 주소 레지스터로 보낸다.  
                
            
            -   2) 메모리 주소 레지스터는 메모리에 1000번지에 있는 데이터를 가져온다. 이후 메모리 버퍼 레지스터로 넣는다. 이후 PC카운트를 늘린다  
                
            
            -   3) 메모리 버퍼 레지스터는 1101의 값을 명령어 레지스터로 이동해준다.  
                
            
            -   4) 명령어 레지스터는 해당 값을 해석하고 제어신호를 발생시킨다  
                
        
        -   [CPU는 어떻게 작동할까?](https://www.youtube.com/watch?v=Fg00LN30Ezg&t=840s)  
            
    
    -   04-3 명령어 사이클과 인터럽트 (P. 127)  
        
        -   요약![](https://api.transno.com/v3/document_image/6c4ba7d3-85c0-4af8-aee4-64389ae5857a-10826299.jpg)  
            
        
        -   인터럽트  
            
            -   인터럽트란?  
                -   그림![](https://api.transno.com/v3/document_image/1c7df32d-909c-429e-895e-960f09412879-10826299.jpg)  
                    
            
            -   인터럽트 동작과정  
                -   그림![](https://api.transno.com/v3/document_image/b0b7ec65-151c-45d4-b308-8d56819f93a2-10826299.jpg)  
                    
            
            -   인터럽트가 발생하면 이전에 저장된 값은 어떻게 처리하지?  
                -   프로그램 실행상태 -> 인터럽트 발생![](https://api.transno.com/v3/document_image/e227dec6-b73b-43cf-a272-fed3dbe281ba-10826299.jpg)![](https://api.transno.com/v3/document_image/5affc1df-18db-4289-8372-d65544a88241-10826299.jpg)  
                    이전까지 저장된 정보는 스택영역에 백업을 해놓는다.
            
            -   용어정리  
                
                -   인터럽트 요청신호  
                    -   정상적인 실행 흐름을 끊기 전에 CPU에게 보내는 신호![](https://api.transno.com/v3/document_image/6004a1c2-a2ee-4c55-9675-75e8f7afaec6-10826299.jpg)  
                        
                
                -   인터럽트 플래그  
                    -   인터럽트 유무는 판별![](https://api.transno.com/v3/document_image/c2e4040c-6b5b-4a38-8c70-3f24b151f2eb-10826299.jpg)  
                        
                
                -   인터럽트 서비스 루틴  
                    -   인터럽트가 실행 될때, 작용하는 프로그램![](https://api.transno.com/v3/document_image/2ab0485f-76d6-4b39-bfd7-ee69939575dd-10826299.jpg)  
                        
                
                -   인터럽트 백터  
                    -   인터럽트 서비스 루틴을 식별하기 위한 정보로, 시작점을 알 수 있음.![](https://api.transno.com/v3/document_image/17a0ee95-81c4-48c0-b424-90b2c412ee65-10826299.jpg)  
                        
            
            -   인터럽트 종류는?  
                
                -   그림![](https://api.transno.com/v3/document_image/8f9e6e7c-0330-45f5-af21-84d848690990-10826299.jpg)  
                    
                    -   폴트 -> 예외처리후, 예외 발생한 명령어부터 다시 실행재개  
                        
                    
                    -   트랩 -> 예외처리후, 예외 발생한 다음 명령어부터 다시 실행재개(디버깅)  
                        
                    
                    -   소프트 웨어 인터럽트 -> 시스템 호출 발생했을때  
                        
                
                -   동기 인터럽트란?  
                    -   CPU에 의해 발생되는 인터럽트로 예외가 발생했을때 동작함  
                        
                
                -   비동기 인터럽트란?  
                    
                    -   그림![](https://api.transno.com/v3/document_image/49a263e1-080f-4dd7-bc92-dad18f440ea5-10826299.jpg)  
                        
                    
                    -   입출력장치에 의해 발생된는 인터럽트로 알람과 같은 역할을 함.  
                        
        
        -   명령어 사이클  
            -   그림![](https://api.transno.com/v3/document_image/02eba38d-b5a9-4aa8-b637-594104067abf-10826299.jpg)  
                
-   Chapter 05 CPU를 위한 설계 기법  
    
    -   05-1 빠른 CPU를 위한 설계 기법 (P. 145)  
        -   요약![](https://api.transno.com/v3/document_image/e46ebad7-bef4-4aba-84a1-723617f06409-10826299.jpg)  
            
            -   클럭  
                
                -   CPU의 속도를 나타내는 단위  
                    
                
                -   클럭속도가 높으면?  
                    
                    -   명령어 사이클을 더 빠르게 반복, 부품도 빠르게 작동  
                        
                    
                    -   단, 이럴경우 발열문제가 발생할 수 있음  
                        
                
                -   클럭 속도는 일정하게 유지 되는게 X, 성능에 따라 순간 클럭 속도를 조절함.  
                    
            
            -   코어와 멀티코어(=멀티 프로세서)  
                
                -   그림![](https://api.transno.com/v3/document_image/bafc06f4-1946-445a-bc4b-ff4efe60c210-10826299.jpg)  
                    
                
                -   코어란?  
                    -   명령어를 실행하는 부품  
                        
                
                -   멀티 코어로 성능 높이는 방법은?  
                    
                    -   코어마다 처리할 연산을 적절히 분배해야함.  
                        -   몰아서 주면, 몰아서 준만큼의 성능 밖에 안나옴  
                            
                    
                    -   처리량이 코어 수보다 지나치게 작아도 안됌  
                        -   한사람의 할일을, 5명이 나눠갖는 경우랑 비슷 성능차이가 크지 않음  
                            
            
            -   스레드와 멀티스레드  
                
                -   스레드란?  
                    -   실행 흐름의 단위  
                        
                
                -   하드웨어적/소프트웨어적 스레드  
                    
                    -   하드웨어적 스레드란?  
                        
                        -   하나의 코어가 동시에 처리하는 명령어 단위![](https://api.transno.com/v3/document_image/204644d9-20fa-4de1-a078-f20ae50e3d18-10826299.jpg)  
                            
                        
                        -   ex) 2코어 4쓰레드![](https://api.transno.com/v3/document_image/cc2ebd6d-d484-4fe3-9dc1-b619916edd91-10826299.jpg)  
                            CPU가 한번에 4개의 명령어를 처리할 수 있음. 프로그램 입장에서 봤을 때는 한번에 하나의 명령어를 처리하는 CPU가 4개 있는것처럼 보임. 그래서 논리 프로세스라고도 함
                        
                        -   멀티 스레드 프로세서 = 멀티 스레드 CPU  
                            -   위의 그림처럼 하나의 코어로 동시에 여러 명령어를 처리하는 것  
                                
                    
                    -   소프트웨어적 스레드란?  
                        
                        -   하나의 프로그램에서 독립적으로 실행되는 단위![](https://api.transno.com/v3/document_image/e8b312d9-4fd5-46f6-9e09-bf28f805e7be-10826299.jpg)  
                            
                        
                        -   EX)멀티 스레드![](https://api.transno.com/v3/document_image/0a63ede6-ea16-4824-ba6d-dd390a8d3098-10826299.jpg)  
                            예시로는 입력받은 내용을 화면에 보여주면서, 맞춤법에 맞는지 검사하는 기능
            
            -   멀티스레드 프로세스  
                
                -   그림![](https://api.transno.com/v3/document_image/af39544b-723b-408e-a59e-5477708726da-10826299.jpg)  
                    
                
                -   어떻게 두개의 명령어를 동시에 처리할 수 있을까?  
                    -   이전에 명령어를 처리했던 방식을 생각해보면, 명령어를 처리하기 위한 부품(PC, 데이터 버퍼 레지스터, 데이터 주소 레지스터)등.. 중요 레지스터가 2개씩 있으면됌  
                        
            
            -   [[10분 테코톡] 🌷 코다의 Process vs Thread - YouTube](https://www.youtube.com/watch?v=1grtWKqTn50)  
                
    
    -   05-2 명령어 병렬 처리 기법 (P. 157)  
        
        -   요약![](https://api.transno.com/v3/document_image/a5aea7c3-4cda-4ade-ad01-93a7cf2d42c2-10826299.jpg)  
            
        
        -   (배경) 어떻게 명령어를 동시에 처리하여 CPU를 작동시킬까(=명령어 병렬 처리 기법)  
            -   그림![](https://api.transno.com/v3/document_image/73b3911c-491a-4a55-883c-3d4d8e424579-10826299.jpg)  
                
        
        -   명령어 파이프라인  
            
            -   명령어 처리 과정  
                -   인출 -> 해석 -> 실행 -> 저장  
                    
            
            -   명령어 파이프라인이란?  
                
                -   같은 단계가 겹치지 않는다면 CPU는 '각 단계를 동시에 실행할 수 있다'![](https://api.transno.com/v3/document_image/0f0d879f-7e6f-49ef-9468-0f38a6573923-10826299.jpg)![](https://api.transno.com/v3/document_image/e7e3712f-5958-4338-8c02-029e929643ab-10826299.jpg)  
                    
                
                -   만약 파이프라인을 사용하지 않으면?![](https://api.transno.com/v3/document_image/310e33eb-de69-4034-8c4b-39713cf987cf-10826299.jpg)  
                    
            
            -   파이프라인 위험  
                
                -   특정상황에서는 성능 향상에 실패하는 경우를 알아보자  
                    
                
                -   그림![](https://api.transno.com/v3/document_image/d7632d26-471a-423d-a0b4-3e678e07db1f-10826299.jpg)  
                    
                
                -   데이터 위험  
                    -   어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우(데이터 의존성)  
                        
                
                -   제어 위험  
                    -   프로그램 카운터의 갑작스러운 변화![](https://api.transno.com/v3/document_image/7f78e494-ea24-4369-9b30-17e9fc73ba44-10826299.jpg)  
                        
                
                -   구조적 위험  
                    -   서로 다른 명령어가 ALU과 같은 CPU 부품을 동시에 사용할때  
                        
            
            -   비순차적 명령어 처리  
                
                -   명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법(= 명령어의 합법적인 새치기)  
                    
                
                -   언제 사용될까?(데이터의존성을 가지고 있을때)  
                    
                    -   사용되는 예시![](https://api.transno.com/v3/document_image/33fb388c-6431-4571-9e90-c0c076e2ee35-10826299.jpg)  
                        
                    
                    -   사용한 이후![](https://api.transno.com/v3/document_image/1031e325-c6b6-41ea-906a-b3964f8d0bb8-10826299.jpg)  
                        
        
        -   슈퍼스칼라  
            
            -   슈퍼스칼라란?  
                -   CPU내부에 여러 개의 명령어 파이프라인을 포함한 구조  
                    
            
            -   그림![](https://api.transno.com/v3/document_image/86999427-a132-4f4a-8b5c-d9fefb502752-10826299.jpg)![](https://api.transno.com/v3/document_image/620f33c5-a93d-4889-8d14-91a87af07f2e-10826299.jpg)  
                
    
    -   05-3 CISC와 RISC (P.167)  
        
        -   요약![](https://api.transno.com/v3/document_image/1bb16a65-a669-40a8-b867-e06e44bfe5c6-10826299.jpg)  
            
        
        -   (배경) CPU에 명령어 병렬처리기법을 하기 위해 명령어 구조  
            -   이전에 연산코드, 오퍼랜드는 뭐지?  
                
                -   아 그건 구역을 나눈거고, 어떤 연산코드를 정할지, 오퍼랜드 길이나 방식은 각 회사마다 다름  
                    
                
                -   그래서 인텔과 아이폰 호환 X, 명령어가 달라지면 어셈블리어도 달라지니깐  
                    
        
        -   ISA  
            -   CPU의 언어임과 동시에 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속![](https://api.transno.com/v3/document_image/3e67f6e0-e7e3-4390-92bf-c8c6b274d2eb-10826299.jpg)  
                
        
        -   CISC  
            
            -   복잡하고 다양한 명령어들을 활용하는 CPU설계 방식  
                
            
            -   명령어의 형태와 길이가 다양함![](https://api.transno.com/v3/document_image/b711be70-02e3-4ee2-932d-e92f1b262793-10826299.jpg)  
                
            
            -   (문제점) 명령어의 크키가 일정하지 않아 시간이 일정하지 않음 -> 파이프라인 효과적 적용 X![](https://api.transno.com/v3/document_image/0aee919b-07ff-4961-81ba-d798bdbec52c-10826299.jpg)  
                
        
        -   RISC  
            
            -   명령어 종류가 적고, 1클럭 내외로 실행되는 명령어  
                
            
            -   메모리 접근을 단순/최소화하는 대신 레지스터를 적극 활용함  
                
        
        -   비교![](https://api.transno.com/v3/document_image/745fce68-cef6-46d8-bbf0-c185b6671413-10826299.jpg)  
            
-   Chapter 06 메모리와 캐시 메모리  
    
    -   06-1 RAM의 특징과 종류 (P.179)  
        
        -   요약![](https://api.transno.com/v3/document_image/a148bf37-5783-41a1-95bb-59d396b0f5d5-10826299.jpg)  
            
        
        -   cpu와 작동방식  
            
            -   메모리에 없는 경우![](https://api.transno.com/v3/document_image/19b0cc2d-7879-4317-83e4-b4bdbb16b7ba-10826299.jpg)  
                
            
            -   메모리에 있는 경우![](https://api.transno.com/v3/document_image/2855114f-4759-4e09-acb9-2a319dcbdef9-10826299.jpg)  
                
            
            -   따라서 RAM의 용량이 크면 많은 프로그램을 동시에 빠르게 시키는 것이 가능하다.  
                
            
            -   단, 메모리가 커진다고 해도 메모리 실행시간(=보조 기억장치 가져오는 시간)이 빨라 지는 것은 아님![](https://api.transno.com/v3/document_image/e3cbc445-b2ca-4359-a705-2baff8acfb84-10826299.jpg)  
                
        
        -   DRAM/SRAM/DDR RAM  
            
            -   DRAM/SRAM![](https://api.transno.com/v3/document_image/70b5182c-eabf-499f-9b03-9b3a87615d2b-10826299.jpg)  
                
            
            -   DDR RAM![](https://api.transno.com/v3/document_image/0e56a0f4-3c3b-4780-a438-3a8bdb3b02f2-10826299.jpg)  
                대역폭(=데이터가 지나가는 길)을 넓혀서 속도를 빠르게 만든 것
    
    -   06-2 메모리의 주소 공간 (P.187)  
        
        -   요약![](https://api.transno.com/v3/document_image/af810b8c-af67-441b-b8f9-953b28ce174b-10826299.jpg)  
            
        
        -   물리주소와 논리주소  
            
            -   그림![](https://api.transno.com/v3/document_image/14573cfe-6baa-479b-a337-bdbb74743dae-10826299.jpg)  
                
            
            -   물리주소는 메모리 하드웨어가 사용하는 주소  
                
            
            -   논리주소는 CPU와 실행 중인 프로그램 사용하는 주소로, 각 논리 주소마다 0번지로 시작함  
                
            
            -   그러면 CPU는 논리 주소로 작동하는데 문제가 없을까?  
                
                -   문제점![](https://api.transno.com/v3/document_image/4ee4cb3a-b7d7-4882-a7dc-267cd3d54af3-10826299.jpg)  
                    CPU는 논리주소만 알아서 명령하지만, 실제로 물리 주소로 저장되어 있어서 변환해줘야하는 필요성 생김
                
                -   해결책![](https://api.transno.com/v3/document_image/a865462b-a6ed-4b6c-8dca-7150511b69dc-10826299.jpg)  
                    
                    -   MMU라는 메모리 관리 장치에 의해서 논리 주소를 물리주소로 변환해준다.  
                        
                    
                    -   베이스 레지스터를 기준(=실행 프로그램의 시작주소)에서 논리주소를 더하면 됌  
                        
                    
                    -   만약 논리주소를 벗어나게 되면 한계 레지스터(=논리주소의 최대크기)를 벗어나므로 실행 X  
                        
    
    -   06-3 캐시 메모리 (P.197)  
        
        -   요약![](https://api.transno.com/v3/document_image/bf7690b7-cec9-482a-9c33-853490daba9f-10826299.jpg)  
            
        
        -   캐시 메모리를 사용하는 이유는?  
            
            -   그림![](https://api.transno.com/v3/document_image/1b4aae0f-4a7f-4bcc-b83a-248e2b9daf90-10826299.jpg)  
                
            
            -   CPU의 연산속도를 메모리 접근하는 시간이 따라잡지 못함. 그래서 병목현상을 예방하고자 캐시 사용  
                
        
        -   메모리 계층 구조  
            -   그림![](https://api.transno.com/v3/document_image/bc0cb9b4-db95-4e2d-a09a-29f76d33d43c-10826299.jpg)  
                
        
        -   CPU와 동작하는 방식  
            -   그림![](https://api.transno.com/v3/document_image/e531b8b5-d709-4e83-92f1-ef55f72d49f4-10826299.jpg)  
                L1, L2는 코어마다 할당되고, L3는 공유하는 형태로 코어의 외부에 존재하게 된다
        
        -   참조 지역성의 원리  
            -   캐시메모리에 어떻게 가져와야할까?(=캐시 히트)  
                
                -   1) 최근에 접근했던 메모리 공간에 다시 접근(=시간지역성)  
                    -   예시) FOR문![](https://api.transno.com/v3/document_image/09079691-c0ef-4b77-a279-3fa393af96f7-10826299.jpg)  
                        
                
                -   2) 접근한 메모리 근처에 접근(=공간지역성)  
                    -   예시) 배열  
                        
        
        -   [[10분 테코톡] 🏖 파피의 Caching(캐싱) - YouTube](https://www.youtube.com/watch?v=JBFT4KyEvoY)  
            
-   Chapter 07 보조기억장치  
    
    -   07-1 다양한 보조기억장치 (P.209)  
        
        -   요약![](https://api.transno.com/v3/document_image/ffd59d48-8eee-4cb2-a223-c5be45a49167-10826299.jpg)  
            
        
        -   하드디스크  
            -   하드디스크가 속독가 느린 이유는?  
                
                -   1)탐색시간 : 데이터의 접근하려면 헤드를 이동시켜야함![](https://api.transno.com/v3/document_image/c2de7edb-6b2e-4981-ae66-e1299e80da9f-10826299.jpg)  
                    
                
                -   2)회전시간: 헤더가 있는 곳으로 플래터를 회전시켜야함![](https://api.transno.com/v3/document_image/cb52b704-583e-4f12-a968-ec66296e00e7-10826299.jpg)  
                    
                
                -   3) 전송시간: 하드디스크와 컴퓨터 간에 데이터를 전송하는 시간![](https://api.transno.com/v3/document_image/cec03740-2ec1-47d2-8044-1bd83fcb5a2d-10826299.jpg)  
                    
        
        -   플래시 메모리  
            
            -   전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장장치  
                
            
            -   USB, SSD에 사용됌  
                
            
            -   그림![](https://api.transno.com/v3/document_image/88e3a5f5-b75d-4146-8b98-3cda4e1d75be-10826299.jpg)  
                
            
            -   1비트를 저장할 수 있는 타입  
                
                -   요약![](https://api.transno.com/v3/document_image/29418039-5088-41b8-95ff-9f9a10b251bf-10826299.jpg)  
                    같은 집에 몇명이 사는지로 생각해보자
                
                -   SLC![](https://api.transno.com/v3/document_image/c6ec6254-71cf-4bf6-b232-1eca97b4c54e-10826299.jpg)  
                    
                
                -   MLC![](https://api.transno.com/v3/document_image/804f2cd9-bd22-41ff-ba8d-7228aeea281c-10826299.jpg)  
                    
                
                -   TLC![](https://api.transno.com/v3/document_image/a4aa0add-9a8e-4e25-8f87-82185d6962a5-10826299.jpg)  
                    
            
            -   플래시 메모리의 문제점은?  
                
                -   그림![](https://api.transno.com/v3/document_image/541cc67c-94b7-4902-b217-66f3c5d76000-10826299.jpg)![](https://api.transno.com/v3/document_image/a22b16c4-d855-4601-b307-f5939ec668a8-10826299.jpg)  
                    저장은 OK, BUT 플래시 메모리는 덮어 쓰기가 불가능 하므로 데이터를 지우지 못함
                
                -   그래서 SSD는 가비지컬렉션 도입![](https://api.transno.com/v3/document_image/acfaf680-6ce3-4a54-97a3-935d9a5a58ca-10826299.jpg)  
                    
    
    -   07-2 RAID의 정의와 종류 (P.221)  
        
        -   요약![](https://api.transno.com/v3/document_image/f29c057b-83da-4bd2-9a29-2a3946866488-10826299.jpg)  
            
        
        -   RAID는?  
            
            -   그림![](https://api.transno.com/v3/document_image/7c20868c-5545-48c6-8722-4acfffea4957-10826299.jpg)  
                
            
            -   하드디스크와 SSD에 사용하는 기술로, 데이터의 안정성과 성능 향상을 위해서 여러개의 보조 기억장치를 하나의 논리적 보조기억 장치로 사용하는 기술  
                
            
            -   RAID 0  
                
                -   그림![](https://api.transno.com/v3/document_image/b6fb5e6c-d909-4689-aa83-1c3a88ee9228-10826299.jpg)  
                    
                
                -   장점 -> 읽고 쓰는 속도 향상  
                    
                
                -   단점 -> 저장 정보 안전 x WHY? 하나 고장나면 다 날라감  
                    
            
            -   RAID 1  
                
                -   그림![](https://api.transno.com/v3/document_image/c1249bb6-d667-4696-b773-c63a1d47002a-10826299.jpg)  
                    
                
                -   장점 -> 안전하게 정보 저장  
                    
                
                -   단점 -> 많은 양의 하드 디스크가 필요함으로, 비용증가  
                    
            
            -   RAID 4  
                
                -   그림![](https://api.transno.com/v3/document_image/6df830bb-fde4-4c4a-a358-257f6020e1a3-10826299.jpg)  
                    
                
                -   오류 검출하고 복구하기 위한 패리티 정보를 저장  
                    
            
            -   RAID 6  
                
                -   그림![](https://api.transno.com/v3/document_image/6d1c9d73-c616-49a5-b38e-4fc7870ed553-10826299.jpg)  
                    
                
                -   패리티를 나눠서 갖는 방식  
                    
                
                -   속도는 조금 떨어지지만, 데이터를 좀더 안정적으로 보관  
                    
-   Chapter 08 입출력장치  
    
    -   08-1 장치 컨트롤러와 장치 드라이버 (P. 233)  
        
        -   요약![](https://api.transno.com/v3/document_image/00a2c027-ca7c-45dd-a562-d82350dbe962-10826299.jpg)  
            
        
        -   장치드라이버  
            -   그림![](https://api.transno.com/v3/document_image/fbd07ac2-7adb-47b0-a0c0-4c95cd399a1f-10826299.jpg)  
                
    
    -   08-2 다양한 입출력 방법 (P.241)  
        -   DYDIR![](https://api.transno.com/v3/document_image/44d764a2-d757-44c4-bee6-22db57f7c5d7-10826299.jpg)  
            
-   Chapter 09 운영체제 시작하기  
    
    -   09-1 운영체제를 알아야 하는 이유 (P. 261)  
        
        -   요약![](https://api.transno.com/v3/document_image/d34735f4-24bb-401f-82a1-93ca849ddb7f-10826299.jpg)  
            운영체제도 프로그래미여서 메모리에 적재되어서 실행되어야함
        
        -   용어정리  
            
            -   자원?  
                -   프로그램 실행에 필요한 시스템 자원  
                    
            
            -   커널영역과 사용자 영역?  
                
                -   그림![](https://api.transno.com/v3/document_image/8fb14f27-1222-42b2-a38e-056e662896e8-10826299.jpg)  
                    
                
                -   커널영역은 운영체제가 실행되는 메모리 공간, 그외에는 사용자 영역이라고 함.  
                    
        
        -   운영체제의 역할은?  
            
            -   그림![](https://api.transno.com/v3/document_image/2fb1f1dc-9d09-4aef-8c7d-a911c7dfcfed-10826299.jpg)  
                
            
            -   프로그램에 메모리 자원 할당  
                -   그림![](https://api.transno.com/v3/document_image/ca75efb5-991c-4a86-9a7c-5be0105d7fd2-10826299.jpg)  
                    
            
            -   프로그램에 CPU 자원 할당  
                -   그림![](https://api.transno.com/v3/document_image/21f754be-1f04-4c69-944f-f36f1bbb3094-10826299.jpg)  
                    
    
    -   09-2 운영체제의 큰 그림 (P. 269)  
        
        -   요약![](https://api.transno.com/v3/document_image/9102584e-f6c8-438b-9d38-5db9b7b3ccdf-10826299.jpg)  
            
        
        -   이중모드  
            
            -   운영체제 역할![](https://api.transno.com/v3/document_image/1c9e4e06-ce4a-4483-b112-65402593d5c6-10826299.jpg)![](https://api.transno.com/v3/document_image/54f681d0-78c7-47c6-85f6-e515d30c40f0-10826299.jpg)  
                운영체제는 문지기 역할을 한다. 이러면 당연히 두가지 행동으로 나뉠 수 있는데,  
                ​운영체제 서비스를 받을수 없는 사용자 모드와 서비스를 받을 수 있는 커널모드로 나뉜다.
            
            -   이중모드![](https://api.transno.com/v3/document_image/18a06007-5b0e-45ec-a96c-cd367071ae5b-10826299.jpg)  
                
            
            -   그러면 사용자 모드는 자원을 못 받는 것인가? NO 시스템 호출을 통해 요청할 수 있음  
                -   시스템 호출그림![](https://api.transno.com/v3/document_image/9932149e-a9f1-4817-8585-1a75dc78f805-10826299.jpg)  
                    
        
        -   운영체제 핵심 서비스  
            
            -   프로세스 관리  
                
                -   그림![](https://api.transno.com/v3/document_image/f7191796-fd23-4ad1-9fb9-94d92db697fb-10826299.jpg)  
                    
                
                -   프로세스란? 실행중인 프로그램  
                    
            
            -   자원(CPU, 메모리,..) 접근 및 할당  
                
                -   프로그램이 얼마나 오래 CPU를 사용할지 결정  
                    
                
                -   새로운 프로세스가 어느 주소에 적재될지 결정  
                    
            
            -   파일 시스템 관리  
                
-   Chapter 10 프로세스와 스레드  
    
    -   10-1 프로세스 개요 (P.285)  
        
        -   요약![](https://api.transno.com/v3/document_image/82f88a60-a80e-4c45-94da-7043e64c217f-10826299.jpg)  
            
        
        -   프로세스란?  
            
            -   그림![](https://api.transno.com/v3/document_image/366a2f66-82fe-43f9-b071-67ad6609ba40-10826299.jpg)  
                
            
            -   보조기억 장치에서 메모리에 적재하고 실행하는 그 프로그램을 지징함  
                
        
        -   프로세스 종류  
            
            -   포그라운드 프로세스  
                -   사용자가 보는 앞에서 실행되는 프로세스  
                    
            
            -   백그라운드 프로세스(=데몬, 서비스)  
                -   사용자가 보지 못하는 뒤편에서 실행되는 프로세스  
                    
        
        -   프로세스 제어블록(PCB)  
            
            -   그림![](https://api.transno.com/v3/document_image/625db89e-23ad-49eb-bb06-2a209e49b18a-10826299.jpg)  
                모든 프로그램이 CPU를 동시에 사용할 수 없으니깐 프로세스의 실행순서를 관리하고 자원 관리를 해야함
            
            -   PCB는 커널영역에 생성  
                
            
            -   프로세스 생성 시에 만들어지고 실행이 끝나면 폐기  
                
            
            -   PCB에 담기는 정보는 어떤것이 있을까?  
                
                -   그림![](https://api.transno.com/v3/document_image/38660b96-9738-4f59-873a-21bfb89b99ea-10826299.jpg)![](https://api.transno.com/v3/document_image/fd82e1fa-f54c-48e7-a6a4-f5f5190c392b-10826299.jpg)  
                    
                
                -   PID  
                    -   특정 프로세스를 식별하기 위해 부여하는 고유번호  
                        
                
                -   레지스터 값  
                    -   이전에 사용했던 레지스터 값을 복원하기 위함  
                        
                
                -   프로세스 상태  
                    -   현재 프로세스 상태가 정보. 대기상태인지, 종료상태인지 ...  
                        
                
                -   CPU 스케줄링 정보  
                    -   어떤 순서로 CPU를 할당 받을지  
                        
        
        -   문맥교환(컨텍스트 스위칭)  
            
            -   문맥이란?  
                -   하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보  
                    
            
            -   문맥교환이란?  
                
                -   그림![](https://api.transno.com/v3/document_image/35ae45c4-5b0b-4279-9d3a-43b1a0729f54-10826299.jpg)![](https://api.transno.com/v3/document_image/8472249d-5c8f-4e82-bf91-671eed5597e4-10826299.jpg)  
                    
                
                -   기존의 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것  
                    
        
        -   사용자 영역에서는 무슨일이 일어날까?  
            
            -   그림![](https://api.transno.com/v3/document_image/21bee89a-581f-4230-8298-5df862bbd19a-10826299.jpg)  
                
            
            -   코드영역  
                -   기계어로 이루어진 명령어 저장  
                    
            
            -   데이터 영역  
                -   프로그램이 실행되는 동안 유지할 데이터 EX)전역변수  
                    
            
            -   힙영역  
                -   프로그래머가 직접 할당할 수 있는 저장공간  
                    
            
            -   스택영역  
                -   데이터를 일시적으로 저장하는 공간  
                    
    
    -   10-2 프로세스 상태와 계층 구조 (P. 297)  
        
        -   요약![](https://api.transno.com/v3/document_image/f5c160f6-08ae-4914-b9a8-4984239d4217-10826299.jpg)  
            
        
        -   프로세스 상태  
            
            -   그림![](https://api.transno.com/v3/document_image/96d8526d-7c07-45a3-8590-89de8aeb0924-10826299.jpg)  
                
            
            -   생성상태  
                -   메모리에 적재되어 PCB를 할당 받은 상태  
                    
            
            -   준비상태  
                -   CPU를 할당 받으면 당장이라도 실행 할 수 있는 상태  
                    
            
            -   실행상태  
                -   실행 상태인 프로세스가 할당된 일정 시간동안만 CPU를 사용하는 상태  
                    
            
            -   대기상태  
                -   요청 프로세스를 기달리는 상태  
                    
            
            -   종료상태  
                -   종료된 상태  
                    
        
        -   계층구조  
            -   PPID  
                -   부모 프로세스  
                    
        
        -   프로세스 생성 기법  
            
            -   그림![](https://api.transno.com/v3/document_image/17d29e00-8ab1-4116-af59-c8d0ad9668fa-10826299.jpg)  
                부모 프로세스를 통해 생성된 자식프로세스들은 복제와 옷 갈아입기를 통해 실행됨
            
            -   FORK  
                -   자기 자신 프로세스의 복사본을 만드는 시스템 호출  
                    
            
            -   EXEC  
                -   자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출  
                    
    
    -   10-3 스레드 (P. 307)  
        
        -   요약![](https://api.transno.com/v3/document_image/b0032eed-78f1-4517-9665-74ffe454bd83-10826299.jpg)  
            
        
        -   스레드  
            
            -   그림![](https://api.transno.com/v3/document_image/92820570-66ab-49a6-8a45-721e3088ffff-10826299.jpg)  
                
            
            -   프로세스를 구성하는 실행의 흐름 단위  
                
        
        -   단일 프로세스 VS 멀티 프로세스  
            
            -   단일![](https://api.transno.com/v3/document_image/e7c31a3a-7bfb-44b5-8773-a1f2feb65a5e-10826299.jpg)  
                실행 흐름이 하나인 것
            
            -   멀티![](https://api.transno.com/v3/document_image/977bce00-7981-45e7-abfc-f3a812bfed64-10826299.jpg)  
                여러 명령어를 동시에 수행할 수 있음
        
        -   멀티 프로세스 VS 멀티 쓰레드  
            
            -   구조  
                
                -   멀티 프로세스![](https://api.transno.com/v3/document_image/02d4075d-39c1-4c11-ad0f-a99fc0d69b27-10826299.jpg)  
                    자원을 공유하지 않기 때문에 독립적으로 동작함
                
                -   멀티 쓰레드![](https://api.transno.com/v3/document_image/502163c0-3e20-40b8-88c2-81e35ac7d4a6-10826299.jpg)  
                    자원을 공유하여 사용하기 때문에 하나의 스레드가 문제가 생기면 나머지 쓰레드도 영향 받음
            
            -   실제 실행 했을떄는 어떤 차이가 있을까?![](https://api.transno.com/v3/document_image/3da5f095-ef00-4690-93e6-55c882fbb917-10826299.jpg)  
                멀티 프로세스는 같은 프로그램을 실행하기 위해 위의 그림과 같이 메모리에 동알한 내용을 중복해서 존재하게 된다.  
                멀티 쓰레드는 같은 프로세스 내에서는 자원을 공유하여 메모리 소모가 적음
            
            -   그러면 멀티 프로세스는 공유할 수 있는 방법이 아예 없나?  
                
                -   프로세스 간의 통신  
                    파일을 통한 프로세스 간의 통신
                
                -   공유 메모리![](https://api.transno.com/v3/document_image/61a8d043-3e5a-4831-ac18-a63d890c2ee0-10826299.jpg)  
                    공유할 수 있는 메모리 영역 만들기
-   Chapter 11 CPU 스케줄링  
    
    -   11-1 CPU 스케줄링 개요 (P. 317)  
        
        -   요약![](https://api.transno.com/v3/document_image/8d0da5d8-bcf4-4729-9dc5-08a8d24ef660-10826299.jpg)  
            
        
        -   CPU 스케줄링  
            
            -   그림![](https://api.transno.com/v3/document_image/7163e2ca-2704-4cf3-82c5-ebf712a0d1dc-10826299.jpg)  
                
            
            -   프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하기 위함  
                
        
        -   어떻게 CPU 자원을 배분할까?  
            -   PCB에 적힌 우선순위 + 입출력 < CPU 프로세스에 순서![](https://api.transno.com/v3/document_image/c10ce9ca-a969-41bd-bc07-ef32f2336b1a-10826299.jpg)  
                
        
        -   우선순위 PCB를 일일히 찾아야 할까?  
            
            -   상황![](https://api.transno.com/v3/document_image/31203b31-c1d4-42e9-ab27-72b13f07fe22-10826299.jpg)  
                일일히 찾는 것은 오리 걸리니깐 줄서서 기다리게 함. 이것이 스케줄링 큐
            
            -   스케쥴링 큐 있으면![](https://api.transno.com/v3/document_image/bc4f931b-aaff-4e5d-9106-5c9e72c226af-10826299.jpg)![](https://api.transno.com/v3/document_image/55e0a7b2-11cf-4b15-9b6a-37891afface0-10826299.jpg)  
                
        
        -   갑자기 급한 프로세스가 오면 어떻게 해야할까?  
            
            -   상황![](https://api.transno.com/v3/document_image/4ccd5b2b-477a-4b26-9251-5cfaf73eec03-10826299.jpg)  
                
            
            -   방법1) 강제로 뺏어서 먼저 실행하는 선점형 스케줄링  
                
                -   그림![](https://api.transno.com/v3/document_image/216d6936-c27d-422a-9cc4-3056b36bbe3a-10826299.jpg)  
                    
                
                -   독점 불가능 WHY? 뺏을 수 있으니깐  
                    
                
                -   문맥 교환 과정에서 오버헤드 발생 할 수 있음  
                    -   오버헤드란 간접시간  
                        
            
            -   방법 2) 종료되기만 기다리는 비선점형 스케줄링  
                
                -   그림 ![](https://api.transno.com/v3/document_image/2835344a-d322-4060-847a-11c8d71948b4-10826299.jpg)  
                    
                
                -   자원 독점 가능  
                    
    
    -   11-2 CPU 스케줄링 알고리즘 (P. 329)  
        
        -   요약![](https://api.transno.com/v3/document_image/f256a766-4abc-4808-9936-f554fea9907e-10826299.jpg)  
            
        
        -   스케쥴링 알고리즘  
            
            -   선입 선출 스케줄링  
                
                -   그림![](https://api.transno.com/v3/document_image/7bd53f89-63c2-4ef1-9e02-7296db3d55b3-10826299.jpg)  
                    
                
                -   먼저 들어간 프로세스부터 처리하는 알고리즘  
                    
                
                -   기다리는 시간이 길어질 수 있음  
                    
            
            -   최단 작업 우선 스케줄링  
                
                -   그림![](https://api.transno.com/v3/document_image/c3597a52-b9a2-45b6-9bd5-1440124279d4-10826299.jpg)  
                    
                
                -   CPU 이용 시간이 짧은 프로세스부터 실행하는 비선점형 스케줄링  
                    
            
            -   라운드 로빈 스케줄링  
                
                -   그림![](https://api.transno.com/v3/document_image/d4ad0aac-52b9-40ec-937a-04e831cb7eb7-10826299.jpg)  
                    
                
                -   타임슬라스(정해진 CPU 사용시간)만큼 시간 동안 돌아가며 사용하는 선점형 스케줄링  
                    
                
                -   문맥교환 비용이 커질 수 있음  
                    
            
            -   최소 잔여 시간 우선 스케줄링  
                -   최단 작업 우선 스케줄링을 선점형으로 바꾼 스케줄링(라운드 로빈도 사용)  
                    
            
            -   우선순위 스케줄링  
                
                -   그림![](https://api.transno.com/v3/document_image/ba504f64-9139-4446-87d5-758c27ed38d2-10826299.jpg)  
                    
                
                -   가장 높은 우선순위를 가진 프로세스부터 실행하는 선점형 스케줄링  
                    
                
                -   뒤로 계속 밀릴수 있음(=기아현상) 그래서 오래 대기하면 우선순위 높여줌(=에이징기법)  
                    
            
            -   다단계 큐 스케줄링  
                
                -   그림![](https://api.transno.com/v3/document_image/7d158962-2cdb-45ed-8ef6-3dff9811343e-10826299.jpg)  
                    
                
                -   우선 순위별로 준비 큐를 여러개 사용하여 구현하는 방법  
                    
                
                -   큐마다 다른 스케줄링 알고리즘 사용가능  
                    
            
            -   다단계 피드백 큐 스케줄링  
                
                -   그림![](https://api.transno.com/v3/document_image/8ac9e758-1588-4800-a5ff-9eee6e0005ab-10826299.jpg)  
                    
                
                -   다단계 큐에서 큐 사이를 이동할 수 있게 보완한 스케줄링  
                    
-   Chapter 12 프로세스 동기화  
    
    -   12-1 동기화란 (P. 341)  
        
        -   요약![](https://api.transno.com/v3/document_image/fc577c6c-e793-48a9-a5ae-def0f79807a1-10826299.jpg)  
            
        
        -   동기화란?  
            
            -   그림![](https://api.transno.com/v3/document_image/b72f67f0-58f0-4218-8065-e2c707c2550b-10826299.jpg)  
                
            
            -   프로세스의 실행 순서와 자원의 일관성을 보장하기 위함(실행순서 제어 + 상호 배제)  
                
            
            -   실행순서 제어란?  
                
                -   그림![](https://api.transno.com/v3/document_image/8f2aab2c-c72b-4d06-9deb-5ee765779321-10826299.jpg)  
                    
                
                -   읽고 난후 쓰기가 가능한것 처럼 올바른 순서 보장하게 해줌  
                    
            
            -   상호배제란?  
                
                -   동시 접근 금지  
                    
                
                -   IF 동시에 접근하게 되면?  
                    -   그림![](https://api.transno.com/v3/document_image/8937ca67-6ee5-4862-9b82-d074cfc6fb6e-10826299.jpg)  
                        A, B가 2,5만원을 더해서 17만원이 되어야 되는데. 데이터를 동시에 사용하여 데이터 사용이 끝나기도 전에 접근해서
        
        -   공유자원과 임계구역  
            
            -   그림![](https://api.transno.com/v3/document_image/163001b3-8077-41d3-b2d6-cd0354a4509f-10826299.jpg)  
                
            
            -   임계구역  
                -   동시에 실행하면 문제가 발생하는 코드 영역  
                    
        
        -   레이스 컨디션  
            
            -   레이스 컨디션이란?  
                -   여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우  
                    
            
            -   레이이스 컨디션이 발생하면 데이터의 일관성이 깨짐  
                
            
            -   언제 발생하게 될까?  
                -   그림![](https://api.transno.com/v3/document_image/5d380133-de2d-4d86-ac08-184b4cba4e56-10826299.jpg)  
                    
        
        -   상호 배제를 위한 동기화 3가지 원칙  
            
            -   상호배제  
                -   임계 구역에 진입했다면 다른 프로세스는 접근할 수 없음  
                    
            
            -   진행  
                -   임계 구역에 프로세스가 없다면, 진입할 수 있어야함  
                    
            
            -   유한 대기  
                -   한 프로세스가 임계구역에 진입하고 싶다면, 임계 구역에 들어올 수 있어야함. 무한정 대기 X  
                    
    
    -   12-2 공유 자원과 임계 구역 (P. 351)  
        
        -   요약![](https://api.transno.com/v3/document_image/5640401a-01cd-48bc-8332-cf56957c0f6b-10826299.jpg)  
            
        
        -   동기화를 시키는 방법에 알아보자  
            
        
        -   뮤텍스 락  
            
            -   그림![](https://api.transno.com/v3/document_image/94f7aad6-428d-4f7c-8b29-3e28ac1ede31-10826299.jpg)  
                탈의실을 열어보고 자물쇠가 있다면 기다리기 아니면 탈의실 이용하기
            
            -   단, 탈의실 문을 잠겼는지 계속 반복함(바쁜대기)  
                
            
            -   하나의 공유 자원에 접근하는 방식  
                
            
            -   코드![](https://api.transno.com/v3/document_image/9c737aae-86d0-4bac-abdc-11e82e87b4ef-10826299.jpg)![](https://api.transno.com/v3/document_image/f9e54643-7704-4d66-b5b5-6a5408a896f3-10826299.jpg)  
                lock -> 자물쇠 역할  
                ​acquire -> 임계구역을 잠그는 역할  
                release -> 임계구역의 잠금을 해제하는 역할  
                
        
        -   세마포  
            
            -   그림![](https://api.transno.com/v3/document_image/8ec1e739-67e7-49c3-a452-302ce86d9acb-10826299.jpg)  
                탈의실이 여러 개 있는 상황처럼 공유자원이 여러개 있을때 각각 공유 자원에 접근 가능
            
            -   용어![](https://api.transno.com/v3/document_image/33686937-04ba-4f07-92d7-06a2a4be94cf-10826299.jpg)  
                
            
            -   대기 방식(대기 -> 준비)  
                
                -   해당 프로세스를 대기상태로 만들기  
                    
                
                -   PCB를 대기큐에 넣기  
                    
                
                -   SINGNAL 함수가 호출하면 대기큐에서 제거하기  
                    
                
                -   준비상태로 바꾸기  
                    
                
                -   준비 큐로 옮기기  
                    
        
        -   모니터  
            
            -   그림![](https://api.transno.com/v3/document_image/97faa0a4-fb2e-47b0-be5d-e90961966ece-10826299.jpg)  
                
            
            -   공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리함. 그리고 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근  
                
            
            -   조건변수를 통해서 프로세스 실행 순서를 제어함  
                
-   Chapter 13 교착 상태  
    
    -   13-1 교착 상태란 (P.367)  
        
        -   요약![](https://api.transno.com/v3/document_image/f332a310-bc88-4d21-9817-0e898c0021b2-10826299.jpg)  
            
        
        -   교착상태  
            
            -   그림![](https://api.transno.com/v3/document_image/bf66019f-9f70-47d8-bf83-79b83895769c-10826299.jpg)![](https://api.transno.com/v3/document_image/f940a17a-7e05-4741-abdb-c850805e2bc5-10826299.jpg)  
                프로세스는 원,  
                ​자원 종류는 사각형,  
                ​사용중이면 프로세스쪽 화살표,  
                대기중이면 자원쪽 화살표
            
            -   두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다린다면 그 어떤 프로세스도 더이상 진행할 수 없는 교착상태가 됌  
                
        
        -   교착상태 발생 조건  
            
            -   4가지 모두가 만족해야지 발생할 가능성이 생김  
                
            
            -   상호배제  
                -   하나의 자원은 하나의 프로세스만 이용가능  
                    
            
            -   점유대기  
                -   자원을 보유한채 다른 자원을 기다림  
                    
            
            -   비선점  
                -   다른 프로세스가 강제로 자원을 뺏을 수 없음  
                    
            
            -   원형대기  
                -   프로세스들의 요청과 자원이 원의 형태  
                    
    
    -   13-2 교착 상태 해결 방법 (P. 377)  
        
        -   요약![](https://api.transno.com/v3/document_image/a7fd459a-9ba2-4d2c-95b3-965975fe061b-10826299.jpg)  
            
        
        -   교착상태 예방  
            
            -   상호배제를 없애면?  
                -   모든 자원 공유하면.. 말이 안됌![](https://api.transno.com/v3/document_image/1e05dfc4-7506-4a75-8a6d-6de1d9b5fb3f-10826299.jpg)  
                    
            
            -   점유와 대기를 없애면?  
                -   자원의 활용율 낮아짐 + 많은 자원을 필요로하는 프로세스가 더 많이 기다리게 되는 현상  
                    
            
            -   비선점 조건을 없애면?  
                -   프린트를 예로 들면 프린트 출력중 갑자기 뺏어서 사용한다고? 말이 안됌  
                    
            
            -   원형 대기 조건을 없애면?  
                -   모든 자원을 순서있게 정렬하자 OK![](https://api.transno.com/v3/document_image/6f7179fd-756d-4d90-a06b-79c51c191552-10826299.jpg)  
                    
        
        -   교착 상태 회피  
            
            -   예시 매커니즘  
                
                -   1) 해당 자원을운영체제에 요청  
                    
                
                -   2) 자원 할당 받기  
                    
                
                -   3) 자원 사용이 끝났으면 사용한 모든 자원 반환하기  
                    
            
            -   안정상태 예시  
                
                -   교착상태가 발생하지 않는 상태  
                    
                
                -   순서 : P2 -> P1 -> P3![](https://api.transno.com/v3/document_image/ab2a5270-252d-4ecc-b9f6-1fa09e3ad04e-10826299.jpg)  
                    
            
            -   불완전상태 예시  
                
                -   교착상태가 발생한는 상태  
                    
                
                -   순서 : P2 -> P1 -> P3![](https://api.transno.com/v3/document_image/9b5c1a2d-ab21-4adf-aab9-dba638039ac2-10826299.jpg)  
                    
        
        -   교착 상태 검출 후 회복  
            
            -   1)선점을 통한 회복  
                -   다른 프로세스로부터 자원을 강제로 빼앗고 다른 프로세스에게 할당하는 방식  
                    
            
            -   2)프로세스 강제 종료를 통한 회복  
                -   교착 상태가 없어질 때까지 한 프로세스씩 종료하는 방식  
                    
            
            -   3)타조알고리즘  
                -   교착상태 무시하기  
                    
-   Chapter 14 가상 메모리  
    
    -   14-1 연속 메모리 할당 (P. 391)  
        
        -   요약![](https://api.transno.com/v3/document_image/a5321585-346c-4e09-802e-579a1feef1c9-10826299.jpg)  
            
        
        -   배경  
            -   우리는 지금까지 메모리가 연속적으로 적재되어있는 경우를 고려했다. 이를 위해서 고려해야 될점과 문제점은 어떤 것이 있는지 알아보자![](https://api.transno.com/v3/document_image/b4a98219-1c1e-4212-886c-6512e35bd5c6-10826299.jpg)  
                
        
        -   스와핑  
            
            -   스와핑이란?  
                -   대기상태, 오랫동안 사용되지 않은 프로세스를 메모리에서 보조기억장치로 보내고, 새로 생긴 공간에 다른 메모를 적재하는 방식  
                    
            
            -   스왑영역?  
                
                -   쫓겨난 영역  
                    
                
                -   그림![](https://api.transno.com/v3/document_image/f9172d61-a51e-4e2e-8eba-63ffa52cf816-10826299.jpg)![](https://api.transno.com/v3/document_image/00f333e1-5544-478c-aa1b-3ddce76ca70a-10826299.jpg)  
                    
        
        -   메모리 할당  
            
            -   메모리 내에 빈 공간이 있다면 어디에 배치를 해야할까?  
                
            
            -   그림![](https://api.transno.com/v3/document_image/f3f3fc12-b9e1-4568-9b28-ea53941f9a83-10826299.jpg)  
                
            
            -   1)최초 적합  
                -   빈 공간을 순서대로 검색하다가 발견하면 바로 배치하는 방식  
                    
            
            -   2) 최적 적합  
                -   빈 공간을 모두 검색한 후, 남은 공간중에서 가장 작은 공간에 배치하는 방식  
                    
            
            -   3) 최악 적합  
                -   빈 공간을 모두 검색한 후, 남은 공간중에서 가장 큰 공간에 배치하는 방식  
                    
        
        -   외부 단편화  
            
            -   프로세스를 할당하기 어려울 만큼 작은 메모리 공간으로 메모리가 낭비되는 현상  
                
            
            -   그림![](https://api.transno.com/v3/document_image/e79ffc3e-1a1e-4037-a18d-5ad0fec4544a-10826299.jpg)  
                남은 공간이 50MB이라도 50MB 프로세스가 적재할 수 없는 형태가 됌
            
            -   해결방안 -> 압축  
                
                -   흩어져 있는 작은 빈공간을 모아서 하나의 큰 공간으로 만들기  
                    
                
                -   그림![](https://api.transno.com/v3/document_image/15cde5b5-503b-41b1-97ec-229be698ffce-10826299.jpg)  
                    
                
                -   단점은 하던일을 중지 + 오버헤드 발생  
                    
    
    -   14-2 페이징을 통한 가상 메모리 관리 (P. 403)  
        
        -   요약![](https://api.transno.com/v3/document_image/a41867a0-c331-42cb-aa3e-5dee922ecba1-10826299.jpg)  
            
        
        -   메모리 연속적으로 할당하는 방식은 2가지 문제점  
            
            -   외부 단편화![](https://api.transno.com/v3/document_image/e79ffc3e-1a1e-4037-a18d-5ad0fec4544a-10826299.jpg)  
                
            
            -   물리 메모리보다 큰 프로세스를 실행할 수 X![](https://api.transno.com/v3/document_image/682ec857-e0ad-4c27-b672-4f88b481c021-10826299.jpg)  
                
        
        -   페이징  
            
            -   페이징이란?  
                -   메모리의 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 페이지를 프레임에 할당하는 기법  
                    
            
            -   그림![](https://api.transno.com/v3/document_image/35b8019e-8e1a-4b16-bc5f-531dc1a2beba-10826299.jpg)  
                
            
            -   스왑인/아웃 설명![](https://api.transno.com/v3/document_image/cac05da9-07c2-4a81-bf03-8f2f1cb95713-10826299.jpg)  
                
        
        -   페이지 테이블  
            
            -   프로세스가 불연속적으로 배치되면 CPU입장에서는 다음에 실행할 명령어 찾기 힘든 문제점  
                
            
            -   페이지 테이블  
                -   논리 주소는 연속적으로 배치하는 방법  
                    
            
            -   그림![](https://api.transno.com/v3/document_image/5036181e-ddf6-4e16-a227-2ae5c5c710d3-10826299.jpg)  
                
            
            -   페이지 테이블 베이스 레지스터(PTBR) -> 각 프로세스의 페이지 테이블이 적재된 주소![](https://api.transno.com/v3/document_image/cc45bb35-69c9-4c93-aaf2-0423bfa30014-10826299.jpg)  
                
        
        -   (문제점) CPU는 총 메모리 사용을 2번하게 된다. 그래서 메모리 접근시간을 늘릴 필요가 있음  
            
            -   그림![](https://api.transno.com/v3/document_image/209b15ca-e0a3-4c1b-8a57-b69329eb4bd4-10826299.jpg)  
                
            
            -   해결책  
                -   CPU 곁에 TLB라는 페이지 테이블의 캐시 메모리에 둠![](https://api.transno.com/v3/document_image/73331554-2c80-4e8d-b66f-99badbf8bad9-10826299.jpg)  
                    
        
        -   (문제점) 접근까지 OK 이제 해당 주소를 어떻게 찾아야 될까?  
            
            -   그림![](https://api.transno.com/v3/document_image/e60b31fd-b4ed-45b5-ae6d-5f841e68ea18-10826299.jpg)  
                1) 접근 하려는 페이지 OR 프레임 알아야함  
                ​2) 접근 주소가 프로세스 내에서 얼마나 떨어져 있는지 알아야됌
            
            -   (해결책) 1번은 페이지/프레임 번호 , 2번은 변위![](https://api.transno.com/v3/document_image/38c7de09-3663-4dc7-90d7-9c9ad0c4a953-10826299.jpg)  
                
            
            -   예시) 논리주소(<5, 2>)는 몇번지 물리주소인가? 10번지![](https://api.transno.com/v3/document_image/0f6226cb-fa6d-45e0-a711-292210be482e-10826299.jpg)  
                
        
        -   페이지 테이블 엔트리  
            
            -   페이지/프레임 번호, 변위 외의 중요 정보는 어떤게 있을까?  
                
            
            -   페이지 테이블 엔트리 -> 테이블의 행을 의미함![](https://api.transno.com/v3/document_image/4fe45bd9-deee-4a49-84a4-712282fbfe2b-10826299.jpg)  
                
            
            -   유효비트  
                -   현재 페이지가 메모리에 있는지/보조기억장치에 있는지 알려줌  
                    
            
            -   보호 비트  
                -   접근 권한 설정![](https://api.transno.com/v3/document_image/7612e11e-b88d-4844-92d3-0735519842e4-10826299.jpg)  
                    
            
            -   참조 비트  
                -   접근한적 있는지 확인  
                    
            
            -   수정 비트  
                -   수정한 적 있는지 WHY? 보조기억 장치 작업을 해야되는지 확인하기 위함  
                    
    
    -   14-3 페이지 교체와 프레임 할당(P. 425)  
        
        -   그림![](https://api.transno.com/v3/document_image/7c27389d-d043-43fd-ba14-8ce47f7c0c66-10826299.jpg)  
            
        
        -   (배경) 프로세스의 프레임은 어느정도 차치하게 정해야될까?? 어떤 페이지를 내보내야할까?  
            -   그림![](https://api.transno.com/v3/document_image/c3e96e09-8d46-46df-b057-015ed6751c62-10826299.jpg)  
                
        
        -   요구페이징이란?  
            -   모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법  
                
        
        -   페이지 교체 알고리즘이란?  
            -   페이지 폴트를 가장 적게 일어나는 알고리즘  
                
        
        -   FIFO 페이지 교체 알고리즘  
            
            -   그림![](https://api.transno.com/v3/document_image/02a5c453-9c28-4176-81f9-0333a2946477-10826299.jpg)  
                
            
            -   적재된 페이지 순서대로 교체하는 알고리즘  
                
            
            -   단점 -> 자주 사용하는 페이지가 오래되었다는 이유로 내보내줄 수 있음  
                
            
            -   해결법 -> 참조비트를 참고해서 기회 한번 더 주기  
                
        
        -   최적 페이지 교체 알고리즘  
            
            -   그림![](https://api.transno.com/v3/document_image/7e5454e6-92d7-4987-b0cf-20984ed12c14-10826299.jpg)  
                
            
            -   앞으로의 사용 빈도가 낮은 페이지를 교체하는 알고리즘  
                
            
            -   어떻게 앞으로 사용할지 안할지 알까?  
                -   현실적으로 불가능해서 성능 평가 용도로 사용함  
                    
        
        -   LRU 페이지 교체 알고리즘  
            
            -   그림![](https://api.transno.com/v3/document_image/2c73eada-fb8a-46d1-b0ff-71fc6873b2d0-10826299.jpg)  
                
            
            -   가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘  
                
        
        -   스래싱과 프레임 할당  
            
            -   페이지 폴트가 발생하는 또다른 이유  
                -   프레임 수의 차이![](https://api.transno.com/v3/document_image/69f46f74-7ac1-4452-b5ca-a8d7942d4209-10826299.jpg)  
                    
            
            -   스래싱이란?  
                
                -   프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제  
                    
                
                -   그림![](https://api.transno.com/v3/document_image/760e97d6-3fed-4558-89e0-2096c18be131-10826299.jpg)  
                    
            
            -   프레임 할당 방식  
                
                -   균등 할당  
                    
                
                -   비례 할당  
                    -   프로세스 크기에 따라 비례해서 프레임 할당하는 방식  
                        
                
                -   작업 집합 모델  
                    -   프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 페이지 교체 방지하는 방식  
                        
                
                -   페이지 폴트 빈도 방식  
                    -   페이지 폴트율의 상한선과 하한선을 정하고 그 범위 안에서 프레임 할당하는 방식  
                        
-   Chapter 15 파일 시스템  
    
    -   15-1 파일과 디렉터리  
        
    
    -   15-2 파일 시스템