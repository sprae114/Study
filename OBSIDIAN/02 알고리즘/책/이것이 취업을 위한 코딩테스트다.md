-   그리디  
    
    -   정의 : 현재 상황에서 가장 좋은 것만 고르는 방법(현재의 선택이 나중에 미칠 영향에 대해서는 고려X)  
        
    
    -   사전에 외우지 않아도 풀수 있지만, 많은 유형 풀이 경험 및 문제를 풀기 위한 최소한 아이디어 능력 요구  
        
        -   문제 유형을 파악하기 어렵다면 그리디 알고리즘 의심  
            
        
        -   그리디 알고리즘으로 찾을 수 없다면 다이나믹 프로그래밍 or 그래프 알고리즘 사용  
            
    
    -   기준 예시 : '가장 큰 순서대로', '가장 작은 순서대로  
        
    
    -   대부분의 문제는 그리디 알고리즘을 이용했을 때 '최적의 해'를 찾을 수 없을 가능성 많음  
        -   정당성 검토 해야함(알고리즘 문제해결 전략에서)  
            
    
    -   문제  
        -     
            
-   구현  
    
    -   정의 : 머리속에 있는 알고리즘을 소스코드로 바꾸는 과정  
        
        -   프로그래밍 언어 문법에 능숙 + 코드 작성 속도  
            
        
        -   사소한 조건 놓지지 않도록 조심  
            
        
        -   구현 문제 유형  
            
            -   Exhaustive search : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법  
                
            
            -   Simulation : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행  
                
    
    -   문제  
        
-   자료구조  
    
    -   정의 : 데이터를 표현하고 관리하고 처리하기 위한 구조  
        
    
    -   용어정리  
        
        -   Push : 데이터를 삽입  
            
        
        -   Pop : 데이터를 삭제  
            
        
        -   Overflow : 데이터의 크기가 이미 가득 찬 상태에서 삽입 연산을 수행  
            
        
        -   Underflow : 데이터가 없는 상태에서 삭제 연산을 수행  
            
    
    -   Stack  
        
        -   정의 : 상자 쌓기(선입후출FILO)  
            
        
        -   append(), pop() 사용  
            
        
        -   재귀함수에서 이용  
            
    
    -   Queue  
        
        -   정의 : 대기줄(선입선출FIFO)  
            
        
        -   collections 모듈에서 deque 자료구조 활용  
            
        
        -   append(), popleft() 사용  
            
-   Search  
    
    -   정의 : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정  
        
    
    -   그래프 형태로 표현한 다음 풀이법 고민  
        
    
    -   용어정리  
        
        -   DFS : 깊이 우선 탐색(멀리부터)  
            
        
        -   BFS : 넓이 우선 탐색(가까이부터)  
            
        
        -   Node, Vertex : 도시  
            
        
        -   Edge : 도로  
            
        
        -   Adjacency Matrix : 2차원 배열로 그래프의 연결 관계를 표현하는 방식  
            
            -   2차원 리스트로 구현  
                
            
            -   메모리 불필요 낭비, 정보를 얻는 속도가 빠름(위치 알음)  
                
        
        -   Adjacency List : 리스트로 그래프의 연결 관계를 표현하는 방식  
            
            -   2차원 리스트로 구현  
                
            
            -   메모리 효율적, 정보를 얻는 속도가 느림(하나씩 확인해야해서)  
                
    
    -   DFS  
        -   동작과정  
            
            -   1. 시작 노드를 스택에 삽입하고 방문처리  
                
            
            -   2-1. 최상단 노드에 방문하지 않은 인접노드가 있으면 그 인접 노드를 스택에 넣고 방문처리  
                
            
            -   2-2 방문하지 않은 인접 노드가 없으면 스택에서 최 상단 노드를 꺼낸다  
                
            
            -   3. 2번 과정을 수행할 수 없을 때까지 수행  
                
    
    -   BFS  
        -   동작과정  
            
            -   1. 시작 노드를 큐에 삽입하고 방문처리  
                
            
            -   2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리  
                
            
            -   3. 2번 과정을 수행할 수 없을 때까지 수행  
                
    
    -   문제  
        
        -   5-1 음료수 얼려 먹기  
            
        
        -   5-2 미로 탈출  
            
-   정렬  
    
    -   정의 : 데이터를 특정한 기준에 따라서 순서대로 나열  
        
    
    -   대부분 오름차순 내림차순 이용  
        
    
    -   면접에서 단골 문제로 출제  
        
    
    -   sorted(), sort() -> 병합정렬이용  
        -   key 값은 정렬 기준  
            
    
    -   문제유형  
        
        -   1. 정렬 라이브러리로 풀 수 있는 문제  
            -   단순히 정렬 기법을 알고 있는지 물어보는 문제  
                
        
        -   2. 정렬 알고리즘의 원리에 대해서 물어보는 문제  
            -   선택, 삽입, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다  
                
        
        -   3. 더 빠른 정렬이 필요한 문제  
            -   퀵 정렬 기반의 정렬 기법으로는 풀수 x  
                
                -   계수정렬 활용  
                    
                
                -   문제에서 기존에 알려진 알고리즘의 구조적인 개선  
                    
    
    -   Select sort  
        
        -   동작과정 : 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정  
            
        
        -   시간 복잡도 O(N^2)  
            
    
    -   Insertion sort  
        
        -   동작 과정 : 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입  
            
        
        -   데이터가 거의 정렬이 되어 있을 때 효율적  
            
        
        -   시간 복잡도 O(N^2)  
            
    
    -   quick sort  
        
        -   동작 과정  
            
            -   1. 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸기  
                
            
            -   2. 두 값이 엇갈리는 경우 '작은 데이터'와 '기준 데이터'의 위치를 서로 바꾸기  
                
            
            -   3. 1~2을 반복  
                
        
        -   정렬 알고리즘에서 가장 많이 사용  
            
        
        -   시간 복잡도 O(NlogN)  
            
    
    -   count sort  
        
        -   정의 : 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때  
            
        
        -   동작 과정  
            
            -   1. 리스트 생성(가장 작은 데이터 ~ 가장 큰 데이터)  
                
            
            -   2. 데이터 0 초기화  
                
            
            -   3. 데이터 값과 동일한 인덱스의 데이터를 1씩 증가 시킨다  
                
            
            -   4. 3번을 반복  
                
        
        -   0~100 이하인 성적 데이터를 정렬할 때 효과적  
            
            -   데이터의 차이가 작음  
                
            
            -   정수형 데이터만 사용가능  
                
        
        -   시간 복잡도O(N + K)  
            
-   이진탐색  
    
    -   Sequential Search  
        
        -   정의 : 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법  
            
        
        -   시간 복잡도 O(N)  
            
        
        -   count() 매서드 이용  
            
    
    -   Binary Search  
        
        -   조건 : 리스트 내부가 정렬되어 있어야만 사용가능  
            
        
        -   정의 : 탐색 범위를 절반씩 좁혀가며 데이터를 탐색  
            
        
        -   동작 방법:  
            
            -   1)탐색 위치를 나타내는 변수 3개를 사용(시작점, 끝점, 중간점)  
                
            
            -   2)찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교  
                
            
            -   3) 1~2번을 반복  
                
    
    -   tree  
        
        -   대용량 데이터 처리에 적합한 트리 자료구조 이용하여 항상 데이터 정렬  
            
        
        -   용어정리  
            
            -   루트 노드 : 트리의 최상단 노드  
                
            
            -   단말 노드 : 트리의 최하단 노드  
                
            
            -   서브 트리 : 트리에서 일부를 떼어내도 트리구조  
                
    
    -   Sequential Search tree  
        
        -   정의 : 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조  
            
        
        -   왼쪽 자식노드 < 부모 노드 < 오른쪽 자식 노드  
            
        
        -   구현 x, 데이터를 조회하는 과정만  
            
    
    -   문제  
        
        -   7-2 부품 찾기  
            
        
        -   7-3 떡볶이 떡 만들기  
            
-   다이나믹 프로그래밍  
    
    -   정의 : 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법  
        
    
    -   동일한 함수가 반복적으로 호출, 이미 한번 계산했지만 계속 호출할 때마다 계산하는 경우 사용  
        
    
    -   조건  
        
        -   1. 큰 문제를 작은 문제로 나눌 수 있다  
            
        
        -   2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다  
            
-   최단 경로  
    
    -   정의 : 가장 짧은 경로를 찾는 알고리즘  
        
    
    -   유형  
        
        -   다익스트라 최단경로 알고리즘  
            
        
        -   플로이드 워셜  
            
        
        -   벨만 포드 알고리즘  
            
    
    -   다익스트라 최단경로 알고리즘  
        
        -   정의 : 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구함  
            
        
        -   간단한 다익스트라 알고리즘(최단 거리가 가장 짧은 노드 찾기)  
            
            -   시간 복잡도 : O(v^2)  
                
            
            -   동작과정  
                
                -   1) 출발 노드를 설정, 최단 거리 테이블을 초기화  
                    
                
                -   2)방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택후 방문처리  
                    
                
                -   3)해당 노드를 거쳐 다른 노드로 가는 비용을 계산하고 비교하여 최단 거리 테이블을 갱신  
                    
                
                -   4)2~3 과정 반복  
                    
        
        -   heap 자료구조  
            
            -   Priority Queue 구현 위해서  
                
                -   정의 : 우선순위가 가장 높은 데이터를 가장 먼저 삭제  
                    
                
                -   우선순위 값은 보통 정수형 자료형으로 표현  
                    
            
            -     
                
        
        -   개선된 다익스트라 알고리즘  
            
            -   heap 구조 사용  
                
            
            -   시간 복잡도 : O(E*logV)  
                
            
            -     
                
-   그래프 이론  
    
-   기타  
    
    -   파이썬 리스트 크기  
        -   1,000만(10^7)이상인 경우 메모리 제한 고려  
            
    
    -   체점환경  
        -   1초에 2,000만번 연산을 수행한다고 가정  
            
    
    -   재귀함수  
        
        -   정의 : 자기 자신을 다시 호출하는 함수  
            
        
        -   while처럼 무제한으로 돌기 때문에 종료 조건을 꼭 명시  
            
        
        -   수학의 점화식으로 어떻게 만들까 생각