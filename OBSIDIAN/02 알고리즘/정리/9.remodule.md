## 각 문자들의 의미(정규표현식)
    
    [ ] => 사이의 문자들과 매치, 하이픈 사용가능 ex)a-z : a부터 z까지
    a.b => 줄바꿈을 제외한 모든 문자와 매치 ex) a0b, a=b
    ca*t => 0번 이상 반복 매치 ex) ct, caaat
    ca+t => 1번 이상 반복 매치 ex) cat, caaat
    ca{2}t  => 2번만 반복 매치 ex) caat
    ca{2, 5}t  => 2번과 5번만 반복 매치 ex) caat, caaaaat
    | : 다자택일

## 정규 표현식 궁금한거

        1. space 구분은 어떻게??
        2. - 구분은 어떻게??
        3. split 하지만 그것을 포함하고 싶을땐?
        
        
        정리
        when? 정규식 쓰는거야?
        1. 단일 + 복수개 찾거나(findall), 바꾸거나(sub), 구분지을때(split)
        2. 정규 표현식으로 표현할 수 있는거
            1) 낱말(숫자, 영단어, 한글, 특수문자..), 단어 표현 가능
            2) 포함되거나 제외한 경우([^]) 찾기 가능
            3) 반복매치(+, *, {n}), 모든 문자매치(.) 가능
            4) 처음시작(^)과 끝자락($)이 일치하는 경우 사용가능
            5) ()괄호 안의 일치되는 부분을 묶어서 나중에 사용 -> split 부분에서 나누긴 하지만 포함가능하게 나눔!!
            6) | or 기능 가능
            7) \괄호나 \\, \n, \t, \-는 \가 필요함 
        


```python
import re
#기본적인
print(re.findall('[a-z]', 'life1234_^*_ QER SA[]\n'))
print(re.findall('[a-z].', 'life1234_^*_ QER SA[]\n'))
print(re.findall('[a-z]{2}', 'life1234_^*_ QER SA[]\n'))
print(re.findall('[a-z]{1,3}', 'life1234_^*_ QER SA[]\n'))
print(re.findall('life|QER', 'life1234_^*_ QER SA[]\n'))

#+와 *의 차이
print(re.findall('[A-Z]+[ ]*', 'life1234_^*_ QER SA[]\n'))
print(re.findall('[A-Z]+[ ]+', 'life1234_^*_ QER SA[]\n'))

#🧨🧨괄호나 \\, \n, \t는 \가 필요함 
print(re.findall('[A-Z\[\n\] ]+', 'life1234_^*_ QER SA[]\n'))
```

    ['l', 'i', 'f', 'e']
    ['li', 'fe']
    ['li', 'fe']
    ['lif', 'e']
    ['life', 'QER']
    ['QER ', 'SA']
    ['QER ']
    [' QER SA[]\n']
    


```python
#제외하는 경우
print(re.findall('[^a-zA-Z]+', 'life1234_^*_ QERSA[]'))
print(re.findall('[^a-z0-9A-Z]+', 'life1234_^*_ QERSA[]'))

#🧨중간에 ^표시 안됌
print(re.findall('[a-zA-Z^_]+', 'life1234_^*_ QERSA[]'))

#🧨앞에서부터 일치하는거
print(re.findall('^[a-zA-Z]{3}', 'life1234_^*_ QERSA[]'))

#🧨뒤에서부터 일치하는거
print(re.findall('[a-zA-Z\[\]]{3}$', 'life1234_^*_ QERSA[]'))
```

    ['1234_^*_ ', '[]']
    ['_^*_ ', '[]']
    ['life', '_^', '_', 'QERSA']
    ['lif']
    ['A[]']
    

# 이거 왜 그러지??


```python
import re

A = ['sh', 'ha', 'ak', 'ke', 'e!', '!3', '32', '2 ', ' h', 'ha', 'an', 'nd', 'ds']

print([x for x in A  if not re.findall('[^a-zA-Z]+', x)])
print([x for x in A  if  re.findall('[a-zA-Z]+', x)]) #💥💥 알파벳만 들어가야 되는거 아니었어?
print([x for x in A  if re.findall('[a-zA-Z]{2}', x)])
```

    ['sh', 'ha', 'ak', 'ke', 'ha', 'an', 'nd', 'ds']
    ['sh', 'ha', 'ak', 'ke', 'e!', ' h', 'ha', 'an', 'nd', 'ds']
    ['sh', 'ha', 'ak', 'ke', 'ha', 'an', 'nd', 'ds']
    

## method

    💥spand와 end은 열림기준!!
    group()	일치된 문자열을 반환한다.
    start()	일치된 문자열의 시작 위치를 반환한다.
    end()	일치된 문자열의 끝 위치를 반환한다.
    span()	일치된 문자열의 (시작 위치, 끝 위치 - 1) 튜플을 반환한다.

## re.sub('패턴', '바꿀문자열', '문자열', 바꿀횟수) -> str


```python
import re
#패턴이 단일일때
print(re.sub('[0-9]', '#', '11 2 Fizz 42131 Buzz Fizz 7 8'))
print(re.sub('[0-9a-z]', '#', '11 2 Fizz 42131 Buzz Fizz 7 8'))

#패턴이 복수인데 따로따로 해야하는 경우
#🧨re.sub vs s.sub 차이
word = ['[0-9]', '[a-z]']
for x in word:
    s = re.compile(x)
    print(s.sub('#', '11 2 Fizz 42131 Buzz Fizz 7 8'))
```

    ## # Fizz ##### Buzz Fizz # #
    ## # F### ##### B### F### # #
    ## # Fizz ##### Buzz Fizz # #
    11 2 F### 42131 B### F### 7 8
    


```python
#output을 일정한 규칙으로 바꾸고 싶을때
#🧨🧨lambda를 이용하는 경우
print(re.sub('[0-9]+', lambda m : str(int(m.group()) * 100), '1 12 Fizz 423 Buzz Fizz 721 8'))

#함수를 이용하는 경우
def multiple10(m):        # 매개변수로 매치 객체를 받음
    n = int(m.group())    # 매칭된 문자열을 가져와서 정수로 변환
    return str(n * 100)  

print(re.sub('[0-9]+', multiple10, '1 12 Fizz 423 Buzz Fizz 721 8'))
```

    100 1200 Fizz 42300 Buzz Fizz 72100 800
    100 1200 Fizz 42300 Buzz Fizz 72100 800
    

## findall('패턴', '문자열') -> Listist

    일치하는 문자열을 list에 담아서 return해줌. 문서 내부에 패턴에 해당하는 모든 데이터를 list 타입.


```python
import re
#패턴이 단일일때
r1 = re.findall('[0-9]+', '1 2 Fizz 4 Buzz Fizz 7 8')
print(r1)

#패턴이 복수일때
word = ['[0-9]+', '[a-z]']
for x in word:
    s = re.compile(x)
    print(s.findall('11 2 Fizz 42131 Buzz Fizz 7 8'))
    
#리스트 안에 있는 것을 변환
for y in ['11 2 Fizz 43', 'Buzz Fizz 732 8']:
    print(re.findall('[0-9]+', y))
```

    ['1', '2', '4', '7', '8']
    ['11', '2', '42131', '7', '8']
    ['i', 'z', 'z', 'u', 'z', 'z', 'i', 'z', 'z']
    ['11', '2', '43']
    ['732', '8']
    

## re.finditer(pattern, string, flags) -> object
 re.findall과 비슷하지만, 일치된 문자열의 리스트 대신 matchObj 리스트를 반환


```python
import re

#+의 유/무의 파이
m1 = re.finditer('[a-z]+', 'life is too short')


if m1: #if구문이 없으면 빈 리스트일때 안됌
    for v in m1:
        print(v.group(), v.span(), v.start())
```

    life (0, 4) 0
    is (5, 7) 5
    too (8, 11) 8
    short (12, 17) 12
    

## re.match(pattern, string, flags) -> object

“문자열의 처음”부터 시작하여 패턴이 일치되는 것이 있는지를 확인


```python
import re

#단일로 나옴으로 바로 .메소드 할수 있음
print(re.match('hello|world', 'hello'))
print(re.match('[0-9]+','3 12').group())
print(re.match('[a-z]+','sda2').span())

#처음이 일치 x
print(re.match('a', 'baa'))

#🧨없으면 .메소드 사용 못함!!
m = re.match('a', 'baa')

#존재하지 않는 경우 Nonetype임으로 조건문에서 사용해야함
if m:
    print(m.group())
```

    <re.Match object; span=(0, 5), match='hello'>
    3
    (0, 3)
    None
    

## re.search(pattern, string, flags) -> object

 re.match와 비슷하지만, 반드시 문자열의 처음부터 일치해야 하는 것은 아니다.


```python
import re

#match와의 차이
print(re.search('a', 'baa'))
print(re.search('wor', 'Hello, world!'))
```

    <re.Match object; span=(1, 2), match='a'>
    <re.Match object; span=(7, 10), match='wor'>
    

## re.split(pattern, string, slit 수,flags) -> list
기본 split 함수와 비슷하지만 여러개 중복해서 구분가능!!


```python
import re

#정규 표현식으로 여러개 split 가능
print(re.split('[er!]', 'Hello, world!'))
print(re.split('([er])', 'Hello, world!'))
print(re.split('a|\s', 'abaabca'))
print(re.split('(\s)+', 'the dog the cat ds         the   cup'))

#공백 제거
print(list(v for v in re.split('a+', 'abaabca') if v))
print(list(filter(None, re.split('a+', 'abaabca'))))

print(re.split('a', 'abaabca',2))
```

    ['H', 'llo, wo', 'ld', '']
    ['H', 'e', 'llo, wo', 'r', 'ld!']
    ['', 'b', '', 'bc', '']
    ['the', ' ', 'dog', ' ', 'the', ' ', 'cat', ' ', 'ds', ' ', 'the', ' ', 'cup']
    ['b', 'bc']
    ['b', 'bc']
    ['', 'b', 'abca']
    


```python
#split인데 구분자가 포함해야되는 경우
import re

print(re.split('(a)','bbabasbababbbaabb'))
```

    ['bb', 'a', 'b', 'a', 'sb', 'a', 'b', 'a', 'bbb', 'a', '', 'a', 'bb']
    


```python
#조건문을 더 할경우
import re

print(list(v for v in re.split('a', ''.join(['a','b','aa','b','a','d','d'])) if v == 'b'))
```

    ['b', 'b']
    

## flag

- re.I : 대소문자 구분 없이 일치
- re.M : ^와 $는 개행문자 위치에서 일치
- re.S : 마침표는 개행문자와 일치
- re.X : 정규표현식에 주석을 달 수 있음
