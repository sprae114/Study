# Counter

#### string


```python
import collections

#문자열일때, dict로 바꿔주며 개수셈
print(collections.Counter('helloworld'))
print(collections.Counter('helloworld')['d'])

#최빈값 n개를 반환
#🧨list 안에 tuple인 이유 : 함수의 계산을 통해 나왔기 떄문에
print(collections.Counter('helloworld').most_common())
print(collections.Counter('helloworld').most_common(3))
print(collections.Counter('helloworld').most_common(1)[0][1])
```

    Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, 'w': 1, 'r': 1, 'd': 1})
    1
    [('l', 3), ('o', 2), ('h', 1), ('e', 1), ('w', 1), ('r', 1), ('d', 1)]
    [('l', 3), ('o', 2), ('h', 1)]
    3
    

#### list


```python
import collections

a = ["stanko", "mislav", 'john',"mislav", "ana"]
c = ["stanko", "mislav", "ana", 'j']
b = collections.Counter(a)

#Count함수 요소 뽑기 총 정리
print(b.most_common())
print(b.most_common(2))
print(b.most_common()[0][0])

print(list(zip(*b.most_common(2))))
print(list((map(list, zip(*b.most_common(2)))))[0])


#처음 발견되는 순서대로 반환
print(b.items())
print(b.keys())
print(list(b.keys()))
print(b.values())
print(list(b.elements()))

#해쉬처럼
print(b.get("mislav"))


#뺄셈과 덧셈은 집합 + 갯수까지
print(collections.Counter(a) - collections.Counter(c))
print(collections.Counter(a) + collections.Counter(c))
```

    [('mislav', 2), ('stanko', 1), ('john', 1), ('ana', 1)]
    [('mislav', 2), ('stanko', 1)]
    mislav
    [('mislav', 'stanko'), (2, 1)]
    ['mislav', 'stanko']
    dict_items([('stanko', 1), ('mislav', 2), ('john', 1), ('ana', 1)])
    dict_keys(['stanko', 'mislav', 'john', 'ana'])
    ['stanko', 'mislav', 'john', 'ana']
    dict_values([1, 2, 1, 1])
    ['stanko', 'mislav', 'mislav', 'john', 'ana']
    2
    Counter({'mislav': 1, 'john': 1})
    Counter({'mislav': 3, 'stanko': 2, 'ana': 2, 'john': 1, 'j': 1})
    

0인 목록 삭제하기 : https://leetcode.com/submissions/detail/555199089/

# deque

#### 생성
    🔥 deque(iterable,maxlen) : 최대 길이를 maxlen으로 제한가능 


```python
from queue import deque
dq = deque([1,2,3], 3)
print(dq)

#maxlen이상 들어오면 자동으로 넣는 방향에 따라 정렬
dq.append(4)
print(dq)
dq.appendleft("0")
print(dq)

#🧨maxlen을 쓰고자 할떄는 맨처음 []로 초기화 시켜야함
dq2 = deque([],2)
print(dq2)
```

    deque([1, 2, 3], maxlen=3)
    deque([2, 3, 4], maxlen=3)
    deque(['0', 2, 3], maxlen=3)
    deque([], maxlen=2)
    


```python
from queue import deque

deq = deque([[1, 2, 3, 4, 5],[1,2,3,4],[1,2,3],[1,2,],[1]])

print(deq, type(deq))
print(list(deq), type(list(deq)))
print(deq[0], type(deq[0]))
```

    deque([[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]) <class 'collections.deque'>
    [[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]] <class 'list'>
    [1, 2, 3, 4, 5] <class 'list'>
    

#### 추가

    🔥 deque.append(item): item을 데크의 오른쪽 끝에 삽입한다.
    🔥 deque.appendleft(item): item을 데크의 왼쪽 끝에 삽입한다.
    🔥 deque.extend(array): 주어진 배열(array)을 순환하면서 데크의 오른쪽에 추가한다.
    🔥 deque.extendleft(array): 주어진 배열(array)을 순환하면서 데크의 왼쪽에 추가한다.
    🔥 deque.insert(i, a) : 


```python
from queue import deque

dq = deque([1,2,3])

#append
dq.append([4])
dq.appendleft("0")
print(dq)

#extend
#🧨array 아니면 type error 발생
dq.extend([5])
dq.extendleft([-1])
print(dq)

#insert
#🧨순서 헷갈리지 말기 기억방법 : 
dq.insert(3,"QWE")
print(dq)
```

    deque(['0', 1, 2, 3, [4]])
    deque([-1, '0', 1, 2, 3, [4], 5])
    deque([-1, '0', 1, 'QWE', 2, 3, [4], 5])
    


```python
from collections import deque

a = deque([1,2,3])
b = deque([[1,2,3,4]])

print(a.pop())
print(b.pop())
```

    3
    [1, 2, 3, 4]
    

#### 삭제 
    🔥 deque.pop(): 데크의 오른쪽 끝 엘리먼트를 가져오는 동시에 데크에서 삭제한다.
    🔥 deque.popleft(): 데크의 왼쪽 끝 엘리먼트를 가져오는 동시에 데크에서 삭제한다.
    🔥 del deque[index] : 데크에서 원하는 index를 삭제
    🔥 deque.remove(item): item을 데크에서 찾아 삭제한다.


```python
from queue import deque

deq = deque([1, 2, 3, "4", 5])

#pop
#🧨pop일때, 앞하고 뒤밖에 안됌 -> pop(1) X
deq.pop()
deq.popleft()
print(deq)

#del
del deq[0]
print(deq)

#remove
deq.remove('4')
deq.remove(3)
print(deq)
```

    deque([2, 3, '4'])
    deque([3, '4'])
    deque([])
    

#### 기타
    🔥 deque.rotate(num): 데크를 num만큼 회전한다(양수면 오른쪽, 음수면 왼쪽).
    🔥 deque.reverse() : 데크를 거꾸로
    🔥 deque.index(element) : element를 활용하여 데크에서 index위치 반환
    🔥 deque.count(elemnet) : 데크에서 element의 갯수 반환


```python
from queue import deque

deq = deque([1, 2, 3, 4, 5])

#rotate
deq.rotate(2)
print(deq)
deq.rotate(-3)
print(deq)

deq = deque([1, 2, "3", 4, 5,5,5,5])
#index
print(deq.index("3"))
#count
print(deq.count(5))
```

    deque([4, 5, 1, 2, 3])
    deque([2, 3, 4, 5, 1])
    2
    4
    


```python
from queue import deque

deq = deque([[1, 2, 3, 4, 5],[1,2,3,4],[1,2,3],[1,2],[1]])

#rotate
deq.rotate(2)
print(deq)
deq.rotate(-3)
print(deq)

#reverse
deq = deque([1, 2, 3, 4, 5])
deq.reverse()
print(deq)
```

    deque([[1, 2], [1], [1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3]])
    deque([[1, 2, 3, 4], [1, 2, 3], [1, 2], [1], [1, 2, 3, 4, 5]])
    deque([5, 4, 3, 2, 1])
    


```python
print(1^1)
print(0^1)
```

    0
    1
    
