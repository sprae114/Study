## 의존관계 주입 방법은?  
- [ ]   생성자 주입  
	-  생성자 주입을 선택하는 이유?  
		-   불변  
			-   대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 **의존관계를 변경할 일이 없다.**  
			-   수정자 주입을 사용하면, setXxx 메서드를 public으로 열어두어야 한다.  
		-   누락  
			-   생성자 주입을 사용하면 주입 데이터를 누락 했을 때 **컴파일 오류가 발생**.  
			-   생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다  
	- 생성자 주입 특징은?
		-   의존관계를 주입할때, 대부분 사용하는 방법![](https://api.transno.com/v3/document_image/4b952ddb-80e1-46a4-bba3-80fb10dcf205-10826299.jpg)  
		-   생성자 호출시점에 딱 1번만 호출되는 것이 보장된다.  
		-   불변, 필수 의존관계에 사용  
		-   생성자가 딱 1개만 있으면 @ Autowired를 생략해도 자동 주입 된다.  
- [ ]   setter 주입  
	-   필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법  
	-   **선택, 변경 가능성**이 있는 의존관계에 사용  
- [ ]   필드 주입  
	-   사용하지 X   why? 외부에서 변경이 불가능해서 테스트하기 힘들다,  

## 주입할 스프링 빈이 없어도 동작해야할 때는?
- **옵션처리**(호출을 못하게 하거나 null입력)
- ![](https://api.transno.com/v3/document_image/6f1714e0-248a-4359-a36f-55862eb012fe-10826299.jpg)  
- [ ] 옵션처리 종류
	-   `@Autowired(required=false)` : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨  
	-   `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 null이 입력된다.  
	-   `Optional<>` : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다.  

## 필드 주입처럼 좀 편리하게 사용하는 방법은 없을까? => 롬북
- `@RequiredArgsConstructor` 기능을 사용하면 final이 붙은 필드를 모아서 생성자를 자동으로 만들어준다. 
	- ![](https://api.transno.com/v3/document_image/7bc7fa14-358f-42f5-8aaa-0a4e63532be0-10826299.jpg)  
-   다음과 같은 코드가 생략되어 자동 생성
	- ![](https://api.transno.com/v3/document_image/02cce9eb-d220-4619-a497-738e07dbc8a0-10826299.jpg)  
	**생성자가 1개만 있으면 @ Autowired 생략가능**  

## 의존 주입할때, 동일타입 빈이 2개 이상이면?  
- [ ] `@Autowired 필드명`
	- @Autowired 필드 명 매칭 -> 좋은 방법 X why? 구현체에 의존하게 됌(즉, 수정할때마다 고쳐야돼)
	- ![](https://api.transno.com/v3/document_image/ab251f80-4e4c-4418-9f92-9bf47bd77f40-10826299.jpg)  
		-   1. 타입 매칭  
		-   2. 타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 빈 이름 매칭  
- [ ] `@Qualifier`  
	-   추가 구분자를 붙여주는 방법  
	-   방법 
		-   1. 빈 등록시 추가 구분자 입력![](https://api.transno.com/v3/document_image/3e702b8e-93a5-4b95-a85b-a22cd9de5417-10826299.jpg)  
		-   2. 주입시에 @ Qualifier를 붙여주고 등록한 이름을 적어준다.![](https://api.transno.com/v3/document_image/e4d8262f-a2a5-4191-a2f9-13fbfaa0fcd8-10826299.jpg)  
	-   [주의점](https://dodeon.gitbook.io/study/kimyounghan-spring-core-principle/07-autowire/custom-annotation)  
		-   단, 이방법은 롬북으로는 명시해줄 수 없어서 직접 생성자를 만든 후 입력해야함.  
		-   애노테이션 직접 만들기 why?  애노테이션을 직접 만들어 애노테이션이 직접 오류가 나도록 했다.  
			-   @ Qualifier("mainDiscountPolicy") 이렇게 문자를 적으면 컴파일시 타입 체크가 안된다.  
- [ ] `@ Primary`  
	-   우선순위를 정하는 방법. 가장 선호하는 방법  
	-   방법  
		-   우선권 부여![](https://api.transno.com/v3/document_image/60738022-ecb7-4466-85cd-e6e0c726a89a-10826299.jpg)  

## 해당 타입의 스프링 빈이 다 필요한 경우에 조회 어떻게 하지?
-   [List, Map를 이용한 빈 모두 조회](https://dodeon.gitbook.io/study/kimyounghan-spring-core-principle/07-autowire/retrieve-all-beans)  
- ex) 할인 서비스를 제공하는데, 클라이언트가 할인의 종류(rate, fix)를 선택할 수 있다고 가정해보자  
- 자동, 수동의 올바른 실무 운영 기준  
    -   편리한 **자동 기능을 기본**으로 사용하자  
        -   자동 기능을 사용해도 특정 패키지에 같이 묶어두는게 좋다! 핵심은 딱 보고 이해가 되도록 하기 위함.(아니면 직접 다 찾아봐야함)  
    -   단, 다형성을 적극 활용하는 **비즈니스 로직은 수동 등록**을 고민해보자(수동 쓰면 한번에 핵심 파악하기 쉬움)