## 그렇다면 **DIP**원칙을 지키며 어떻게 바꿔야할까??  
-   인터페이스 타입 선언만  
    
-   그러면 어떻게 객체 생성??  
	-   => 생성자를 통해서 참조를 주입함!!(DIP)![](https://api.transno.com/v3/document_image/d879c746-43e8-4470-b5e6-3435388da52a-10826299.jpg)      

## OCP 원칙를 지키면서 어떻게 분리할까?  
- [ ] 관심사의 분리 무엇을?  
	- 지금 구현체의 역할은 생성과 지정 + 행동 두개로 되어있다 (SRP 위배)  
	- 그래서 Appconfig으로 전체 동작 방식을 한 클래스에서 구성(config)하기 위해, **구현 객체생성과 연결하는 책임**을 가지는 클래스
	- ![](https://api.transno.com/v3/document_image/659a4352-2abc-4936-9d91-c6ad04478f6d-10826299.jpg)

- [ ]  그러면 클래스 다이어그램이 어떻게 바뀌는 거야??![](https://api.transno.com/v3/document_image/1e672289-eb8d-43f6-b271-047ad4f50945-10826299.jpg)![](https://api.transno.com/v3/document_image/9b469a70-d242-486f-a4c9-b214c5ca2fa1-10826299.jpg)  
	기존 사용영역에만 존재하는 것이 아니라 구성역역을 추가해 생성과 연결을 도와줌
	
## AppConfig 리팩터링을 하는 이유?  
    -   중복이 많고 역할에 따른 구현이 잘 안보임  
        -   해결법 => **함수를 만들어 역할**에 따른 클래스가 보이도록 구성  

## IOC, DI, 그리고 컨테이너  
- [ ]   IOC(Inversion of Control)가 뭐야?  
	-   제어의 역전으로, 프로그램 제어를 구현체가 직접 제어를 하는 것이 아니라 appconfig에 관리하는 것을 넘겨준 것처럼 일어나는 현상  
    
- [ ]   [프레임워크 vs 라이브러리 차이는?](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%B0%A8%EC%9D%B4-%EC%A0%95%EB%A6%AC)  
     - 프레임워크 : 작성한 코드를 직접 제어하고, 대신 실행하면 프레임워크  
     - 라이브러리 : 내가 작성한 코드가 제어의 흐름을 담당하면, 라이브러리  
            
    
- [ ]   **의존관계 주입**가 뭐야?  
    -  정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각![](https://api.transno.com/v3/document_image/192dbe0d-a21f-4bd9-9735-037c4ecae9bd-10826299.jpg)![](https://api.transno.com/v3/document_image/6331a7ae-cb08-41b6-817c-970c1448dcbd-10826299.jpg)  
    의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.

## 스프링으로 전환하는 방법  
- [ ]   ApplicationContext 를 스프링 컨테이너라 함.(역할은 Appconfig와 동일)  
	-   `@ Configuration` 이 붙은 AppConfig 를 설정(구성) 정보로 사용  
	-   `@ Bean` 이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록함. 이 객체들을 스프링 빈이라함(이름은 메서드명)