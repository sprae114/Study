[[Real MySQL 8.0] InnoDB 스토리지 엔진 아키텍처 1/2 (tistory.com)](https://jjingho.tistory.com/163)
[InnoDB 스토리지 엔진 아키텍처 (velog.io)](https://velog.io/@jsj3282/4.-InnoDB-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98)
[[MySQL] 4. 아키텍처(2) (tistory.com)](https://jwkim96.tistory.com/261)
[(27) [10분 테코톡] 🔫 우기의 MySQL 아키텍처 - YouTube](https://www.youtube.com/watch?v=vQFGBZemJLQ?t=269)

#RealMyqs02

---

page.116
## 용어정리

#### 데드락이란? ✔
서로 다른 트랜잭션들이 자원을 획득하려고 **서로가 상대방의 자원을 기다리며 무한히 대기하는 현상**입니다.


#### 버퍼 역할이란?  
Insert, Update, Delete처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 하지만 버퍼 풀이 이러한 변경된 **데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수** 있다.


#### 언두 로그 vs 리두 로그 ✔
- 언두 로그 : 변경되기 이전의 데이터를 백업
- 리두 로그 : 변경된 데이터를 백업 (커밋 완료된 데이터)

## InnoDB 스토리지 엔진이란? ✔
MySQL의 스토리지 엔진 중에서 유일하게 **레코드 기반의 잠금을 제공**하며, **높은 동시성 처리가 가능**하고 안정적이며 성능이 뛰어난 스토리지 엔진이다.
![[Pasted image 20230807205729.png]]


## 외래키 지원
- InnoDB 스토리지 엔진 레벨에서만 지원한다. MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
- **외래키는 실제 서비스 운영 환경에 사용하지 않는 경우가 있다**. 그 이유는 부모와 자식 테이블에 인덱스 생성이 필요하고, 변경 시 잠금이 여러 테이블로 전파되어 **데드락이 발생할 확률이 높아지기 때문**이다.
- `foreign_key_checks` 시스템 변수를 OFF로 설정하여 외래키 관계 체크 작업을 일시적으로 멈출 수 있다. OFF한 경우 데이터 일관성에 문제가 생길 수 있으므로 반드시 부모와 자식 테이블 간 일관성을 맞춘 후 다시 활성화해야 한다.


## 실무에서 외래키를 사용하지 않는다?
[실무에서 외래키를 사용하지 않는 이유가 궁금합니다. - 인프런 | 질문 & 답변 (inflearn.com)](https://www.inflearn.com/questions/629396/%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EC%99%B8%EB%9E%98%ED%82%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%A9%EB%8B%88%EB%8B%A4)
[외래키를 사용하지 않는 이유 feat. 인덱스 (tistory.com)](https://co1nam.tistory.com/44)

실무에서는 외래키를 사용하지 않고, 참조 관계에 있는 테이블만 명시합니다. 데이터베이스 설계에서 명시적인 외래키 제약조건을 사용하지 않고, 대신 애플리케이션 로직이나 **코드 레벨에서 참조 관계를 처리한다는 의미**입니다. 이렇게 하면 **데이터베이스 스키마 변경에 대한 유연성이 증가**하고, 특정 상황에서 성능 향상을 이룰 수 있습니다. 하지만 이 경우 **무결성을 적절하게 관리하는 것이 중요**합니다.

▶학생과 강의 엔티티 생성
```java
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int studentId;
    private String name;

    // Getters and setters
    // ...
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int courseId;
    private String name;

    // Getters and setters
    // ...
}

@Entity
public class StudentCourse {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int studentCourseId;

    @ManyToOne
    @JoinColumn(name = "student_id", referencedColumnName = "studentId")
    private Student student;

    @ManyToOne
    @JoinColumn(name = "course_id", referencedColumnName = "courseId")
    private Course course;

    // Getters and setters
    // ...
}
```

▶저장소 인터페이스 생성하기
```java
public interface StudentRepository extends JpaRepository<Student, Integer> {
}

public interface CourseRepository extends JpaRepository<Course, Integer> {
}

public interface StudentCourseRepository extends JpaRepository<StudentCourse, Integer> {
}
```

▶비즈니스 로직을 담은 서비스 클래스 생성
`EnrollmentService` 클래스에서 `enrollStudentInCourse` 메서드를 구현하여 학생을 강의에 등록하고 유효성 검사를 수행합니다. 이 경우 JPA가 참조 무결성을 보장하며, 애플리케이션 레벨에서 제어됩니다.
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class EnrollmentService {
    @Autowired
    private StudentRepository studentRepository;

    @Autowired
    private CourseRepository courseRepository;

    @Autowired
    private StudentCourseRepository studentCourseRepository;

    @Transactional
    public void enrollStudentInCourse(int studentId, int courseId) {
        Student student = studentRepository.findById(studentId).orElse(null);
        Course course = courseRepository.findById(courseId).orElse(null);

        if (student != null && course != null) {
            StudentCourse studentCourse = new StudentCourse();
            studentCourse.setStudent(student);
            studentCourse.setCourse(course);
            studentCourseRepository.save(studentCourse);
        } else {
            throw new IllegalArgumentException("Invalid student_id or course_id. Enrollment not performed.");
        }
    }
}
```


## MVCC ✔
MVCC(Multi Version Concurrency Control)는 데이터베이스 시스템에서 **여러 트랜잭션이 동시에 실행되는 것처럼 보이게** 하면서도 데이터 무결성과 일관성을 유지하기 위한 메커니즘입니다. 즉,**잠금을 사용하지 않는 일관된 읽기**를 제공하는데 있다. 
InnoDB 스토리지 엔진은 **InnoDb 버터풀과 Undo 로그**를 이용해 MVCC 기능을 구현했다.

▶초기상태
`INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
![[Pasted image 20230808122027.png]]

▶UPDATE 문장이 실행
`UPDATE member SET m_area='경기' WHERE m_id=12;`
![[Pasted image 20230808122059.png]]
- InnoDB의 버퍼 풀은 새로운 값인 "경기"로 업데이트된다.
- undo 로그는 원래 값을 백업한다.

▶COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 **쿼리로 작업 중인 레코드를 조회하면** 어디에 있는 데이터를 조회한다면?
`SELECT * FROM member WHERE m_id=12;`

MySQL **초기화 파라미터에 설정된 격리 수준**(Isolation level)에 따라 다르다.
- READ_UNCOMMITTED인 경우
 -> InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환한다.
 
- READ_COMMITTED나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우
-> 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.


## 잠금 없는 일관된 읽기
InnoDB 스토리지 엔진은 **MVCC을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.**  
SERIALIZABLE이 아닌 다른 격리 수준에서는 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능하다.
![[Pasted image 20230808131343.png]]


## 자동 데드락 감지
- InnoDB 스토리지 엔진은 교착상태에 빠지지 않았는지를 **잠금 대기 목록으로 관리**한다.
**교착 상태에 빠진 트랜잭션을 강제 종료**한다. -> 언두 로그의 양이 적은 트랜잭션이 먼저 종료된다. (롤백이 적어서 서버 부하 덜 유발)

- `innodb_table_locks` 변수 : InnoDB스토리지 엔진 내부의 레코드 + 테이블 레벨 잠금

- **동시처리가 많은 경우 데드락** 감지 느려져 성능 영향을 줌. `innodb_lock_wait_timeout` 변수를 활성화하여 데드락 상황에서 **일정 시간 동안 잠금**을 획득하지 못했을 경우 요청이 실패하고 **에러 메시지를 반환**하게 하는 방식으로 문제를 우회할 수 있다.


## 자동화된 장애 복구
InnoDB는 손실이나 장애로부터 데이터를 보호하기 위한 여러 메커니즘이 탑재되어 있다.  
InnoDB 데이터 파일은 **기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행**하는데, 디스크나 서버 하드웨어 이슈로 자동 복구를 못하는 경우가 발생하면 자동 복구를 멈추고 MySQL 서버가 종료돼 버린다.

이때는 `innodb_force_recovery` 시스템 변수를 설정해서 1~6의 값을 가지며 단계 별로 선별적 자동복구를 진행하면서 서버를 재시작해본다.

- innodb_force_recovery - 1 (SRV_FORCE_IGNORE_CORRUPT)
InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작한다.

- innodb_force_recovery - 2 (SRV_FORCE_NO_BACKGROUND)
백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다. InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생한다면 이 모드로 복구하면 된다.

- innodb_force_recovery - 3 (SRV_FORCE_NO_TRX_UNDO)
커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아 있게 MySQL 서버를 시작하는 모드

- innodb_force_recovery - 4 (SRV_FORCE_NO_IBUF_MERGE)
InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 한다. 인서트 버퍼는 실제 데이터와 관련된 부분이 아니라 인덱스에 관련된 부분이므로 테이블을 덤프 한 후 다시 데이터베이스를 구축하면 데이터의 손실 없이 복구할 수 있다.

- innodb_force_recovery - 5 (SRV_FORCE_NO_UNDO_LOG_SCAN)
InnoDB 엔진이 언두 로그를 모두 무시하고 MySQL을 시작할 수 있다. 하지만 이 모드로 복구되면 MySQL 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리되므로 실제로는 잘못된 데이터가 데이터베이스에 남는 것이라고 볼 수 있다.

- innodb_force_recovery - 6 (SRV_FORCE_NO_LOG_REDO)
InnoDB 엔진이 리두 로그를 모두 무시한 채로 MySQL 서버가 시작된다. 커밋됐다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시된다. 즉, 마지막 체크포인트 시점의 데이터만 남게 된다.


## InnoDB 버터풀

### InnoDB 버퍼 풀이란? ✔
기억법 : 데이터 캐시
InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, **디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간**이다. 디스크에서 반복적으로 데이터를 읽는 것보다 메모리에서 데이터를 읽는 것이 더 빠르기 때문에 버퍼 풀은 성능 최적화의 요소로 활용됩니다. 쓰기 작업을 지연시켜 **일괄 작업으로 처리할 수 있게 해주는 버퍼 역할**도 같이 한다.
![[Pasted image 20230807205729.png]]


### 버터풀의 용도 2가지는? ✔
1) 데이터 캐싱
버퍼 풀은 디스크에 **저장된 데이터와 인덱스 페이지를 메모리에 캐싱**하는 데 사용됩니다. 이렇게 함으로써, 데이터에 대한 빈번한 액세스가 발생할 때 **디스크 I/O를 줄이고** 전반적인 성능을 향상시킬 수 있습니다. 이렇게 캐싱된 페이지들은 변경되기도 하며, 이후에 디스크에 다시 쓰여집니다.

2) 쓰기 지연 버퍼
버퍼 풀은 **데이터 변경 사항(쓰기 작업)을 일시적으로 저장**하는 데 사용됩니다. 변경된 페이지는 디스크에 즉시 쓰여지지 않고, 나중에 백그라운드 작업 또는 Checkpoint와 같은 메커니즘을 통해 한번에 디스크에 기록됩니다.
이러면 저장소를 사용한 쓰기 작업을 줄이고, **디스크 I/O에 발생하는 부하를 감소**시킬 수 있기 때문입니다.


### InnoDB 풀을 통해서 성능을 향상 시키는 방법은? ✔
1) **데이터 캐시 늘리기**
InnoDB 버퍼 풀 크기(`innodb_buffer_pool_size`)를 증가시켜 더 많은 데이터와 인덱스 페이지를 메모리에 저장할 공간을 확보하면, 디스크 I/O를 줄일 수 있습니다.

2) **쓰기 버퍼링 기능 향상**
- **리두 로그 버퍼 크기 조절**: 변경 사항을 저장하기 위한 리두 로그 버퍼 크기(`innodb_log_buffer_size`)를 늘리면, 리두 로그(crash recovery에 사용)를 **디스크에 덜 적게 되어 I/O 성능이 향상**됩니다. 일반적으로 16MB~128MB 범위가 적당합니다.
- **리두 로그 파일 크기 조절** : 리두 로그 파일 크기(`innodb_log_file_size`)를 늘리면, 체크포인트 간격이 길어져 작업 효율이 향상되고, 리두 로그 작성 요청 및 재사용을 줄일 수 있습니다. 그러나 너무 큰 파일 크기는 시스템 복구 시간이 증가할 수 있으므로, 적절한 밸런스를 찾아 설정해야 합니다.


### 버퍼풀의 크기 설정
▶버터풀 메모리 크기 설정
전체 메모리의 50% 정도로 설정하자. (50% InnoDB 버터풀 + 50% Mysql 서버, 운영체제, ...)
`innodb_buffer_pool_size` 로 설정가능함.

▶ 버터풀 인스턴스 분할
전체 버퍼 풀은 하나 이상의 메모리 영역으로 나뉘며 이를 버퍼 풀 인스턴스라고 합니다. 
버퍼 풀 인스턴스를 **여러 개로 분할하면 동시적인 I/O 작업을 더 빠르게 처리할 수** 있어 높은 병렬 처리를 필요로 하는 시스템에서 성능이 향상됩니다.
버퍼 풀 인스턴스당 5GB 정도가 되게 인스턴스 개수를 설정하자. why? 세마포어로 인해 내부 자금 경합 유발함.
`innodb_buffer_pool_instances`로 설정가능함.


### 버터풀 인스턴스를 여러개 분할한다면?
![[Pasted image 20230810172321.png]]
버퍼 풀 인스턴스를 여러 개로 분할하면 **동시적인 I/O 작업이 더 빠르게 처리될 수 있는 이유**는

1. 병렬성 증가: 버퍼 풀 인스턴스가 여러 개로 분할되면, 각 인스턴스가 **독립적으로 동작**할 수 있습니다. 여러 개의 인스턴스를 사용함으로써 동시에 수행되는 **I/O 작업의 수가 증가**하므로, 읽기 및 쓰기 작업의 처리량이 향상됩니다.

2. 경합 축소: 단일 인스턴스에서는 동시에 여러 I/O 작업이 발생할 때 경합 상황이 발생할 수 있습니다. 이러한 경합으로 인해 성능 저하가 발생하기 때문에 **여러 버퍼 풀 인스턴스를 사용하면 경합을 줄일 수** 있습니다. 각 인스턴스가 독립적으로 동작하여 버퍼 풀 내부의 자원 경합을 감소시키고, 전체 성능을 개선하게 됩니다.


### 버퍼 풀의 구조
InnoDB는 **디스크에서 읽은 데이터와 인덱스 페이지를 공간을 페이지 단위로 쪼개어 버퍼 풀에 저장**합니다. 디스크에서 데이터를 다시 읽지 않고도 **이 페이지들을 메모리에서 빠르게 액세스**할 수 있습니다. 또한, 데이터의 변경이 발생하면 버퍼 풀에서 해당 페이지를 갱신하고, **나중에 디스크에 변경을 플러시**합니다.
![[Pasted image 20230810202428.png]]

그리고 이 페이지들을 관리하기 위해 LRU 리스트, 플러시 리스트, 프리 리스트 를 관리합니다.
![[Pasted image 20230810202437.png]]

▶LRU(Least Recently Used) 리스트
![[Pasted image 20230808131358.png]]
버퍼 풀은 페이지를 저장할 때 **캐시 교체 정책으로 LRU(Least Recently Used) 알고리즘을 사용**합니다. LRU 리스트는 `New 서브리스트` 와 `Old 서브리스트` 로 나누어집니다.  이 목록에 페이지가 저장되며, 페이지 노드는 가장 최근에 사용한 순서대로 정렬됩니다. 캐시 공간이 부족해지면 목록의 마지막(가장 사용 빈도가 낮거나 오래된 페이지가 위치한 곳)에서 페이지를 제거해 공간을 확보합니다.

▶플러시(Flush) 리스트
플러시 리스트는 **디스크로 동기화 되지 않은 데이터를 가진 페이지의 변경 시점 기준의 페이지 목록을 관리**합니다.  
변경된 데이터 페이지는 먼저 버퍼 풀에서 수정되고 "Dirty page"로 표시됩니다. 플러시 목록에는 이러한 "dirty page"가 관리되며, 디스크에 변경 사항을 기록할 때 사용됩니다. 디스크에 기록하는 시점은 주기적으로 발생하는 체크포인트(Checkpoint)에서 결정됩니다.

▶프리(Free) 리스트
버퍼 풀에서 데이터로 채워지지 않은, 비어있는 페이지들의 목록입니다.


### 버퍼 풀과 리두 로그
#### 리두 로그(Redo Log)란? ✔
리두 로그는 데이터베이스에 발생한 모든 변경 작업을 저장하여 데이터베이스가 **이상 종료된 경우 복구를 가능하게 하는 로그 파일**입니다. 리두 로그는 데이터에 적용된 **변경 사항(INSERT, UPDATE, DELETE 등)에 대한 정보를 저장**합니다.

![[Pasted image 20230810202454.png]]


#### InnoDB 버퍼 풀과 리두 로그의 관계 설명의 흐름
 ![[Pasted image 20230808134703.png]]
1. 데이터 액세스
InnoDB 버퍼 풀은 RAM에서 데이터와 인덱스를 캐싱하는데 사용됩니다. 사용자가 데이터를 읽거나 변경할 때, 데이터는 먼저 버퍼 풀에 로드됩니다.

2. 데이터 변경
사용자가 데이터를 변경하는 트랜잭션을 실행하면, 변경된 데이터는 버퍼 풀에 있는 해당 페이지에서 먼저 적용되며, 이러한 변경된 데이터 페이지를 더티 페이지(Dirty Page)라 합니다.

3. 리두 로그 기록
동시에 데이터가 변경되면 변경 사항은 디스크에 기록되는 리두 로그 버퍼에도 캐시됩니다. 특정 간격(예: 커밋 시)이나 리두 로그 버퍼가 가득 찼을 때, 리두 로그 버퍼의 변경 사항이 디스크의 리두 로그 파일로 쓰기 됩니다.

4. 체크포인트 (Checkpoint)
체크포인트 프로세스가 실행되면, 리두 로그에 기록된 변경 사항이 버퍼 풀의 더티 페이지에 반영되고 해당 더티 페이지들이 디스크로 플러시 됩니다.

5. 복구 프로세스
만약 비정상 종료 또는 장애 시 복구 작업이 필요하면, 마지막 체크포인트 이후의 리두 로그 항목들을 디스크 데이터 페이지에 재적용하여 데이터의 최근 상태를 복원합니다.


#### 쓰기 버퍼링 기능 최적화
버퍼 풀에 더티페이지의 비율이 너무 높은 상태에서 갑자기 버터 풀이 필요해지는 상황이 오면 InnoDB 스토리지 엔진은 매우 많은 더티 페이지를 한 번에 기록해야 하는 상황이 오기때문에 최적값을 적절하게 선택해야함.


### 버퍼 풀 플러시
MySQL 5.6 까지는 더티 페이지를 Disk 로 Flush 하는 기능이 안정적이지 않아, 갑자기 디스크 I/O 가 폭증하는 경우가 있었지만, 이제는 Flush 기능이 안정화 되었습니다.

리두 로그 공간을 재활용 하기 위해 리두 로그 엔트리 공간을 비워야함. **리두 로그 공간이 지워질라면, 버터 풀의 더티페이지가 디스크로 동기화해야함**. 

InnoDB 는 다음 2개의 플러시 기능을 백그라운드로 실행한다.
- **Flush_List 플러시** : Flush_List 플러시 함수를 주기적으로 호출해서 더티페이지들을 디스크에 동기화한다.
- **LRU_List 플러시** :  LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해 LRU_list 플러시 함수가 사용된다.

### 버퍼 풀 상태 백업 및 복구
**디스크의 데이터가 버퍼 풀에 적재돼 있는 상태를 워밍업**(Warming UP)이라고 표현한다.

버퍼 풀이 잘 워밍업 된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보이는 것이 일반적이다. 그래서 서버 점검 등의 이유로 **서버를 재시작할 때 버퍼풀을 복구할 수 있도록**, MySQL 에서는 버퍼풀 백업 및 복구 기능을 제공한다.

```
-- MySQL 서버 셧다운 전에 버퍼 풀의 상태 백업
mysql> SET GLOBAL innodb_buffer_pool_dump_now=ON

-- MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
mysql> SET GLOBAL innodb_buffer_pool_load_now=ON
```


### Double Write Buffer
리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 하드웨어의 오작동이나 시스템 비정상 종료 등의 문제로 인해 InnoDB 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제(파셜 페이지 또는 톤 페이지)가 발생하면 그 페이지에 대한 내용을 복구할 수 없을 수도 있다.

DB 스토리지 엔진에서는 Double-Write 기법을 사용해 이러한 문제를 해결한다.
![[Pasted image 20230810212226.png]]

1. 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 묶어 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다.
2. InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 랜덤 쓰기를 실행한다.
3. **데이터 파일의 페이지들과 DoubleWirte 버퍼의 내용을 비교**한다.
4. 데이터 파일 페이지와 DoubleWirte 버퍼의 내용이 다르다면 DoubleWirte 버퍼의 내용을 데이터 파일의 페이지로 복사한다.


## 언두 로그
### 언두 로그란? ✔
언두 로그는 **트랜잭션이 실패하거나 롤백이 필요한 경우 데이터를 이전 상태로 되돌릴 수** 있도록 하는 로그 파일입니다. 언두 로그는 트랜잭션 내에서 **수정된 데이터에 대한 이전 버전의 정보를 저장**합니다.


### 언두 로그의 기능 ✔
1) 트랜잭션 롤백하면 언두 영역의 백업된 데이터 파일로 복구함.
2) 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공함.


### 언두 로그 레코드 모니터링
**대용량의 데이터를 처리하거나 오랜 시간 실행되는 트랜잭션으로 인해 언두 로그의 양이 증가할 수** 있다. InnoDB 스토리지 엔진은 언두 로그의 이력을 필요한 만큼 스캔해야 레코드를 찾을 수 있기 때문에 **쿼리 성능이 떨어질 수 있다.**


### 언두 테이블스페이스 관리
언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다. MySQL 8.0 으로 업그레이드되면서 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선되었다.


## 체인지 버퍼
**인덱스 페이지 변경 작업을 효율적으로 처리**하기 위해 사용됩니다. 인덱스 페이지를 버퍼 풀이 아닌 디스크를 통해 읽어와야 할 경우 즉시 실행하지 않고 **버퍼 풀의 일부 영역에 저장하게 되는데, 이는 디스크 I/O를 줄이는 데 도움**이 됩니다.

다음과 같은 과정을 따르게 됩니다.
1. 인덱스 페이지 변경 최적화: InnoDB는 인덱스 페이지 변경 작업(예: 삽입, 삭제, 수정)을 순차적으로 처리하는 대신, 변경 사항을 체인지 버퍼 영역에 먼저 저장합니다. 이렇게 함으로써 디스크 I/O를 최소화하고 성능을 향상시킵니다.

2. 변경 사항 병합: 변경 사항이 기록된 체인지 버퍼는 나중에 인덱스 페이지를 디스크에서 로드할 때 병합됩니다. 이런 식으로 변경 사항이 메모리에서 처리되므로 I/O 비용이 절감됩니다.

3. 체크포인트 및 백그라운드 작업: 체크포인트 생성 시 또는 InnoDB 백그라운드 작업 중에 체인지 버퍼의 내용이 인덱스 페이지와 병합되어 디스크에 저장됩니다. 이 과정에서 더티 페이지가 플러시되어 데이터 일관성을 유지합니다.


## 리두 로그 및 로그 버퍼
### 리두 로그란? ✔
데이터베이스에서 **트랜잭션이 발생할 때 데이터의 변경 사항을 저장하는 로그 파일**입니다.


### 리두 로그로 복구하는 방법은?
리두 로그는 MySQL 서버가 **비정상적으로 종료되었을 때** 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치의 역할을 한다. 비정상적인 종료로 인한 데이터는 두 가지 종류고 **각 데이터의 복구 방법**은 다음과 같다.

▶커밋되었지만 데이터 파일에 기록되지 않은 데이터
- 리두 로그를 사용하여 데이터 복사로 복구

▶ 롤백되었지만 데이터 파일에 이미 기록된 데이터
- 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 복사하고, 이후 리두 로그 진행함.


### 리두 로그 아카이빙
데이터베이스의 **리두 로그를 보관하고 관리**하는 프로세스입니다. 리두 로그는 데이터베이스에서 발생하는 모든 데이터 변경 사항을 기록하는 로그 파일입니다. 이러한 변경 사항은 트랜잭션 처리 과정에서 데이터베이스 복구와 데이터 일관성을 유지하기 위해 사용됩니다.


## 어댑티브 해시 인덱스 ✔
InnoDB 스토리지 엔진에서 **사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 해시 인덱스**이다. 자주 읽히는 데이터 페이지의 키 값을 이용하여 인덱스를 만들어 저장된 데이터 페이지를 즉시 찾아갈 수 있도록 도와준다.  **B-트리 인덱스와 비교하여 상대적으로 빠른 검색 성능을 제공**합니다.
![[Pasted image 20230807205729.png]]

키 값은 B-Tree 인덱스의 고유번호(Id)와 B-Tree 인덱스의 실제 키 값의 조합이며, 이 키 값은 버퍼 풀에 로딩된 데이터 페이지의 주소를 저장한다.

### 어댑티브 해시가 필요한 경우
1) 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷함(디스크 읽기가 많지 않음)
대부분이 메모리에 올라와 있기 때문에 디스크 읽기와 관련된 성능 부담이 상대적으로 적습니다. 어댑티브 해시 인덱스를 사용하면 메모리 내에서 더 빠른 검색 성능을 제공할 수 있으며, 전체 시스템 성능을 향상시킵니다.

2) 동등 조건 검색이 많은 경우
동등 조건 검색은 특정 키 값과 일치하는 데이터를 질의하는 경우입니다. 어댑티브 해시 인덱스가 해시 함수를 사용하여 데이터의 메모리 위치를 즉시 찾아갈 수 있기 때문에, 동등 조건 검색에 대한 성능을 크게 향상시킬 수 있습니다.

3) 쿼리가 데이터 중 일부에만 집중되는 경우
InnoDB 엔진이 실시간으로 데이터 접근 패턴을 모니터링하며 해당 인덱스에 대한 해시 인덱스를 동적으로 관리하므로, 이러한 경우에 어댑티브 해시 인덱스의 효율이 높아집니다.

## InnoDB vs MyISAM ✔
![[Pasted image 20230812000700.png]]