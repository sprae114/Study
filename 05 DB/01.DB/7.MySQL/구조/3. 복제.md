[(27) [10분 테코톡] ✌️ 영이의 Replication - YouTube](https://www.youtube.com/watch?v=95bnLnIxyWI&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=191)

[[10분 테코톡] 앤지의 DB Replication - YouTube](https://www.youtube.com/watch?v=NPVJQz_YF2A&pp=ygUM7Jqw7YWM7L2UIGRi)


#RealMyqs05

---

### Replication이란? ✔
데이터베이스의 데이터를 **한 시스템에서 다른 시스템으로 복사하거나 동기화하는 과정**을 말합니다. 이를 통해 여러 서버간에 데이터 일관성을 유지할 수 있고, 가용성을 향상시키며, 백업 및 데이터 분석 목적으로 활용할 수 있습니다.

![[Pasted image 20230812170147.png]]
- 원본 데이터를 가지는 서버를 Source 서버 
- 복제된 데이터를 가지는 서버를 Replica 서버


## 클러스터링과 복제의 차이점은?
- Clustering은 단순히 데이터베이스 서버를 확장한 것이라면 
- Replication은 데이터베이스 서버와 스토리지 모두를 확장하게 된다. 이때 단순히 확장만 하는 것이 아니라 메인으로 사용할 Master 서버와 이를 복제한 Slave 서버로 구성하게 된다.


## Replication을 사용하는 이유는? ✔
1) **부하를 줄이기** 위해서 (Scale-out)
- 갑자기 늘어나는 트래픽을 대응하는데 유연한 구조입니다.

2) **데이터 백업**
- 레플리카를 안하더라도 백업을 해야합니다. But, 백업 과정은 실제 실행중인 쿼리들에 영향을 줄 수 있습니다. 그래서 **레플리카 서버에서 데이터 백업을 실행하여 소스 서버에서 백업** 시 발생하는 문제 해결

3) **데이터 분석**
- 분석용 쿼리는 대량의 데이터를 조회하고, 쿼리 자체가 무거운 경우가 많습니다. 소스 서버에서 하게 되면 문제가 될 수 있으니, **레플리카 서버에서 분석용 쿼리만 전용**으로 하는 것이 좋습니다.

4) **데이터의 지리적 분산** 
- 데이터베이스와 애플리케이션 **서버가 멀리 떨어져있다면 응답을 늦게** 받게됩니다. 빠른 응답을 위해 애플리케이션 서버에 가깝게 서버를 구성하는 것이 좋음


## 바이너리 로그란? (binlog) ✔
MySQL 서버에서 발생하는 **모든 변경사항을 별도의 로그 파일에 순서대로 저장**

- 데이터의 변경내역
- 데이터베이스나 테이블의 구조 변경
- 계정이나 권한의 변경 정보

MySQL에서 다음 명령어로 확인 가능하다. 
```
show binary logs; // binlog 확인
show master status; // 파일명과 위치 정보 파악
```


## MySQL Replication 동작 원리 ✔
**소스 서버에서 생성된 Binary Log가 레플리카 서버로 전송되고, 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤 자신이 가진 데이터에 반영하므로써 동기화**가 이루어진다.

이는 세개의 스레드에서 이루어진다. 
![[Pasted image 20230814004818.png]]

1) Binary Log Dump Thread
- 소스 서버에 존재하며, **binary log를 레플리카 서버로 전송하는 역할**
- 레플리카 서버가 소스 서버에 연결되면 소스 서버에서 내부적으로 Binary Log Dump Thread를 생성

2) Replication I/O Thread
- 레플리카 서버에 존재하며, **Binary Log Event를 가져와 로컬 서버의 파일(Relay Log)로 저장**하는 역할
- 복제가 시작될 때 스레드가 생성되고 복제가 끝나면 스레드 종료

3) Replication SQL Thread
- 레플리카 서버에 존재하며, **릴레이 로그 파일의 이벤트들을 읽고 실행**
- Applier Metadata : 릴레이 로그에 저장된 **소스 서버의 이벤트들을 서버에 저장**하는 컴포넌트


## binary log를 어떻게 변경 내용을 식별하는가?
기본적으로 레플리케이션을 사용하려면 소스 서버에 반드시 binlog가 활성화되어 있어야한다. 

#### 바이너리 로그 파일 위치 기반
**레플리카 서버에서 소스 서버의 binary log 파일명과 파일 내에서 위치로 개별 binary log 이벤트를 식별해서 복제가 진행되는 형태**를 말한다.
![[Pasted image 20230815050837.png]]

![](https://blog.kakaocdn.net/dn/vwLkm/btrlEsWzV25/crBOnMTcZ8CsJ5GeslAtzk/img.png)

이벤트가 최초로 발생한 MySQL 서버를 식별하기 위해 server_id를 사용한다.  
기본값은 1인데 레플리케이션을 하게 된다면 레플리카 서버에 반드시 server_id를 각각 다르게 지정해주어야 한다. 

하지만 이 방식은 **식별 과정이 소스 서버에서만 유효**하다는 단점이 있다. **동일한 이벤트가 레플리카 서버에서 동일한 위치와 동일한 파일명으로 저장된다는 보장이 없습니다.** 
(참고 https://youtu.be/NPVJQz_YF2A?t=212)

예를 들어, 다음과 같이 소스서버가 고장난 경우를 생각해보자.
![[Pasted image 20230815051048.png]]

레플리카 서버 A가 소스 서버로 승격된 경우. 복제에 참여하는 기존 서버들은 소스 서버의 바이너리 로그를 다시 찾아야함.
![[Pasted image 20230815051104.png]]


#### 글로벌 트랜잭션 ID 기반 (GTID)
관계형 데이터베이스 시스템에서 일반적으로 사용되는 복제 방식입니다. GTID 기반 복제는 바이너리 로그 파일 위치 기반 복제의 한계를 극복하기 위한 방법으로, **각 트랜잭션에 고유한 식별자를 할당해 소스 서버와 레플리카 서버 사이의 데이터 일관성**을 높입니다.
![[Pasted image 20230815051024.png]]

![[Pasted image 20230815051526.png]]


## 바이너리 로그는 어떻게 생겼을까? ✔
#### Statement 방식
- **SQL 문을 바이너리 로그에 그대로 기록**
- MySQL에 binlog가 처음 도입되었을 때부터 있던 방식
- **트랜잭션의 격리 수준이 반드시 REPEATABLE-READ 이상이어야 한다.** 그 이유는 하나의 트랜잭션에서도 각 쿼리가 실행되는 시점마다 스냅샷이 달라질 수 있어 이로 인해 복제 시 서버와 레플리카 서버의 데이터가 일치하지 않을 수 있기 때문입니다.

장점
- 손쉽게 SQL문들을 확인할 수 있다.
- 여러개의 데이터를 수정하는 쿼리여도 바이너리 로그에 하나의 SQL만 기록된다. 그로 인해 공간 활용이 늘어나고 빠른 처리가 가능하다.

단점
- **비확정적 처리 될 수 있는 쿼리**가 실행된 경우 Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버 간 **데이터가 달라질 수 있다.**

예를 들어, 주문 목록을 저장하는 테이블이 있고, 가장 최근 3개의 주문을 삭제하려 한다고 가정합시다. 이 때, 다음과 같이 DELETE 쿼리를 작성하면 최근 주문 데이터를 찾지 못하고 무작위로 3개의 주문을 삭제할 수 있습니다.

```sql
DELETE FROM orders LIMIT 3;
```

이 경우, Master 서버에서 실행 결과는 레플리카 서버에서의 결과와 달라질 수 있습니다. 이러한 비확정적 쿼리는 복제 과정에서 데이터 불일치를 초래할 수 있습니다.

이 문제를 해결하기 위해 확정적(deterministic) 쿼리를 사용하도록 수정합니다. 예를 들어, 주문 날짜를 기준으로 정렬하여 DELETE문을 사용하면, 무작위 선택 대신 명확한 기준으로 데이터를 삭제할 수 있습니다.
```sql
DELETE FROM orders
ORDER BY order_date DESC
LIMIT 3;
```


#### Row 방식
- **변경된 데이터 자체를 기록**
- MySQL 5.7.7 버전 이후부터 바이너리 로그 기본 포맷 

장점
- 어떤 형태의 쿼리든지 복제 시 소스 서버와 레플리카 **서버의 데이터를 일관**되게 한다. 

단점
- 많은 데이터를 변경하면 **모든 데이터가 전부 기록되어 바이너리 로그 파일이 단 시간에 매우 커진다.**
- **어떤 쿼리가 실행되었는지는 확인하기 어렵다.**


#### Mixed 방식
- 위 두 방식을 혼합
- 쿼리의 대부분은 Statement 방식으로 기록될 확률이 높은데, 실행된 쿼리가 Statement 포맷으로 기록되어 **복제됐을 때 문제가 될 가능성 있는 안전하지 못한 쿼리라면 Row 방식으로 기록**

다음과 같은 명령어로 변경이 가능하다.

```
set global binlog_format = 'STATEMENT';
```


## 복제 동기화 방식
소스 서버가 레플리카 서버에 **이벤트들이 잘 보내졌는 지 확인하냐 안하냐**에 따라 복제 동기화 방식을 설정할 수 있다.

#### 비동기 복제
**소스 서버가 레플리카 서버에서 변경 이벤트가 정상적으로 전달 되었는지 확인하지 않는다.**   
소스 서버에 장애가 일어나면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있다.

![[Pasted image 20230814012521.png]]


#### 반동기 복제
소스 서버는 **레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답을 보내면 그때 트랜잭션을 완전히 커밋**한다.  
하지만 전송이 보장된 것이지 적용이 보장된 것은 아니다.   
소스 서버는 일정 시간동안 기다리다 응답이 없으면 비동기 방식으로 변경된다. 

![[Pasted image 20230814012555.png]]


## 소스, 레플리카 서버는 어떻게 구성할까? ✔
#### 싱글 레플리카 복제
![[Pasted image 20230814012749.png]]
하나의 소스서버에 하나의 레플리카 서버만을 두는 구조입니다.

주로 다음과 같은 목적으로 사용됩니다
1. 데이터 분산 읽기 및 부하 분산: 마스터 서버에 대한 읽기 요청 부하를 레플리카 서버에 분산시켜 성능을 향상시키고, 마스터 서버에는 쓰기 작업을 전담합니다.
2. 백업 및 실패 예방: 레플리카 서버는 데이터 백업 용도로 사용되며, 마스터 서버에 문제가 발생한 경우 레플리카 서버로부터 데이터를 복원할 수 있습니다.

#### 멀티 레플리카 복제
![[Pasted image 20230814012830.png]]
하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태이다. 하나의 서버는 예비용으로 구성하고, 다른 서버는 읽기 전용으로 구성한다. 

주로 다음과 같은 목적으로 사용됩니다
1. 높은 가용성: 데이터를 여러 레플리카 서버와 동기화함으로써, 어떤 서버에 문제가 발생해도 데이터가 손실되지 않고, 다른 레플리카 서버에서 데이터를 계속 사용할 수 있습니다.
    
2. 부하 분산 및 성능 향상: 읽기 작업을 여러 레플리카 서버로 분산시키고, 각 서버의 부하를 줄이기 때문에 전체 시스템 성능이 향상됩니다. 이를 통해 읽기 요청의 속도가 빨라지고, 마스터 서버는 쓰기 작업에 집중할 수 있습니다.

#### 체인 복제
![[Pasted image 20230814012840.png]]
하나의 소스 서버에 연결된 레플리카 서버 수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수 있을 때 사용한다.   
소스 서버가 해야하는 바이너리 로그 배포 역할을 새로운 서버로 넘긴다. 

#### 듀얼 소스 복제
![[Pasted image 20230814012853.png]]
두개의 서버가 서로 소스 서버이자 레플리카 서버로 구성되어 있다.   
두 서버 모두 쓰기가 가능하며, 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에서 쓰기가 발생하지만 두 서버는 서로 동일한 데이터를 갖게 된다.

트랜잭션 충돌이 일어나기 때문에 잘 사용하지 않는다.

#### 멀티 소스 복제  
![[Pasted image 20230814012857.png]]

하나의 레플리카 서버가 둘 이상의 소스 서버를 가진다.   
여러 서버에 존재하는 다른 데이터를 하나의 서버로 통합하거나, 샤딩되어 있는 테이블 데이터를 하나의 테이블로 통합할 때 사용할 수 있다.

▶샤당이란?
데이터베이스 분리 기법 중 하나로서, **대용량 데이터를 처리하는 것이 어려운 경우 전체 데이터를 여러 개 smaller 데이터 세트로 분할하고, 각 데이터 세트를 별도의 서버 또는 클러스터(폴리오)에 저장하는 방식**입니다. 이렇게 분할된 각각의 데이터 부분을 '샤드(Shard)'라고 부릅니다. 이 방식은 데이터베이스 성능 향상, 가용성 높이기 및 관리 비용 절감을 효과적으로 지원합니다.


## 크래시 세이프 복제 ✔
복제를 하다가 레플리카 서버에 문제가 생긴다면 어떻게 해결할까?

![[Pasted image 20230815052300.png]]
레플리케이션 I/O 스레드와 레플리케이션 SQL 스레드를 이용해서 소스 서버에 바이너리 로그 이벤트 위치를 읽을 때와 트랜잭션 실행정보를 읽을 때 어디까지 읽었는 지에 대한 포지션 정보를 로컬에 저장해두게 됩니다. 
그래서 레플리카 서버를 재가동할때, 그 정보를 바탕으로 다시 소스 서버와의 동기화를 이룹니다.