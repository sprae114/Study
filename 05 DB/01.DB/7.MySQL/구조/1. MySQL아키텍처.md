[(27) [10분 테코톡] 🔫 우기의 MySQL 아키텍처 - YouTube](https://www.youtube.com/watch?v=vQFGBZemJLQ)
[(27) [10분 테코톡] 릭의 MySQL 아키텍처 - YouTube](https://www.youtube.com/watch?v=8PRkLItDwXQ)

#RealMyqs01

---
page.94

# 목표
1) SQL문이 MySQL로 들어왔을 때, 매커니즘
2) 쿼리 실행 과정

# 1.MySQL 전체 구조
![[Pasted image 20230807155736.png]]

## MySQL 엔진이란? ✔
기억법 : 두뇌 담당
클라이언트를 통해 전달된 **SQL 쿼리를 구문 분석, 쿼리 실행 계획 생성, 최적화 및 쿼리 실행과 같은 작업을 처리**하는 데이터베이스 관리 시스템의 핵심 부분입니다. MySQL 엔진은 클라이언트 요청에 대한 처리를 담당하며, **연산을 수행한 후 핵심 데이터 작업을 스토리지 엔진에 위임**합니다.


## 스토리지 엔진이란? ✔
기억법 : 손발 담당
MySQL 서버의 **데이터 저장 및 관리를 담당하는 하위 시스템**입니다. 스토리지 엔진은 표, 인덱스 등의 MySQL 객체를 파일 시스템에 저장하는 방법을 결정하고, **CRUD(Create, Read, Update, Delete) 작업을 처리**합니다. MySQL은 **특정 테이블마다 다른 스토리지 엔진을 사용할 수** 있는 플러그 가능한 구조를 지원하며, 각 스토리지 엔진은 성능, 기능 및 사용 사례에 따라 다양한 특징을 제공합니다.


## 스토리 엔진의 종류는?
▶현재 테이블의 스토리지 엔진 확인하기
```
mysql> SHOW TABLE STATUS FROM test;
```

- InnoDB
**기본적으로 제공**되는 스토리지 엔진으로서 대부분의 경우에 추천됩니다. InnoDB는 외래 키(Foreign Key) 제약 조건과 ACID(Atomicity, Consistency, Isolation and Durability) 속성을 준수하는 거래(Transaction) 안전성 보장 기능이 있습니다.

- MyISAM
이전 버전에서 기본적인 옵션이었으나 현재는 **거래 안전성(Transaction Safety)과 외래 키(Foreign Key) 지원 부재**로 인해 **잘 사용되지 않습니다**. 그러나 **읽기 전용** 또는 과거 호환성 요구사항이 있는 경우 유효할 수 있습니다.

- MEMORY (HEAP)
모든 데이터와 인덱스가 메모리 상주(**RAM** 내부 저장) 형태로 저장되기 때문에 매우 빠른 읽기/쓰기 속도를 제공합니다. 그러나 **서버가 종료되면 데이터 손실**되며, 고정 크기의 테이블만 지원하므로 **대용량 데이터에는 적합하지 않습니다.**


## InnoDB 특징은? ✔
- **트랜잭션 지원**
InnoDB는 트랜잭션을 지원하며, ACID(Atomicity, Consistency, Isolation, Durability) 속성을 충족하므로 어플리케이션에서 데이터 무결성을 높이는 데 사용됩니다.

- **행 수준 잠금**
데이터 **수정 시 행 수준에서 잠금이 처리되므로 동시성 및 성능이 향상**됩니다. 동시에 여러 트랜잭션이 하나의 테이블에 액세스하더라도 각 트랜잭션이 특정 행에만 영향을 미칠 때 사용됩니다. 행 수준 잠금을 사용함으로써, 여러 트랜잭션이 독립적으로 작업할 수 있고, 공유 자원에 대한 경쟁을 최소화하여 성능과 동시성을 높입니다.

▶행 수준 잠금의 작동 원리
1. 트랜잭션 A가 특정 행을 수정하거나 삭제하려고 할 때, 해당 행에 잠금이 설정됩니다.
2. 트랜잭션 B가 같은 행에 액세스하려고 하면, 트랜잭션 A가 작업을 완료하고 잠금을 해제할 때까지 기다려야 합니다.
3. 이 기간 동안 트랜잭션 B는 다른 행에 액세스하여 작업을 계속할 수 있습니다. 이로 인해 동시성이 향상되고, 대기 시간이 줄어듭니다.

- **외래 키(Foreign Key) 지원**
InnoDB는 외래 키 제약 조건을 지원하여 관계형 데이터베이스의 무결성을 고려할 수 있습니다.

- **Crash Recovery**
InnoDB는 트랜잭션 로그 기반의 복구 메커니즘을 가지고 있어서 시스템 장애 발생 시 데이터를 복구할 수 있습니다.


## 핸들러 API(핸들러 요청)이란?
**MySQL 엔진에서 스토리지 엔진에 데이터 읽기, 쓰기 요청을 헨들러 요청**이라고 한다.즉, MySQL 엔진은 이 헨들러 요청들을 통해서만 디스크로부터 데이터를 읽고, 쓸수있다.

▶ 얼마나 많은 핸들러 요청이 있었는지 확인하기
```
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';

+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
| Handler_commit             | 647   |
| Handler_delete             | 8     |
| Handler_discover           | 0     |
| Handler_external_lock      | 6869  |
| Handler_mrr_init           | 0     |
| Handler_prepare            | 16    |
| Handler_read_first         | 61    |
| Handler_read_key           | 1922  |
| Handler_read_last          | 0     |
| Handler_read_next          | 4358  |
| Handler_read_prev          | 0     |
| Handler_read_rnd           | 0     |
| Handler_read_rnd_next      | 4046  |
| Handler_rollback           | 0     |
| Handler_savepoint          | 0     |
| Handler_savepoint_rollback | 0     |
| Handler_update             | 350   |
| Handler_write              | 1302  |
+----------------------------+-------+
18 rows in set (0.11 sec)
```


## 커넥션 핸들러란?
**클라이언트와 서버 간의 연결을 관리**하는 데 사용되는 소프트웨어 구성 요소입니다. 커넥션 핸들러는 네트워크 요청을 처리하며, 적절한 리소스 할당과 작업 분배를 할당하는 역할을 합니다.

▶핸들러란?
핸들러(handler)는 일반적으로 프로그래밍 및 소프트웨어 개발에서 사용되는 용어로, 특정 이벤트, 요청 또는 작업을 처리하는 역할을 담당하는 코드 블록, 함수, 객체, 시스템, 또는 모듈을 의미합니다.


## 스레드 관점에서 mysql이 어떻게 연결되는 걸까?
[MySQL :: The New MySQL Thread Pool](https://dev.mysql.com/blog-archive/the-new-mysql-thread-pool/)
[MySQL :: MySQL Connection Handling and Scaling](https://dev.mysql.com/blog-archive/mysql-connection-handling-and-scaling/)

![[Pasted image 20230810150217.png]]
![[Pasted image 20230808120015.png]]

1. 클라이언트 연결 요청: 클라이언트가 MySQL 서버에 연결 요청을 보냅니다.
    
2. 수신 스레드 작동: MySQL 서버에서는 수신 스레드가 생성되어 클라이언트의 연결 요청을 받습니다. 통신 프로토콜은 TCP/IP, 유닉스 소켓, 네임드 파이프 등을 통해 이루어집니다.
    
3. 인증 및 권한 확인: 클라이언트는 사용자 이름과 비밀번호를 제공하고, MySQL 서버는 제공된 인증 정보를 확인한 후 사용자 권한을 검사합니다.
    
4. 쿼리 요청 처리: 인증이 완료된 후, 클라이언트가 SQL 쿼리를 전송합니다. 수신 스레드는 전송된 쿼리를 받아서 포그라운드 스레드로 전달합니다. 포그라운드 스레드는 쿼리를 파싱, 최적화 및 실행하고 결과를 클라이언트에 반환합니다.
    
5. 연결 종료: 클라이언트가 연결을 종료하거나 서버에서 연결이 종료되면, 해당 수신 및 포그라운드 스레드가 소멸되고 연결 리소스가 해제됩니다.


# 2.MySQL의 스레딩 구조 
![[Pasted image 20230807161717.png]]
프로세스 기반이 아닌 **스레드 기반으로 동작**, 포그라운드와 백그라운드로 구분할 수 있다.


## 포그라운드 스레드
일반적으로 **사용자의 요청을 직접 처리하는 스레드로, SQL 쿼리 실행 등의 작업**을 담당합니다. 포그라운드 스레드는 클라이언트와 직접적으로 통신하며, 대화형 작업이나 주요 데이터 처리 작업을 수행합니다. 이러한 스레드는 **사용자의 특정 작업 요청에 응답하는 데 필요한 동작만을 실행하며, 작업이 완료되면 결과를 클라이언트에 반환**합니다.

- 최소 접속된 클라이언트의 수만큼 존재합니다. (그래서 사용자 스레드라고도 함)
- 커넥션을 종료하면 스레드 캐시로 돌아가거나 종료합니다. (스레드 캐시에 저장된 스레드 수를 일정하게 유지한다. 시스템 변수로 설정 가능)
- 데이터 버퍼나 캐시로부터 데이터를 가져오거나 직접 디스크의 데이터를 읽어와서 작업합니다.


## 백그라운드 스레드
주로 **관리 및 유지 관리 작업에 사용**되며, 시스템 운영에 필요한 다양한 기능을 수행합니다. 백그라운드 스레드는 사용자의 요청을 처리하는 것이 아니라, **데이터베이스의 내부 작업을 처리하기 위해 실행**됩니다. 이러한 스레드는 일반적으로 다음과 같은 작업을 수행합니다.


## 백그라운드 스레드에서 사용되는 스레드 종류는?
- 마스터 스레드 (Master Thread)
마스터 스레드는 체크포인트 생성, 더티 페이지를 디스크로 플러시, 로그 팔릿 (flush) 작업 등을 실행합니다. 또한, 이 스레드는 시스템 전반의 성능과 안정성을 유지하기 위한 **주기적인 작업을 수행**합니다.

- 로그 스레드 (Log Thread) -> 중요
로그 스레드는 트랜잭션 로그 버퍼에 있는 로그 레코드를 데이터베이스 **로그 파일로 플러시하는 역할**을 담당합니다. 이 작업은 데이터 무결성과 복구를 위해 필요합니다.

- IO 작업 스레드 (IO Helper Threads) -> 중요
IO 작업 스레드는 비동기 읽기-쓰기 작업이나 인덱스 정리 작업 등, **시스템 전반의 I/O 요청을 처리**합니다. 이 스레드는 다양한 I/O 작업의 부하를 분산하여 시스템의 성능을 향상시키는 데 도움을 줍니다.

- Purge 스레드 (Purge Thread)
퍼지(purge) 스레드는 더 이상 필요하지 않은 트랜잭션 내역을, 시스템의 오버헤드를 줄이기 위해 **정리하는 역할**을 합니다. 이 작업은 다중 버전 교차 커밋(MVCC)을 지원하는 InnoDB에서 필요합니다.

- 모니터 스레드 (Monitor Thread)
모니터 스레드는 데이터베이스 시스템의 전반적인 **상태와 성능을 모니터링**하며, 필요한 경우 성능 개선을 위한 조치를 취합니다.


# 3.메모리 할당 및 사용 구조
![[Pasted image 20230807164319.png]]

## 글로벌 메모리 영역
**데이터베이스 시스템 전체에서 공유되는 메모리 영역**으로, 모든 클라이언트 및 스레드가 접근할 수 있는 공통 자원입니다. 

- **데이터 및 인덱스 캐시**: InnoDB 버퍼 풀, MyISAM 키 캐시 등과 같은 데이터와 인덱스 페이지를 캐싱하는 메모리 영역입니다.
- **시스템 변수**: 데이터베이스 전반에 걸친 전역 설정 값들을 저장하는 메모리 영역입니다.


## 로컬 메모리 영역
**각 스레드 또는 클라이언트에게 특정된 메모리 영역**으로, 스레드가 생성되거나 클라이언트가 **연결될 때 할당**되고 사용됩니다. 

- 조인 버퍼: 조인 작업을 수행하는 데 사용되는 메모리 영역입니다.
- 정렬 버퍼: ORDER BY 및 GROUP BY 절을 처리하는 데 사용되는 메모리 영역입니다.
- 읽기 버퍼: 순차적으로 테이블을 스캔하는 작업에 사용되는 메모리입니다.


# 4.플러그인 스토리지 엔진 모델
![[Pasted image 20230807170855.png]]
- MySQL 은 플러그인 형태로 다양한 스토리지 엔진을 제공한다.
- 스토리지 엔진 뿐만 아니라, 인증이나 파서(parser) 등도 플러그인 형태로 제공되고, 직접 개발해서 사용할 수 있다.


# 5.컴포넌트
기존 플러그인 모델의 단점을 대체하기 위해 등장함

▶플러그인 모델의 단점
- 플러그인은 MySQL 서버와 인터페이스할 수 있고, **플러그인끼리는 통신할 수 없다.**
- MySQL 서버의 변수나 함수를 **직접 호출하기 때문에 안전하지 않다.**
- **상호 의존관계를 설정할 수 없어서 초기화가 어렵다.**


# 6.쿼리 실행 구조 ✔
![[Pasted image 20230807170903.png]]
![[Pasted image 20230807194333.png]]

## 1) 쿼리 파서 
쿼리 파서(Query Parser)의 주요 역할은 클라이언트로부터 받은 **SQL 문장을 구문 분석하고 각 구성 요소를 인식**하는 것입니다. 파서는 **문장을 토큰화하고, 문법적인 정확성을 검사**하며 문장을 **트리 구조로 생성**합니다.
![[Pasted image 20230811230726.png]]

## 2) 전처리기 
전처리기(Preprocessor)는 파서로부터 **생성된 문장 구조를 검사하고 각 항목에 대한 추가 처리를 진행**합니다. 이 과정에서 테이블과 열의 **이름이 올바른지 확인**하고, 사용자가 **필요한 권한을 보유**하고 있는지 확인하며, 명시되지 않은 기본값을 적용하는 등의 작업이 진행됩니다.

## 3) 옵티마이저 
옵티마이저(Optimizer)는 서로 다른 실행 전략들 중에서 **가장 효율적인 실행 계획을 선택**하는 데 필요한 결정을 내립니다. 이 규칙에는 두가지 전략이 있는데
- 규칙 기반 최적화 : 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
- 비용 기반 최적화 : 작업의 비용과 대상 테이블 통계 정보를 활용해서 실행 계획 수립

## 4) 쿼리 실행 엔진
실행 엔진(Execution Engine)은 옵티마이저로부터 선택된 실행 계획을 바탕으로 **쿼리를 처리하고 최적화하는 역할을 담당**합니다.

## 5) 핸들러(=스토리지 엔진)
쿼리 실행 엔진이 **요청하는대로 데이터를 디스크로 저장**하고 읽습니다. 핸들러 API에 의해 동작합니다.


# 7.쿼리 캐시
- MySQL 8.0 으로 올라오면서 쿼리 캐시는 완전히 제거됐다!
- 쿼리 요청 결과를 캐싱하는 모듈입니다. 하지만 캐싱하고 있는 데이블이 변경 된다면, 캐싱 데이터를 삭제해야 됩니다. 캐싱 데이터 삭제를 위해 캐시에 접근하는 스레드에 락이 걸려 심각한 **동시 처리 성능 저하 유발 및 버그 발생 등의 문제.**


# 8.스레드 풀
## 스레드 풀이란?
스레드 풀이란 **일정량을 스레드를 미리 생성해놓고, 스레드가 필요할때 미리 생성된 스레드를 제공하는 방식**입니다.  이러한 방식을 사용하는 이유는 요청마다 스레드를 생성하는 경우 오버헤드가 많이 발생하기 때문에 이를 줄이기 위함입니다.

▶ 발생하는 오버헤드
- 스레드 생성, 제거 비용
- 컨텍스트 스위칭
- 스레드 스케줄링 비용


## MySql의 스레드풀의 목적은?
스레드 풀은 내부적으로 사용자의 **요청을 처리하는 스레드 개수를 줄여 CPU의 컨텍스트 스위치와 자원의 소모를 줄이는 것이 목적**이다.
MySQL **Server Enterprise 에서는 스레드 풀을 제공**하지만, Community 에서는 제공하지 않습니다.


## 스레드 풀의 스레드를 늘려도 성능이 떨어지는 경우는?
1. **자원 경쟁과 병목현상**
스레드 개수가 증가하면 각 스레드가 시스템 자원(CPU, 메모리, 디스크 I/O)에 대한 접근 경쟁이 발생할 수 있습니다. 이로 인해 병목현상이 발생하거나 기존에 숨겨져 있던 성능 제한 요소가 두드러지게 됩니다.

2. **컨텍스트 스위칭 오버헤드**
스레드 개수가 증가하면, 운영 체제의 스케줄러가 실행 중인 스레드와 대기 중인 스레드 간에 더 자주 전환해야 합니다. 이로 인해 컨텍스트 스위칭(context switching) 오버헤드가 증가하며, 이는 성능 저하로 이어질 수 있습니다.
![[Pasted image 20230807202744.png]]

3. **캐시 지역성 감소**
스레드 개수가 너무 많을 경우, 각 스레드가 사용하는 데이터의 캐시 지역성(cache locality)이 감소할 수 있습니다. 즉, **각 스레드가 다른 스레드와 공유하는 데이터를 덜 참조함**으로써, **CPU 캐시 효율이 저하**되면서 성능에 악영향을 미칩니다.

4. **동기화 및 락 관련 오버헤드**
다중 스레드 환경에서는 스레드끼리 데이터를 공유하면서 **동기화 관련 오버헤드가 발생**할 수 있습니다. 락(lock)이나 뮤텍스(mutex) 등의 동기화 메커니즘이 올바르게 동작하지 않거나, 경합 조건(race condition)이 발생할 경우 성능 저하의 원인이 될 수 있습니다.


# 9.트랜젝션 지원 메타데이터
## 기존 버전의 문제점은?
데이터 딕셔너리(메타데이터): 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 **파일 기반으로 관리**했었다. 파일 기반의 메타데이터는 **트랜잭션을 지원하지 않기 때문에** 테이블을 생성 또는 변경 중에 서버가 비정상 종료되면 테이블 깨지는 현상이 있었다.

## 해결책은?
데이터 딕셔너리를 모두 **트랙잭션이 사용가능한 `InnoDB`의 테이블에 저장**하도록해 개선됐다.  시스템 테이블(MySQL 서버가 동작하기 위해 필요한 테이블들 ex. 인증 및 권한)과 데이터 딕셔너리를 mysql DB에 저장한다. mysql DB는 통째로 `mysql.ibd`라는 이름의 테이블스페이스에 저장된다.