[index가 뭔지 설명해보세요 (개발면접시간) - YouTube](https://www.youtube.com/watch?v=iNvYsGKelYs)
[인덱스 스캔 방식 종류 및 특징 : 네이버 블로그 (naver.com)](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=gglee0127&logNo=221336088285)
[Real MySQL 2 (velog.io)](https://velog.io/@alswn9938/Real-MySQL-2#4-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9D%BD%EA%B8%B0)

#인덱스탐색

참고 : #RealMyqs04인덱스 (page.231)

---

## 인덱스를 사용하지 않을때는?
특정 조건에 맞는 데이터를 찾기 위해 테이블의 **모든 행을 처음부터 끝까지 검색**하는 방법을 말합니다. (Full Table Scan)
예를들어, id 순서대로 해당 address가 "서울"이 맞는지 일일히 확인함. 
![[Pasted image 20231103012209.png]]


## Full Table Scan의 단점은?✔
1. 테이블의 모든 데이터를 읽어야 하므로 **대용량 테이블의 경우** 매우 느릴 수 있습니다.
2. **디스크 I/O가 많이 발생**하므로 시스템의 부하를 증가시킬 수 있습니다.
3. 인덱스를 사용한 검색에 비해 **CPU 사용량**이 높을 수 있습니다.


## 자료구조가 찾는 방법
#### 클러스터형 인덱스 탐색방법은?
클러스터형 인덱스는 기본키로, 자동정렬
![[Pasted image 20230809144521.png]]

#### 보조 인덱스 찾는 방법탐색방법은?
보조 인덱스는 고유키로, 정렬 x 그래서 +#번호로 위치 나타내고 있음
![[Pasted image 20230809144548.png]]


#### 클러스터형 인덱스와 비클러스터형 인덱스의 혼합
![[Pasted image 20231107172458.png]]
- 순서는 **비클러스터형 인덱스 -> 클러스터형 인덱스**
- 비클러스터형 인덱스는 `데이터 페이지 번호 + #오프셋` 대신 **클러스터형 인덱스에 대한 컬럼 값**을 갖는다.


# B-Tree 인덱스를 통한 데이터 읽기 
## 인덱스 레인지 스캔✔
#### 인덱스 레인지 스캔란?
![[Pasted image 20231107220025.png]]
**검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식**이다. 뒤에 설명할 두 가지 인덱스 접근 방식보다는 빠른 방법이다.


#### 언제 인덱스 레인지 스캔 사용할까?
- 특정 범위의 값을 검색하는 경우 (예: 2020년 1월 1일부터 2020년 12월 31일까지의 주문 내역 조회)
- 정렬된 결과가 필요한 경우 (예: 성(last name)이 'A'로 시작하는 모든 직원 검색)
- 특정 조건을 만족하는 일부 데이터만 검색하는 경우 (예: 나이가 18세 이상이고 성별이 남성인 사람 조회)


#### 인덱스 레인지 동작 방식
인덱스 레인지 스캔은 크게 세 단계를 거친다.

1. 인덱스에서 **조건**을 만족하는 값이 저장된 **위치**를 찾는다.(인덱스 탐색)
2. 1번에서 탐색된 위치부터 **필요한 만큼 인덱스를 차례로 쭉 읽는다**. (인덱스 스캔)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.


예시)'Ebbe'와 'Gad'사이의 성을 모두 찾는 쿼리
```sql
SELECT * FROM employees WHERE first.name BETWEEN 'Ebbe' AND 'Gad';
```


1) 루트 노드에서부터 브랜치 노드를 거쳐 최종적으로 리프 노드까지 찾아 들어가 필요한 **레코드의 시작점을 찾는다.** (두꺼운 화살표는 실제 스캔하는 범위)

![](https://blog.kakaocdn.net/dn/bp7EAi/btrFWxLDCnu/7imDUfCY73wnqQRXCa8fak/img.png)

2) **시작 지점을 찾으면 그때부터는 리프 노드의 레코드만 차례대로 쭉 읽으면 된다.** 만약 리프 노드의 끝까지 읽으면 리프 노드 간 링크를 이용해 다음 리프 노드를 찾아 다시 스캔을 시작한다.

3) 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어와야 한다. 리프 노드에서 **검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는데** 이때 **한 건당 랜덤 I/O**가 발생한다.  
![](https://blog.kakaocdn.net/dn/cAsR53/btrFZ0lhKvm/gYGov3jMYl4Awzut09aOo0/img.png)



## 인덱스 풀 스캔✔
#### 인덱스 풀 스캔란?
**인덱스의 처음부터 끝까지 모두 읽는 방식**을 말한다. 대표적으로 쿼리 조건절에 사용된 컬럼이 **인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용**된다.

인덱스 풀 스캔은 **테이블 전체를 읽는 것보다 적은 디스크 I/O가 발생**하지만 인덱스를 사용하는 측면에서는 효율적인 방식은 아니다.


#### 인덱스 풀 스캔 언제 사용할까?
1. 테이블의 대부분 또는 전체 레코드를 검색해야하는 경우.
2. 순서가 중요한 결과를 반환해야 하는 경우.


#### Index Full Scan vs Table Full Scan 차이는?
▶ Full Table Scan
**테이블의 모든 행**을 처음부터 끝까지 순서대로 읽는 방법입니다. 테이블의 모든 데이터 블록을 직접 읽어야 하므로 데이터베이스에서 가장 비용이 크고 시간이 많이 소요되는 검색 방식입니다. **WHERE 절이 없거나 인덱스를 사용할 수 없는 쿼리**에서 사용되기도 합니다.

▶ Index Full Scan
**인덱스의 모든 항목을 순서대로** 읽는 방법입니다. 인덱스는 일종의 참조 테이블로, 특정 컬럼의 값과 해당 값이 위치한 행의 주소를 가지고 있습니다. 주로 **ORDER BY 절이 인덱스와 동일한 순서일 때 사용**합니다.


#### 인덱스 풀 스캔 동작방식
예시) 조건절에 처음 사용된 컬럼이 인덱스의 첫 번째(A) 컬럼이 아니므로 인덱스 풀 스캔이 일어난다.
``` sql
// (A, B, C)라는 인덱스가 있다고 가정
SELECT * FROM employees WHERE B = 'b' AND C = 'c' ORDER BY A;
```

1) 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한다.
2) 해당 위치에서 리프 노드를 연결하는 링크드 리스트를 따라 처음부터 끝까지 스캔한다.
![[Pasted image 20230810135604.png]]


## 루스 인덱스 스캔
**일부 조건에 맞는 행을 더 효율적으로 검색**하기 위해 인덱스의 일부만 스캔하는 것을 목표로 합니다. 인덱스 레인지 스캔과 비슷하게 작동하지만 **중간에 필요하지 않은 인덱스 키 값은 무시하고 넘어가는 형태로 처리**된다.

다음과 같은 경우 유용합니다
1) GROUP BY 또는 MAX(), MIN() 함수를 포함한 쿼리: 일부 연속된 인덱스 키 값을 사용하여 그룹화를 수행할 때 Loose Index Scan이 효율적입니다.

2) 특정 조건에 맞는 행을 빠르게 찾는 경우: 인덱스 키 값이나 레인지를 이용하여 특정 사례에서 더 효율적인 검색을 수행할 수 있습니다.


## 인덱스 스킵 스캔
**복합 인덱스를 사용하여 최적화된 인덱스 스캔 방식** 중 하나입니다. 이 방식은 일반적으로 첫 번째 인덱스 컬럼에 대한 조건이 없는 경우에 사용됩니다. 인덱스 스킵 스캔을 활용하면 기존 복합 인덱스의 두 번째 이후 컬럼에 대한 검색이 가능해집니다.


예시) 조건절에 사용된 컬럼이 인덱스의 첫 번째(A) 컬럼이 아닌경우
```sql
// (A, B, C)라는 인덱스가 있다고 가정
SELECT * FROM employees WHERE B = 'b' AND C = 'c';
```
하지만 MySQL 8.0 버전에 **인덱스 스킵 스캔 최적화 기능이 도입되면서** 옵티마이저가 A 컬럼을 건너뛰어서 **B, C 컬럼만으로도 인덱스 검색이 가능**하게 되었다.

GROUP BY의 인덱스 처리에만 사용할 수 있었던 루스 인덱스 스캔과는 다르게 인덱스 스킵 스캔은 WHERE 조건절의 검색에 사용 가능해져, 그 용도가 훨씬 넓어졌다.

