[index가 뭔지 설명해보세요 (개발면접시간) - YouTube](https://www.youtube.com/watch?v=iNvYsGKelYs)
[[10분 테코톡] 👨‍🏫안돌의 INDEX - YouTube](https://www.youtube.com/watch?v=NkZ6r6z2pBg)
[[10분 테코톡] 라라, 제로의 데이터베이스 인덱스 - YouTube](https://www.youtube.com/watch?v=edpYzFgHbqs)
[[MySQL] B-tree, B+tree란? (인덱스와 연관지어서)](https://zorba91.tistory.com/293)
[[MySQL] 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/285)

#인덱스자료구조, #B트리, #InnoDB , #B트리인덱스성능

참고 : #혼자공부하는SQL02인덱스 (page. 274), #RealMyqs04인덱스 (page.231)

----

## 사용하는 DB
**MySQL의 InnoDB 스토리지 엔진을 사용**한다고 가정함. 사용가능한 인덱스 구조는 B+트리 인덱스, FULLTEXT 인덱스, 공간 인덱스가 있음.


# 트리 사전지식
## 왜 트리를 사용해야 할까?✔
![[Pasted image 20231106160419.png]]

![[Pasted image 20231106161417.png]]

1. 검색속도
트리 구조에서는 **로그 시간 복잡도**를 가지는 검색이 가능합니다. 반면 배열이나 링크드 리스트는 선형 시간 복잡도를 가지므로, 데이터가 많아질수록 검색 시간이 증가합니다.

2. 삽입과 삭제
트리 구조에서는 **삽입과 삭제도 로그 시간 복잡도**로 가능합니다. 반면 배열에서는 삽입과 삭제 시 모든 요소를 재배치해야 하므로, 작업량이 많아집니다.

3. 정렬
트리 구조는 자연스럽게 데이터를 **정렬 상태로 유지**합니다.


## 이진트리
![[Pasted image 20231106160538.png]]
각 노드가 **최대 두 개의 자식 노드를 가질 수 있는 트리 형태의 자료구조**입니다. 
왼쪽 자식 노드의 값이 부모 노드의 값보다 작고, 오른쪽 자식 노드의 값이 부모 노드의 값보다 큰 특성을 가지고 있습니다. 이러한 특성 덕분에 이진 탐색 트리에서는 원하는 값을 찾기 위한 탐색 시간을 크게 줄일 수 있습니다.


## 이진트리의 단점은?✔
![[Pasted image 20231106170443.png]]
이진 탐색 트리는 데이터를 삽입하거나 삭제하는 과정에서 **트리의 균형이 깨질 수 있습니다.** 트리의 균형이 깨지게 되면 본래 로그 시간 복잡도를 가질 수 있는 탐색, 삽입, 삭제 등의 연산이 선형 시간 복잡도를 가지게 되어 성능이 급격히 저하될 수 있습니다.


## B트리✔
![[Pasted image 20231106160521.png]]
**Balanced-Tree**의 약자로, **자식 노드를 가질 수 있는 수가 2개 이상**인 트리 형태의 자료구조입니다. 이진 트리(Binary Tree)를 일반화하여 더 많은 자식 노드를 가질 수 있도록 확장한 형태라고 볼 수 있습니다.

B-트리의 중요한 특징 중 하나는 **트리의 높이를 최소화하는 방향**으로 구성된다는 점입니다. 이는 각 노드가 가질 수 있는 자식 노드의 수가 많기 때문에 가능하며, 이로 인해 탐색, 삽입, 삭제 **연산의 시간 복잡도를 로그 시간으로 유지**할 수 있습니다.


## B 트리의 단점은?
리프 **노드들이 서로 연결되어 있지 않습**니다. 그래서 범위 탐색할 때, 여러 번 B트리를 탐색해야함


## B트리와 B+트리 차이점은?✔
![[Pasted image 20231107164624.png]]

## 페이지 분할 동작방식은? -> 이해만
#### 초기상태
![[Pasted image 20230809144404.png]]

####  2번째 리프에 인덱스를 추가한다면?
![[Pasted image 20230809144426.png]]

#### 루트 페이지가 꽉차면?  
![[Pasted image 20230809144506.png]]



## B+트리✔
- B+트리 예시
![[Pasted image 20231106160619.png]]

- DB에서 사용되는 B+트리 모습
![[Pasted image 20230809170338.png]]

**모든 데이터를 리프 노드에 저장**하며, **리프 노드 간에는 포인터로 연결**되어 있습니다. 이 구조 덕분에 범위 검색이나 순차 검색이 빠르게 수행될 수 있습니다.


# MySQL에서 B+트리
## InnoDb의 B+Tree✔
클러스터형 인덱스와 비클러스터형 인덱스의 **혼합된 트리구조**를 사용합니다. ([[1.인덱스 개념]]) 그래서, 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야함.
![[Pasted image 20230809170400.png]]


## 인덱스 키 추가
상대적으로 **쓰기 작업(새로운 키 추가)** 에 비용이 많이 든다고 할 수 있습니다.(위의 페이지 분할 동작방식 참고) 테이블의 칼럼수, 칼럼의 크기, 인덱스 칼럼의 특성에 따라 시간이  달라집니다.

1. 새로운 키 값이 B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색
2. 저장될 위치가 결정되면 레코드의 키 값과 레코드의 주소 정보를 B-Tree 리프 노드에 저장
    1) 만약 리프 노드가 꽉 차서 더는 저장할 수 없는 경우 리프 노드를 분리
    2) 리프 노드가 분리되는 경우 상위 브랜치 노드까지 처리해줘야 함(상대적으로 쓰기 작업의 비용이 상승)


## 인덱스 키 삭제
B-Tree의 키값이 삭제되는 경우는 상당히 간단합니다. 해당 키값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료됩니다. 이렇게 **삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용**할 수 있습니다. 

인덱스 키 **삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요**하므로 이 작업 역시 디스크 I/O가 필요한 작업입니다.


## 인덱스 키 변경
키값이 변경되는 경우 인덱스상의 키값만 변경하는 것은 불가능합니다. 
변경을 원할 시 **기존 키 값 삭제 + 새로운 키 값을 추가**하게 된다.


## 인덱스 키 검색✔
**`SELECT`뿐 아니라 `UPDATE`나 `DELETE`를 처리하기 위해** 레코드를 먼저 검색할 때도 사용된다. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭 락)이 검색을 수행한 **인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현**돼 있다.


▶인덱스를 이용한 키 검색이 가능한 경우
- **100% 일치**(동등 연산, = ‘test') 또는 **값의 앞부분만 일치**하는 경우(LIKE 연산, “test%”) **사용 가능**
- 부등호 (< , >) 비교 조건에서 사용 가능


▶인덱스를 이용한 키 검색이 불가능한 경우
- **키 값의 뒷부분만 검색**하는 경우(LIKE 연산, “%test”) **사용 불가능**
- **키 값에 변형**이 가해지는 경우 **사용 불가능** (`where 2*price = 10000`)
```SQL
--인덱스 가능한 SQL
SELECT mem_name, mem_number
FROM member
WHERE mem_number >= 7;

--인덱스 불가능한 SQL
SELECT mem_name, mem_number
FROM member
WHERE mem_number*2 >= 14;
```


# B-Tree 인덱스 성능✔
## 페이지란?
**디스크에서 데이터를 읽고 쓰는 가장 작은 단위**로 블록(Block)이라고도 함. 
페이지의 크기는 일반적으로 4KB, 8KB, 16KB 등으로 고정되어 있습니다. 

페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여, 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 상당히 중요하다. 
- 디스크 I/O가 많아질 수 있음
- 메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음


## 인덱스 키 값의 크기
![[Pasted image 20230809214537.png]]
**페이지 크기는 고정**되어 있는데, 인덱스 크기가 커지면 커질수록 **메모리에 캐시 해 둘 수 있는 레코드 수는 줄어들기 때문에** 자연히 메모리 효율이 떨어지는 결과를 가져온다.

예를 들어, 500개의 레코드를 읽을 때 키 값이 16바이트인 인덱스 페이지는 디스크를 한 번만 읽으면 되지만, 키 값이 32바이트인 인덱스 페이지는 디스크를 두 번 읽어야 한다. 즉, **키 값이 커지면 디스크를 읽어야 하는 횟수가 늘어나고 그만큼 느려진다.**


## 선택도(카디널리티)
**모든 인덱스 키 값 가운데 유니크한 값의 수를 의미**한다. 인덱스 키 값 가운데 **중복된 값이 많아지면 기수성은 낮아진다.** 

카디널리티를 따져야 하는 상황을 생각해보자. 이름과 이메일 둘중 하나를 이용해서, 개인 해당 레코드를 찾으려고해. 둘중 어떤 걸 인덱스로 사용해야할까?
![[Pasted image 20231107212808.png]]

이때, 인덱스를 선택하는 기준이 카디널리티다. 이름을 선택하면, 중복되는 경우가 있어 추가적인 행동이 필요하다. 하지만 이메일을 이용하면 한번에 데이터를 빠르고 효율적으로 검색할 수 있다.


## 읽어야 하는 레코드의 수
인덱스를 통해 테이블 레코드를 읽는 것은 인덱스를 거치지 않고 읽는 것보다 높은 비용이 드는 작업이다. 따라서 인덱스를 통해 레코드를 읽어오는 방법과 인덱스를 거치지 않고 읽어오는 방법 중 어느 것이 **효율적인지 판단해야 한다.**

일반적으로 읽어야 할 **레코드 수가 전체 테이블 레코드의 20~25%를 넘어서면 테이블을 모두 직접 읽어서 필터링을 수행하는 것이 더 효율적**이다.


