#DB테스트, #임베디드모드

#인프런스프링DB2편03

----
page.59
#### (코드) 데이터베이스에 접속 설정방법은?
- main - application.properties
```
spring.profiles.active=local 
spring.datasource.url=jdbc:h2:tcp://localhost/~/test 
spring.datasource.username=sa

logging.level.org.springframework.jdbc=debug
```
- test - application.properties
=> 테스트 케이스에서도 데이터베이스에 접속할 수 있게 설정함.
```
spring.profiles.active=test
```


#### @SpringBootTest란?
```java
@SpringBootTest 
class ItemRepositoryTest {}
```
=> @SpringBootTest 는 **@SpringBootApplication 를 찾아서 설정으로 사용**한다.

```java
@Import(JdbcTemplateV3Config.class)
@SpringBootApplication
public class ItemServiceApplication {}
```
=> 테스트도 JdbcTemplate 을 통해 실제 데이터베이스를 호출하게 된다.


#### ✔테스트 케이스 주의점은?
1) 데이터베이스 **서버가 실행**되어 있어야 한다.
2) 테스트 케이스를 실행하면 실제 DB에 저장됌. 그래서 과거에 서버를 실행하면서 **저장했던 데이터가 보관**되어 있기 때문에 이 데이터가 현재 테스트에 영향을 줄 수 있음.


####  (코드) 테스트 데이터베이스 분리하는 설정은?
1) 데이터베이스 파일 생성
- 데이터베이스 서버를 종료하고 다시 실행한다. 
- 사용자명은 sa 입력 JDBC URL에 다음 입력, jdbc:h2:~/testcase (최초 한번) 
- ~/testcase.mv.db 파일 생성 확인 
- 이후부터는 jdbc:h2:tcp://localhost/~/testcase 이렇게 접속

2) 테이블 생성하기
```sql
drop table if exists item CASCADE; 
create table item (
id bigint generated by default as identity,
item_name varchar(10), 
price integer,
quantity integer,
primary key (id)
);
```

3) 접속 정보 변경
url을 ~/test에서 ~/testcase로 변경함.
```
spring.profiles.active=test 
spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase 
spring.datasource.username=sa
```


## ✔테스트 데이터 롤백하는 방법은?
테스트가 끝나고 나서 트랜잭션을 강제로 롤백해버리면 데이터가 깔끔하게 제거된다

#### @BeforeEach , @AfterEach
=> 테스트는 각각의 테스트 실행 전 후로 동작하는 @BeforeEach , @AfterEach 라는 편리한 기능을 제공

```java
@BeforeEach    
void beforeEach() {        
	//트랜잭션 시작  
	status = transactionManager.getTransaction(new DefaultTransactionDefinition());    
}

@AfterEach  
void afterEach() {  
	//MemoryItemRepository 의 경우 제한적으로 사용  
	if (itemRepository instanceof MemoryItemRepository) {  
		((MemoryItemRepository) itemRepository).clearStore();  
	}  
	//트랜잭션 롤백  
	transactionManager.rollback(status);  
}
```

#### @Transactional
```java
@Transactional 
@SpringBootTest 
class ItemRepositoryTest {}
```

![[Pasted image 20230102104629.png]]
-   1. @ Transactional 애노테이션이 테스트 메서드나 클래스에 있으면 **먼저 트랜잭션을 시작함.**  
-   2. 테스트를 로직을 실행한다. 테스트가 끝날 때 까지 **모든 로직은 트랜잭션 안에서 수행**  
-   3. @ Transactional 이 테스트에 있으면 **테스트가 끝날때 트랜잭션을 강제로 롤백**


## 임베디드 모드
#### Embedded Mode VS In-Memory Mode란?
공통점
- DB를 띄우지 않아도 **손쉽게 데이터베이스를 사용**할 수 있기에 테스트 용도로 자주 사용된다.
- 애플리케이션이 종료되면 DB가 종료되고, 데이터도 모두 사라짐.

차이점
- Embedded Mode : H2 DB 데이터를 **로컬에 직접 저장하고 사용**한다.
- In-Memory Mode : H2 DB 데이터를 **로컬에 저장하지 않고 메모리에만 가지고 있다.**


#### (코드) 임베디드 모드 사용방법은?
- 임베디드 모드 사용설정(이해만)
=>별다른 정보가 없으면 스프링 부트는 임베디드 모드로 접근하는 데이터소스( DataSource )를 만들어서 제공함. 로그를 보면 다음 부분을 확인할 수 있는데 jdbc:h2:mem 뒤에 임의의 데이터베이스 이름이 들어가 있다. 
```java
public class ItemServiceApplication {  
	...

   @Bean  
   @Profile("test")  
   public DataSource dataSource() {  
      log.info("메모리 데이터베이스 초기화");  
      DriverManagerDataSource dataSource = new DriverManagerDataSource();  
      dataSource.setDriverClassName("org.h2.Driver");  
      dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");  
      dataSource.setUsername("sa");  
      dataSource.setPassword("");  
      return dataSource;  
   }  
}
```

```
spring.profiles.active=test  
spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase  
spring.datasource.username=sa
```


- 테이블 생성
test/resources에 생성
```sql
drop table if exists item CASCADE; 
create table item (
id bigint generated by default as identity,
item_name varchar(10), 
price integer,
quantity integer, 
primary key (id)
);
```