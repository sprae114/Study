[[10분 테코톡] 마루의 데이터베이스 Lock - YouTube](https://www.youtube.com/watch?v=ZXV6ZqMyJLg)
[[10분 테코톡] ⛲️ 오즈의 데이터베이스 Lock - YouTube](https://www.youtube.com/watch?v=onBpJRDSZGA)
[(27) [10분 테코톡] 🍧카일의 데이터베이스 락 - YouTube](https://www.youtube.com/watch?v=w6sFR3ZM64c&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=281)

[5. 트랜잭션과 잠금 (tistory.com)](https://jwkim96.tistory.com/264)

#RealMyqs03

---

# 트랜잭션
page.172
## 트랜잭션이란? ✔
[[1. 트랜잭션]]

트랜잭션(Transaction)은 데이터베이스에**서 하나 이상의 데이터 조작 명령어를 묶어 실행하는 논리적인 작업 단위**입니다. 트랜잭션은 데이터 **일관성과 무결성을 유지하는 데 중요한 역할**을 하며, ACID 속성(원자성, 일관성, 고립성, 지속성)을 만족해야 합니다.


## ACID 속성이란? ✔
- 원자성(Atomicity)
트랜잭션 내에서 실행한 작업들은 마치 **하나의 작업인 것처럼** 모두 성공 하거나 모두 실패해야한다.  

- 일관성(Consistency)
모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 **무결성 제약 조건**을 항상 만족해야 한다.  

- 격리성(Isolation)
동시에 실행되는 트랜잭션들이 **서로에게 영향을 미치지 않도록 격리**한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준 (Isolation level)을 선택할 수 있다.  

- 지속성(Durability)
트랜잭션을 성공적으로 끝내면 **그 결과가 항상 기록**되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.


## (코드) 트랜잭션 커밋, 롤백
▶ 트랜잭션 커밋 예시
```sql
START TRANSACTION; -- 트랜잭션 시작

-- 작업 수행
INSERT INTO example_table (key, value) VALUES (1, 'A');
UPDATE example_table SET value = 'B' WHERE key = 2;

COMMIT; -- 트랜잭션 완료 및 변경 사항 저장
```

▶ 트랜잭션 롤백 예시
```sql
START TRANSACTION; -- 트랜잭션 시작

-- 작업 수행
INSERT INTO example_table (key, value) VALUES (1, 'A');
UPDATE example_table SET value = 'B' WHERE key = 2;

-- 오류가 발생한 경우, 롤백 실행
ROLLBACK; -- 트랜잭션 취소 및 변경 사항 되돌리기
```


## MyIsam과 InnoDb의 차이 ✔
```sql
-- 두 테이블의 c1 은 PRIMARY KEY 임
> INSERT INTO tbl_myisam ( c1 ) VALUES (3);
> INSERT INTO tbl_innodb ( c1 ) VALUES (3);

> SET autocommit=ON;

> INSERT INTO tbl_myisam ( c1 ) VALUES (1),(2),(3);
> INSERT INTO tbl_innodb ( c1 ) VALUES (1),(2),(3);
```

두 쿼리의 실행결과는 아래와 같습니다.
```sql
> INSERT INTO tbl_myisam ( c1 ) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'  // 오류발생!!

> INSERT INTO tbl_innodb ( c1 ) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'  // 오류발생!!

> SELECT c1 FROM tbl_myisam;
+----+
| c1 |
+----+
|   1|
|   2|
|   3|
+----+


> SELECT c1 FROM tbl_myisam;
+----+
| c1 |
+----+
|   3|
+----+
```
오류가 발생했지만,  **MyISAM 엔진은 트랜잭션을 지원하지 않기** 때문에 `tbl_myisam` 은 일부만 반영되고, `tbl_innodb` 는 아예 반영되지 않았습니다.

실제로 이런 문제가 발생하면, **데이터 정합성을 맞추기가 매우 어렵다**고 합니다.


## 트랜잭션 주의사항
트랜잭션은 **최소한의 코드에만 적용**하는것이 좋습니다.  
여러 작업이 있을 때, 불필요한 작업까지 트랜잭션의 범위에 넣을 필요가 없다는 의미입니다.

▶잘못된 트랜잭션 예시
```text
1. 처리 시작
    => DB Connection START
    => Transaction START
2. 사용자의 로그인 여부 확인
3. 게시글 내용 오류 여부 확인
4. 첨부파일 확인 및 저장
5. 사용자의 게시글 내용을 DB 에 저장
6. 첨부파일을 DB 에 저장
7. 저장된 내용 또는 기타 정보를 DBMS 에서 조회
8. 게시글 등록 알림 메일 발송
9. 알림 메일 발송 이력을 DB 에 저장
    <= Transaction COMMIT
    <= DB Connection END
10 처리 완료
```

위와 같은 작업 흐름을 보면, 너무 많은 작업들이 엮여 있습니다. 이런 트랜잭션의 범위가 넓은 구조는 다음과 같은 단점들이 있습니다.

1) DB Connection 을 소유하는 시간이 길다는 점
- 실제 DB 작업은 5번 부터인데, 1번 부터 갖고있음
- Connection 의 개수는 제한적이기 때문에, 필요할때 받아서 사용하는것이 좋음

2) DB 가 아닌 다른 외부 서버와의 통신이 트랜잭션 내부에 있음
- 메일 발송 때문에, 트랜잭션 내의 전체 작업이 취소될 수 있음

3) `5,6` 은 하나의 트랜잭션이어야 하지만, `7` 은 그럴 필요가 없음
- 적당히 작은 단위로 트랜잭션을 나누는게 좋음

위와 같은 단점들을 해결하기 위해서는 아래 처럼 개선해야 합니다.
```text
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 게시글 내용 오류 여부 확인
4. 첨부파일 확인 및 저장
    => DB Connection START
    => Transaction START
5. 사용자의 게시글 내용을 DB 에 저장
6. 첨부파일을 DB 에 저장
    => Transaction COMMIT
7. 저장된 내용 또는 기타 정보를 DBMS 에서 조회
8. 게시글 등록 알림 메일 발송
    => Transaction START
9. 알림 메일 발송 이력을 DB 에 저장
    => Transaction COMMIT
    => DB Connection END
10 처리 완료
```


## 트랜잭션 일어나는 과정
[(27) [10분 테코톡] 🌼 예지니어스의 트랜잭션 - YouTube](https://www.youtube.com/watch?v=e9PC0sroCzc)
![[Pasted image 20230815053705.png]]
1) 쿼리가 실행되고 쿼리가 처리되고 통과된다.
2) 일차적으로 구매자의 정보를 캐시에서 요청합니다. 해당되는 정보가 없는경우 데이터 파일에서 가져오고 데이터 캐시에 로드됩니다.
3) SQL의 업데이트를 하기 전에 변경전 값을 로그 캐시(언두 로그)에 저장합니다.
4) 변경 후 값을 리두 로그에 저장합니다.
![[Pasted image 20230815054038.png]]
5) ROLLBACK을 발생하면 언두 로그의 데이터들을 역순으로 접근하면 초기의 상태로 되돌릴 수 있습니다. 만약, ROLLBACK 없이 예상치 못한 오류가 일어나면 리두 로그를 통해 일관성 있게 만들어주고 이후 다시 UnDo를 통해 원상복구합니다.

# Lock
page.178## 배경지식
### Lock을 사용하는 이유는? ✔
데이터베이스에서 동시성을 관리하고, **여러 트랜잭션이 동시에 실행되어도 데이터의 일관성과 무결성을 보장**하기 위함입니다. 락은 특히 다중 사용자 환경에서 여러 트랜잭션 실행 시 데이터 접근 충돌을 방지하는데 중요한 역할을 합니다.


### Lock을 사용해야 되는 이유 예시 ✔
[[1. 트랜잭션]]
은행 계좌 이체를 처리하는 데이터베이스 시스템을 상상해보겠습니다. 이 시스템에서는 동시에 여러 이체 작업이 발생할 수 있기 때문에, **락을 사용하여 동시성을 관리하고 데이터 일관성을 유지**해야 합니다.

이 예시에서 계좌 A에서 계좌 B로 $100을 이체하는 과정은 다음과 같습니다:
1. 계좌 A의 잔액에서 $100 차감
2. 계좌 B의 잔액에 $100 추가

이 사례에서 락을 사용하지 않고 동시에 수행되는 두 개의 이체 작업이 그대로 진행되면 데이터 일관성이 올바르게 유지되지 않을 수 있습니다. 예를 들어, **두 트랜잭션이 동시에 계좌 A와 B의 잔액을 변경하려고 할 경우, 결과적인 잔액은 올바르지 않을 수 있습니다.**


이 문제를 해결하기 위해 락을 사용하여 다음과 같이 이체 작업을 수행할 수 있습니다:

1. 트랜잭션 시작
2. SELECT ... FOR UPDATE를 사용하여 계좌 A와 계좌 B에 **배타적 락 설정** (다른 트랜잭션에 의한 수정 및 배타적 락 요청 차단)
3. 계좌 A에서 $100 차감
4. 계좌 B에 $100 추가
5. 락 해제 및 트랜잭션 커밋

이처럼 배타적 **락을 사용하여 동시에 발생하는 이체 작업간의 도중에 다른 작업이 해당 자원에 접근하는 것을 방지하여 데이터 일관성을 유지하고, 충돌을 피할 수 있습니다.** 

# 용어 정리
#### 팬텀 현상이란?
데이터베이스에서 동시성 제어(concurrency control)와 관련된 문제로 발생하는 현상입니다. 특히, 여러 트랜잭션이 동시에 실행될 때 한 트랜잭션이 다른 트랜잭션에 의해 읽은 행 집합에 새로운 행을 삽입, 삭제 또는 수정함으로써 발생합니다. 이로 인해 **한 트랜잭션 내에서 같은 쿼리를 여러 번 실행하면 그 결과가 실행 시마다 달라질 수 있습니다.**


# MySQL 엔진의 잠금
## MySQL 에서 사용되는 잠금 종류는? ✔
1) MySQL 엔진 잠금 : 스토리지 엔진에 영향을 미침
2) 스토리지 엔진 잠금 : 스토리지 엔진간 상호 영향을 주지는 않음


## 글로벌 락
글로벌 락(Global Lock)은 MySQL **서버 전체에 영향을 주는 잠금**입니다. 

다음과 같은 경우에 사용합니다.
1. 데이터베이스 전체의 일관된 스냅샷 또는 백업을 생성할 때
글로벌 락은 데이터베이스의 현재 상태를 안전하게 백업할 수 있도록 모든 작업을 일시 중단시킵니다.

2. 데이터베이스 복사 또는 복원 시
데이터베이스 복제 작업 중에는 실시간 서비스에 영향을 미치지 않기 위해 작업을 일시 중단하는 것이 좋습니다. 글로벌 락은 이러한 작업을 안전하게 수행할 수 있도록 도움을 줍니다.

▶코드 예시
1. `FLUSH TABLES WITH READ LOCK (FTWRL)`
이 명령어는 글로벌 리드 락을 수립하여 **모든 테이블에 대한 쓰기 작업을 일시 중지**합니다. FTWRL이 활성화되는 동안 쓰기 작업이 차단되기 때문에 **성능 저하가 발생할 수** 있습니다.
```sql
FLUSH TABLES WITH READ LOCK;
-- ... 여기서 백업, 유지 관리 작업 등을 수행
UNLOCK TABLES; -- 락 해제 및 트랜잭션 재개
```

2. `LOCK INSTANCE FOR BACKUP`
이 명령어는 MySQL 8.0부터 도입된 백업 명령으로, FLUSH TABLES WITH READ LOCK의 단점을 해결하기 위해 사용됩니다. `LOCK INSTANCE FOR BACKUP`는 파일 및 테이블 스페이스에 대한 글로벌 백업 락을 걸어 백업 작업이 데이터와 저장소 파일 간의 불일치 문제없이 수행되도록 합니다. 이 명령어는 **InnoDB 스토리지 엔진에서만 정상 작동**하며, 데이터베이스 내의 트랜잭션 처리가 차단되지 않도록 해 **쓰기 작업이 계속 진행될 수** 있습니다.
```sql
LOCK INSTANCE FOR BACKUP;
```


## 테이블 락
데이터베이스 내의 특정 테이블에 대해 모든 액세스를 잠그거나 동시성을 제어하기 위해 사용합니다. **특정 테이블에 대한 접근을 동기화하기 위해 사용**됩니다. 테이블 락은 일반적인 애플리케이션에서는 **거의 사용할 필요가 없습니다.**

다음과 같은 경우에 사용합니다.
1. **대량의 데이터를 한 번에 수정하거나 삽입하는 경우**
대량의 데이터를 처리할 때 테이블 락을 사용하면 락 경쟁을 줄이고 트랜잭션 리소스를 절약할 수 있습니다. 예를 들어, 데이터베이스를 대규모로 갱신하거나 초기 데이터를 삽입할 때 테이블 락을 사용할 수 있습니다.

2. **테이블 구조 변경 작업 시**
테이블 구조를 변경하는 작업(예: ALTER TABLE, TRUNCATE TABLE) 중에는 다른 작업이 테이블에 동시에 액세스하지 못하도록 테이블 락을 사용할 수 있습니다.

```sql
-- 읽기 락 (다른 트랜잭션에서 테이블을 읽을 수 있지만 쓰기를 차단합니다.)
LOCK TABLES table_name READ;
-- ... 여기서 필요한 작업을 수행
UNLOCK TABLES; -- 락 해제

-- 쓰기 락 (다른 트랜잭션에서 테이블 읽기 및 쓰기를 모두 차단합니다.)
LOCK TABLES table_name WRITE;
-- ... 여기서 필요한 작업을 수행
UNLOCK TABLES; -- 락 해제
```


## 네임드 락
데이터베이스 테이블 또는 행이 아닌 **사용자가 정의한 고유한 문자열 기반의 락**입니다. **여러 클라이언트 간에 동기화를 제공하거나 서로 다른 세션에서 순차적으로 작업**을 수행하는 데 유용한 방법입니다.

다음과 같은 경우에 사용합니다.
1. 어플리케이션 레벨의 동시성 제어
데이터베이스와 관련이 없거나 데이터베이스 수준의 락으로 처리하기 어려운 어플리케이션의 동시성 문제를 처리하는 데 사용할 수 있습니다.

2. 여러 데이터베이스 간 동시성 제어
테이블 또는 행 레벨 락으로 처리할 수 없는 여러 데이터베이스 사이에서 발생하는 동시성 문제에 대응하기 위해 사용됩니다.

3. 다중 클라이언트 환경에서 공유된 자원에 대한 동시성 제어
여러 엔드 유저가 애플리케이션 및 데이터베이스를 사용하여 동시에 동일한 작업을 수행해야 하는 경우, 네임드 락을 사용하여 동시 접근을 조절할 수 있습니다.
sql

```sql
-- 네임드 락 설정 (lock_name이라는 락 이름을 사용)
SELECT GET_LOCK('lock_name', 10); -- 락을 얻으려고 시도하고, 최대 10초 동안 기다립니다.

-- ... 여기서 필요한 작업을 수행

-- 락 해제
SELECT RELEASE_LOCK('lock_name');
```

▶ 실생활 예시
온라인 상점에서 특정 제품의 한정판 물품을 판매한다고 가정해보겠습니다. 이 제품은 매우 인기가 있으며, 단 한 개의 품목만 판매가 됩니다. 이러한 경우 네임드 락을 사용하여 한 번에 한 명의 고객만 제품을 구매하도록 동시성을 관리할 수 있습니다.

```sql
-- 고객 A

-- 고객 A가 제품을 구매하려고 시도하면, 고객 A가 락 을 얻을 때까지 기다립니다.
SELECT GET_LOCK('limited_item_purchase', 10); -- 최대 10초 동안 기다립니다.

-- 고객 A가 지금까지 판매되지 않은 제품을 확인하고 구매합니다.
-- ... 여기서 물품 확인 및 구매 작업 수행

-- 구매가 완료되면 락을 해제합니다.
SELECT RELEASE_LOCK('limited_item_purchase');
```

이러한 방식으로 네임드 락을 사용하면 한 번에 한 명의 고객만 제품을 구매할 수 있으므로 동시성 문제를 해결할 수 있습니다. 하지만, 직접적으로 데이터베이스 자원에 락이 필요한 경우라면, **일반적으로 행 레벨 락이나 테이블 레벨 락을 사용하는 것이 더 효과적**입니다.


## 메타데이터 락
▶메타데이터란?
데이터베이스의 맥락에서 메타데이터는 **테이블, 칼럼, 인덱스, 제약 조건, 뷰** 등과 관련된 **구조, 속성, 제약 조건 등의 정보를 포함**합니다. 메타데이터는 데이터베이스의 기능과 효율성을 유지하고 **데이터베이스 구조와 엔터티 간의 관계를 제어**하는 데 중요한 역할을 합니다.

데이터베이스 시스템에서 스키마 객체(테이블, 뷰, 인덱스 등)의 메타데이터를 동시에 수정하거나 액세스하는 것을 제어하기 위해 사용됩니다. 

다음과 같은 상황에서 사용됩니다.
1. **테이블 구조 변경**
메타데이터 락은 테이블의 구조를 변경하려는 동안(예: ALTER TABLE, DROP TABLE, TRUNCATE TABLE) 모든 대기 중인 작업이 해당 테이블의 구조를 참조하는 것을 차단하는 데 사용됩니다. 테이블 구조 변경 작업이 완료되면 메타데이터 락이 해제되고 대기 중이던 작업들이 진행됩니다.

2. **트랜잭션 내부의 객체 접근**
메타데이터 락은 트랜잭션 범위 내에서 데이터베이스 객체에 대한 접근이 원활하게 이루어지도록 보장하는 데 기여합니다. 특정 트랜잭션에서 객체에 대한 메타데이터 락을 보유하고 있는 경우, 다른 트랜잭션이 해당 객체를 참조할 수 있도록 원활하게 처리됩니다.


## 메타 데이터 락 예시
[[MySQL] Metadata Lock (tistory.com)](https://ohtaeg.tistory.com/16)
메타데이터 락은 데이터베이스 시스템에서 **자동으로 관리**되므로 일반적으로 명시적으로 호출하지 않아도 됩니다. 

예를 들어, 고객 정보를 추적하는 데이터베이스에서 `customer` 테이블에 대해 **인덱스를 추가하고 싶다고 가정**해봅시다. 여러 사용자가 동시에 데이터베이스에 액세스할 수 있으므로, 인덱스가 추가되는 동안 다른 사용자가 **해당 테이블을 수정하거나 읽는 것을 차단**해야 합니다.

1. 사용자 A는 `ALTER TABLE` 명령을 사용하여 `customer` 테이블에서 새 인덱스를 생성합니다
```sql
ALTER TABLE customer ADD INDEX (last_name);
```

2. 사용자 B는 동시에 `customer` 테이블에서 정보를 검색하려고 합니다.
```sql
SELECT * FROM customer WHERE last_name = 'Smith';
```

`ALTER TABLE` 명령을 실행하는 동안 시스템은 자동으로 `customer` 테이블의 메타데이터에 락을 설정합니다. 이 락은 테이블 구조 변경 작업이 완료되기 전까지 다른 사용자가 해당 테이블에 대한 DDL 및 DML 작업을 수행하는 것을 차단합니다.


# InnoDB 스토리지 엔진 잠금
[[MySQL] 스토리지 엔진 수준의 락의 종류(레코드 락, 갭 락, 넥스트 키 락, 자동 증가 락) - MangKyu's Diary (tistory.com)](https://mangkyu.tistory.com/298)

## InnoDB 스토리지 엔진 잠금
**스토리지 엔진 내부에서 레코드 기반의 잠금 방식**을 탑재하고 있다. 이 덕분에 뛰어난 동시성 처리를 제공할 수 있다.
 
InnoDB 스토리지 엔진은 잠금 정보가 상당히 작은 공간으로 관리 되기 때문에 **락 에스컬레이션**이 발생하지 않는다.
![[Pasted image 20230808222241.png]]

▶락 에스컬레이션이란?
DBMS에서 사용되는 동시성 제어 기법 중 하나로, 레코드 또는 페이지(데이터 단위)에 발생한 여러 레벨의 잠금(lock)을 **더 상위 레벨의 잠금으로 변환하는 과정**입니다. 이 기법의 목표는 잠금의 수를 줄이고, 메모리 사용량을 줄여 성능을 개선하고, 경쟁 환경에서의 경합 문제를 완화하기 위함입니다.


### Record Locks(레코드 잠금) ✔
특정 행에 대한 작업을 수행하는 동안 **다른 트랜잭션이 해당 행에 동시에 액세하지 못하도록 차단**하는 잠금 방식입니다. InnoDB 는 레코드 자체를 잠그는 것이 아닌 **인덱스의 레코드를 잠근다는 것** 입니다. 행 기반 잠금(ROW 레벨)이라고도 하며, 데이터베이스 성능과 동시성을 개선하는 데 도움이 됩니다.

다음과 같은 경우에 사용합니다.
1. **데이터 수정 작업**
한 트랜잭션이 데이터를 수정할 때(예: UPDATE, DELETE, INSERT), 해당 행에 대한 Exclusive Lock(독점 잠금)이 걸립니다. 이 잠금은 해당 데이터를 동시에 변경하는 충돌을 방지하며, 해당 행에 다른 작업을 시도하는 트랜잭션은 대기하거나 다른 동작을 수행해야 합니다.

2. **데이터 읽기 작업**
트랜잭션 내에서 일관된 데이터를 읽기 위해 Shared Lock(공유 잠금)을 사용합니다. 해당 행의 데이터가 변경되는 것을 방지하며, 동시에 여러 트랜잭션이 같은 행을 읽을 수 있습니다.


### Record Locks의 종류는? ✔
#### 공유 락(Shared Lock, S-Lock)
- **읽기 작업시 사용**되며, **여러 트랜잭션에서 동시에 동일한 데이터를 읽을 수 있도록 허용**합니다.
- 하지만, 공유 락이 **활성화된 행에 대한 수정을 차단**합니다. 즉, 다른 트랜잭션이 해당 행을 수정하려고 하면 락이 해제될때까지 대기해야 합니다.

```sql
START TRANSACTION;
SELECT * FROM table_name WHERE id = 1 FOR SHARE; -- 공유 락 설정
-- ... 여기서 필요한 작업을 수행
COMMIT; -- 트랜잭션 커밋 및 락 해제
```

#### 베타락(Exclusive Lock, X-Lock)
- **쓰기 작업시 사용**되며, 한 트랜잭션에서 데이터를 **수정하는 동안 다른 트랜잭션이 동일한 데이터를 수정하거나 배타적 락을 요청할 수 없게** 합니다.
- 다른 트랜잭션이 해당 행에 공유 락을 설정하려고 한다면, 배타적 락이 해제될 때까지 기다려야 합니다.

```sql
START TRANSACTION;
SELECT * FROM table_name WHERE id = 1 FOR UPDATE; -- 배타적 락 설정
-- ... 여기서 필요한 작업을 수행
COMMIT; -- 트랜잭션 커밋 및 락 해제
```


### Gap Locks(갭 잠금)
레코드 사이의 간격을 잠근다는 개념으로, **특정 인덱스 값의 범위에 대한 잠금**입니다. 갭 잠금은 트랜잭션 과정에서 **추가, 삭제 및 수정 작업의 동시성과 일관성을 유지**하는 데 사용됩니다.

다음과 같은 경우에 사용합니다.
1. **범위 검색을 수행할 때**
데이터베이스에서 특정 범위의 인덱스 값에 대한 작업이 이루어질 때 Gap Locks가 사용됩니다. 예를 들어, 특정 날짜 범위의 데이터를 검색하거나 값을 기준으로 범위를 정렬할 때 사이의 갭을 잠그려 원치 않는 새로운 레코드 추가를 차단합니다.

2. **Repeatable Read 격리 수준에서의 트랜잭션**
격리 수준이 Repeatable Read로 설정된 경우 트랜잭션 내에서 데이터 일관성을 유지하기 위해 Gap Locks이 사용됩니다. 이 격리 수준에서 다른 트랜잭션이 쿼리 범위에 새로운 데이터를 입력하거나 삭제하는 것을 차단하여 팬텀 현상을 방지합니다.

3. **트랜잭션 내에서 순차적으로 삽입 작업을 수행할 때**
자동 증가(auto-increment) 값을 가진 키 또는 순차적 인덱스 값을 사용하는 경우, Gap Locks를 사용하여 동시에 삽입되는 값들 간의 충돌을 방지하고 순서를 유지할 수 있습니다.

예시) Gap Locks
`WHERE ... BETWEEN` 또 `WHERE ... >=`와 같은 범위 기반의 검색 쿼리를 사용하여 인접 간격을 잠급니다. 
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- Gap Locks 적용하기 위한 쿼리
SELECT * FROM employees WHERE salary >= 3000 AND salary <= 6000;

COMMIT;
```


### Next-Key Locks(다음 키 잠금) ✔
Next-Key Locks는 두 가지 종류의 잠금을 결합한 것으로, **레코드 잠금(Record Lock)과 갭 잠금(Gap Lock)을 모두 사용**합니다. 이 방식은 **레코드에 대한 변경 작업을 동기화하면서 해당 범위에 대한 동시 삽입이나 변경 작업을 차단하여 포괄적인 동시성 제어를 제공**합니다.
넥스트키와 갭락으로 인해 데드락이나 다른 트랜잭션을 기다리게 만드는 일을 자주 발생해 주의 필요함.

다음과 같은 경우에 사용합니다.
1. **범위 조회**
범위 검색이 필요한 쿼리에서는 Next-Key Locks가 사용됩니다. 범위 검색을 사용하면 지정된 기준에 따라 여러 레코드를 한 번에 검색합니다. 이 경우, 각 레코드에 대한 맞춤형 잠금과 인접한 간격(JPA의 갭 잠금과 유사)에 대한 잠금을 제공하여 동시성 제어를 구현합니다.

2. **트랜잭션 격리 수준 높은 경우**
Next-Key Locks은 트랜잭션 격리 수준이 `REPEATABLE READ` 또는 `SERIALIZABLE`인 경우 주로 사용됩니다. 이러한 격리 수준에서는 팬텀 현상을 방지하고 동시성 문제를 해결하기 위해 레코드 잠금 및 갭 잠금을 사용합니다. 다른 트랜잭션에서 동시에 인근 레코드에 액세스하거나 변경을 시도하려는 경우에도 Next-Key Locks가 적용됩니다.

3. **행 순서를 유지해야 하는 경우**
트랜잭션에서 데이터를 처리하는 동안 행 순서를 중요한 것으로 간주하고 유지해야 하는 상황에서도 Next-Key Locks를 사용할 수 있습니다. 예를 들어, 특정 ID 값에 대한 정렬 순서를 유지하거나 범위 검색을 실행하여 삽입된 새 레코드의 순서를 지켜야 하는 경우에 사용됩니다.

예시)
Next-Key Locks: 필요한 경우 `WHERE ... FOR UPDATE` 또는 `WHERE ... FOR SHARE` 절을 추가하여 범위 기반의 검색 쿼리와 레코드 락을 동시에 사용합니다.
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- Next-Key Locks를 적용하기 위한 쿼리
SELECT * FROM employees WHERE salary >= 3000 AND salary <= 6000 FOR UPDATE;

COMMIT;
```


### Auto-Increment Locks(자동 증가 잠금) ✔
**자동 증가 컬럼의 값을 부여하는 동안 해당 테이블에 적용되는 잠금**입니다. 여러 트랜잭션이 같은 시점에 새로운 레코드를 삽입하더라도 고유 ID 값이 유지되도록 도와줍니다. **자동으로 처리**되기 때문에 사용자가 코드에서 명시적으로 호출하지 않아도 됩니다.

예시)
```sql
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    salary REAL
);
```

새로운 직원 레코드를 추가하는 INSERT 문
```sql
INSERT INTO employees (first_name, last_name, salary) VALUES ('John', 'Doe', 5000);
```
이 예제에서 `id` 열은 `AUTO_INCREMENT` 속성이 지정되어 있으므로, 새 레코드가 추가될 때마다 고유한 값을 자동으로 할당합니다. 이렇게 하면 다른 트랜잭션들이 동시에 실행되어도 레코드에 중복되지 않은 고유한 값이 할당됩니다.


## 인덱스와 잠금 ✔
InnoDB의 잠금은 레코드를 잠그는 것이 아니라 **인덱스를 잠그는 방식**으로 처리한다. 즉, **변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.** 

예시) 입사 일자를 오늘로 변경하는 쿼리를 실행해보면?
``` sql
-- ix_firstname로 first_name 칼럼의 인덱스 준비되어 있음.

SELECT COUNT(*) FROM employees WHERE first_name='Georgi'; 
-- Georgi인 사원은 전체 253명

SELECT COUNT(*) FROM employees WHERE first_name='Georgi' AND last_name='Klassen';
-- first_name이 Georgi이고 last_name이 Klassen인 사원은 1명
```

``` sql
UPDATE employees SET hire_date=NOW()
        WHERE first_name='Georgi' AND last_name='klassen';
```

▶ UPDATE 쿼리가 실행되면 1건의 레코드가 수정될 것이다. 하지만 이 **1건의 업데이트를 위해서 몇 개의 레코드에 잠금이 걸릴까?**
[(27) [10분 테코톡] 🔫 우기의 MySQL 아키텍처 - YouTube](https://www.youtube.com/watch?v=vQFGBZemJLQ?t=495)

![[Pasted image 20230811150716.png]]
UPDATE 쿼리의 조건에서 인덱스를 이용할 수 있는 조건은 `first_name='Georgi'` 이며, **last_name 컬럼이 인덱스에 없기 때문에 `first_name='Georgi'` 인 레코드 253건에 모두 잠금이 걸린다.**
UPDATE 쿼리를 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어지므로 한 세션에서 UPDATE 작업을 하는 중에 다른 세션은 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생한다.


▶만약 이 테이블에서 인덱스가 하나도 없다면 어떻게 될까?

이러한 경우에는 테이블을 풀 스캔하면서 UPDATE 작업을 하는데, 이 과정에서 **테이블에 있는 30여 만 건의 모든 레코드를 잠그게 된다**. 이것이 MySQL의 InnoDB에서 인덱스 설계가 중요한 이유 중 하나이다.


## 레코드 수준의 잠금 확인 및 해제
레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다. 

MySQL 5.1부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나만 실행해 보면 확인 가능하다.


# MySQL의 격리 수준
[[MySQL] 트랜잭션의 격리 수준(Isolation Level)에 대해 쉽고 완벽하게 이해하기 - MangKyu's Diary (tistory.com)](https://mangkyu.tistory.com/299)
[(27) [10분 테코톡] 로건의 Transaction - YouTube](https://www.youtube.com/watch?v=taUeIi6a6hk)

## 트랜잭션 격리 수준이란?
동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.
![[Pasted image 20230811161544.png]]


## READ UNCOMMITTED
각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부와 상관 없이 다른 트랜잭션에서 보여지게 된다. 더티 리드(Dirty Read) 발생하는 문제점이 생긴다.

그래서 트랜잭션의 격리 수준으로 인정하지 않을 정도로 데이터의 정합성에 악영향을 끼치므로 해당 격리 수준은 피할 것을 권장한다.


### 더티 리드란?
더티 리드란 **다른 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 볼 수 있게 되는 현상**을 말한다.

예시) 다른 트랜잭션에서 사용자 B가 실행하는 SELECT 쿼리의 결과에 사용자 A의 INSERT 쿼리가 COMMIT되기 전에 어떤 영향을 미치는지 보여주는 예시이다.
![[Pasted image 20230811154451.png]]
문제점은 만약 사용자 A가 작업 도중 문제가 발생하여 삽입한 내용을 **롤백해도 사용자 B는 JuBal이 정상적인 사원이라 판단하고 계속해서 처리**하게 된다.


## READ COMMITTED
오라클에서 기본적으로 사용되고 있으며, 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. 어떤 트랜잭션에서 데이터를 변경하더라도 **커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수** 있기 때문이다.

**그러나 READ COMMITTED 격리 수준에서는 NON_REPEATABLE READ라는 부정합 문제가 존재한다.**


### 더티 리드(Dirty Read)해결
![[Pasted image 20230811154852.png]]
사용자 A는  `first_name` 을 JuBal에서 Toto로 수정하였는데, **이때 새로운 값인 Toto는 `employees` 테이블에 즉시 기록되고 이전 값인 JuBal은 `Undo` 영역으로 백업이 된다.**

사용자 A가 이러한 변경 내역을 커밋하기 전에 사용자 B가 조회하면 결과 값은 Toto가 아닌, 이전 값인 JuBal이 조회된다. 여기서 사용자 B의 SELECT 쿼리 결과는 `employees` 테이블이 아닌 **`Undo` 영역의 백업된 레코드에서 가져온 결과이다.**


### NON-REPEATABLE READ 발생
NON-REPEATABLE READ란, **하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장**해야 한다는 REPEATABLE READ 정합성에 어긋나는 것을 말한다.

예시)
![[Pasted image 20230811155053.png]]
Toto로 수정하고 커밋한 전후 사용자 B가 똑같은 SELECT 쿼리로 조회하면 수정 전에는 결과값이 없다가, 수정 후에는 1건의 결과가 조회된다. 이는 사용자 B가 하나의 트랜잭션 내에서 **동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 REPEATABLE READ 정합성에 어긋나게 된다.**

웹 프로그램에서는 크게 문제가 되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.


## REPEATABLE READ
MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준이다. 이 격리 수준에서는 READ COMMITTED 격리 수준에서 발생하는 NON-REPEATABLE READ 부정합이 발생하지 않습니다.
 
PHANTOM READ 부정합이 발생하지만, InnoDB 스토리지 엔진을 사용할 경우 PHANTOM READ 부정합이 발생습니다.


### NON-REPEATABLE READ 해결
언두(Undo) 영역에 **백업된 이전 데이터를 통해 트랜잭션 내에서는 동일한 결과를 보여 주도록 보장**하여 NON-REPEATABLE READ 문제를 해결한다. 

사실 READ COMMITTED 격리 수준 또한 언두 영역에 백업된 이전 데이터를 보여 주지만, 두 격리 수준에는 언두 영역을 활용하는 방식이 다르다. `REPEATABLE READ` 격리 수준은 ‘**언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 버전을 보여 주냐**’에 차이가 있어 NON-REPEATABLE READ 문제를 해결할 수 있다.

예시)
![[Pasted image 20230811161105.png]]
REPEATABLE READ 격리 수준에서는 실행 중인 트랜잭션(10번)보다 작은 트랜잭션에서 변경한 데이터만 보게 하여 NON-REPEATABLE READ 문제를 해결한다. 그래서 사용자 A의 12번 트랜잭션에서 변경한 데이터는 열람할 수 없다.


### PHANTOM READ 발생
`SELECT ... FOR UPDATE` 쿼리와 같은 **쓰기 잠금을 거는 경우 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상**을 말한다.
 
![[Pasted image 20230811165112.png]]


### InnoDB 스토리지 엔진에서 PHANTOM READ 해결하는 방법은?
1. **MVCC 사용**
InnoDB는 MVCC를 사용하여 트랜잭션이 동시에 데이터에 접근할 수 있도록 합니다. MVCC는 각 트랜잭션에 대해 **데이터의 여러 버전을 유지하고 관리**하며, 이를 통해 같은 데이터를 동시에 읽는 트랜잭션들이 서로 영향을 미치지 않게 됩니다. 이 기법 덕분에 트랜잭션 간 동시성이 개선되고, 팬텀 판독 현상이 대부분 차단됩니다.

2. **Next-Key Locking**
InnoDB의 기본 격리 수준인 REPEATABLE READ에서 이 기법이 적용됩니다. Next-Key Locking은 **레코드 레벨의 락을 사용하면서도 레코드 간의 간격에도 락을 걸어 새로운 레코드의 삽입이나 삭제를 제한**합니다. 이렇게 함으로써 팬텀 판독 현상을 방지할 수 있습니다.


## SERIALIZABLE
가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다. 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.
**한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것**이다. 따라서 SERIALIZABLE 격리 수준에서는 모든 부정합 문제가 발생하지 않는다. 그러나 동시 처리가 거의 불가능하므로 **사용을 권장하지 않는다.**