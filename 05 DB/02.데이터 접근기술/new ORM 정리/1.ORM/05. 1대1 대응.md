
#패컴JPA프로그래밍06

코드 위치 : databaseJpaPractice/oneToOne

----
## 언제 1:1 사용해야될까?
1. 주요 엔티티와 **세부적인 정보를 분리**하고 싶을 때
예를 들어, 한개의 `book`  테이블마다 여러개의 `review` 테이블이 존재한다. 하지만 개별적인 리뷰만 존재할뿐 전체적인 평점은 개별적인 평점을 연산해야한다. 리뷰가 많아질수록 계산시간이 많아짐으로, 전체적인 평점을 관리할 수 있는 `book_review_info` 테이블을 만들었다.

2. 데이터 **접근을 분리**하고 싶을 때
예를 들어, 특정 데이터에 대한 접근 권한을 제한하고 싶을 때 해당 데이터를 별도의 테이블에 분리하고, 이를 1:1 관계로 연결하여 데이터 접근을 분리할 수 있습니다.


## 연관관계가 맺지 않은 상태의 코드는?
#### 코드
![[Pasted image 20231114031211.png]]
```java
@Entity  
@NoArgsConstructor  
@Data  
@ToString(callSuper = true)  
@EqualsAndHashCode(callSuper = true)  
public class Book1 extends BaseEntity {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    private String name;  
  
    private String category;  
  
    private Long authorId;  
    private Long publisherId; //BookReviewInfo의 FK  
    public Book1(String name, String category, Long authorId, Long publisherId) {  
        this.name = name;  
        this.category = category;  
        this.authorId = authorId;  
        this.publisherId = publisherId;  
    }  
}
```

```java
@Entity  
@NoArgsConstructor  
@Data  
@ToString(callSuper = true)  
@EqualsAndHashCode(callSuper = true)  
public class BookReviewInfo1 extends BaseEntity {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    private Long bookId; //Book의 FK  
    private float averageReviewScore;  
  
    private int reviewCount;  
  
    public BookReviewInfo1(Long bookId, float averageReviewScore, int reviewCount) {  
        this.bookId = bookId;  
        this.averageReviewScore = averageReviewScore;  
        this.reviewCount = reviewCount;  
    }  
}
```


#### 문제점은?
1. 객체지향적이지 않습니다
실세계에서는 '책'과 '책 리뷰 정보'가 서로 연관관계를 맺고 있습니다. 하지만 이 코드에서는 이 연관관계가 전혀 반영되지 않았습니다. 이렇게 될 경우, 객체와 데이터베이스 사이에 불필요한 '**불일치**'가 발생하게 됩니다.

2. 코드 복잡성이 증가합니다: 
'책'과 '책 리뷰 정보'를 함께 조회하거나 조작하려면 **별도의 코드를 작성**해야 합니다. 이는 코드의 복잡성을 증가시키며, 실수를 유발할 수 있습니다.

3. 성능이 저하될 수 있습니다
'책'과 '책 리뷰 정보'를 함께 조회하려면 **별도의 SQL 쿼리를 두 번 실행**해야 합니다. 이는 성능을 저하시킬 수 있습니다.


## 단방향 1:1 대응
#### 코드
![[Pasted image 20231124164215.png]]
해당 별점 및 조회수를 통해 어떤 책인지 판단 할 수 있음.

```java
@Entity  
@NoArgsConstructor  
@Data  
@ToString(callSuper = true)  
@EqualsAndHashCode(callSuper = true)  
public class Book2 extends BaseEntity {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    private String name;  
  
    private String category;  
  
    private Long authorId;  
  
    private Long publisherId; //BookReviewInfo의 FK  
    public Book2(String name, String category, Long authorId, Long publisherId) {  
        this.name = name;  
        this.category = category;  
        this.authorId = authorId;  
        this.publisherId = publisherId;  
    }  
}
```

```java
@Entity  
@NoArgsConstructor  
@Data  
@ToString(callSuper = true)  
@EqualsAndHashCode(callSuper = true)  
public class BookReviewInfo2 extends BaseEntity {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    @OneToOne(optional = false)  
    @JoinColumn(name = "book_id")  
    private Book2 book;  //Long bookId 에서 바뀜  
  
    private float averageReviewScore;  
  
    private int reviewCount;  
  
    public BookReviewInfo2(Book2 book, float averageReviewScore, int reviewCount) {  
        this.book = book;  
        this.averageReviewScore = averageReviewScore;  
        this.reviewCount = reviewCount;  
    }  
}
```
- `@OneToOne(optional = false) private Book book;`
이 필드는 **`Book` 엔티티와의 1:1 대응 관계**를 나타냅니다. `@OneToOne` 어노테이션을 통해 1:1 관계임을 명시하고, 
`optional = false`를 통해 `Book` 엔티티가 반드시 존재해야 함을 나타냅니다. 

#### 결과
- 생성된 테이블
![[Pasted image 20231114222456.png]]


## 방향의 차이는?
1:1 단방향 참조는 **연관관계의 주인이 되는 쪽에서만 참조**를 하게 됩니다.

▶Book -> Book_reivew_info
![[Pasted image 20231124164206.png]]
- `BookReviewInfo`가 외래 키를 가지고 있게 됩니다.
- `BookReviewInfo`에서 Book을 참조할 수 있습니다. 즉, `BookReviewInfo`를 통해 해당 리뷰가 어떤 책에 대한 것인지 알 수 있습니다.
- `Book`에서는 `BookReviewInfo`를 참조할 수 없습니다. 즉, 특정 책에 대한 리뷰 정보를 알기 위해서는 별도의 쿼리를 실행해야 합니다.
```java
// BookReviewInfo 엔티티를 먼저 조회
BookReviewInfo1 reviewInfo = bookReviewInfoRepository.findById(1L).get();

// 별도의 쿼리를 실행하여 Book 엔티티를 조회
Book1 book = bookRepository.findById(reviewInfo.getBookId()).get();
```

▶Book <- Book_reivew_info
![[Pasted image 20231124164215.png]]
- `Book`이 외래 키를 가지고 있게 됩니다.
- `Book`에서 `BookReviewInfo`를 참조할 수 있습니다. 즉, `Book`을 통해 해당 책의 리뷰 정보를 알 수 있습니다.
- `BookReviewInfo`에서는 `Book`을 참조할 수 없습니다. 즉, 특정 리뷰 정보가 어떤 책에 대한 것인지 알기 위해서는 별도의 쿼리를 실행해야 합니다.


## FK키 지정하는 방법



## 양방향 1:1 대응 연결
#### 코드
```java
@NoArgsConstructor  
@Data  
@ToString(callSuper = true)  
@EqualsAndHashCode(callSuper = true)  
public class BookReviewInfo extends BaseEntity {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    @OneToOne(optional = false)  
    private Book book;  //Long bookId 에서 바뀜
  
    private float averageReviewScore;  
  
    private int reviewCount;  
}
```


```java
@Entity  
@NoArgsConstructor  
@Data  
@ToString(callSuper = true)  
@EqualsAndHashCode(callSuper = true)  
public class Book extends BaseEntity {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    private String name;  
  
    private String category;  
  
    private Long authorId;  
  
    private Long publisherId;  
  
    @OneToOne(mappedBy = "book")  
    @ToString.Exclude  
    private BookReviewInfo bookReviewInfo;  
}
```
- `@OneToOne(mappedBy = "book") @ToString.Exclude private BookReviewInfo bookReviewInfo;`
`@OneToOne` 어노테이션을 통해 **1:1 관계임을 명시**하고, `mappedBy = "book"`를 통해 `BookReviewInfo` 엔티티의 **`book` 필드에 의해 관계가 관리**된다는 것을 나타냅니다. 
 
`@ToString.Exclude` 어노테이션은 `toString()` 메서드를 호출할 때 이 필드를 제외하도록 설정합니다. 이는 **양방향 관계에서 순환 참조를 방지하기 위한 설정**입니다.
