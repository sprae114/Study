#엔티티

#패컴JPA프로그래밍04

---
[JPA 기본 Annotation 정리 :: catpark's something new (icatpark.com)](https://www.icatpark.com/entry/JPA-%EA%B8%B0%EB%B3%B8-Annotation-%EC%A0%95%EB%A6%AC)
[[JPA] 엔티티 매핑 (tistory.com)](https://blogshine.tistory.com/343)

```java
@Data
@Entity
@Table(name = "sp_crew", indexes = { @Index(columnList = "name")}, 
	   uniqueConstraints = {@UniqueConstraint(columnNames = {"email"})})
public class Crew {
    @Id
    @GeneratedValue
    private Long id;

    @NonNull
    private String name;
  
    @NonNull
    private String email;

    @Enumerated(value = EnumType.STRING)
    private Gender gender;

    @Column(updatable = false)
    private LocalDateTime createdAt;

	@Column(insertable = false)
    private LocalDateTime updatedAt;

    @Transient
    private String fullName;

}
```

## `@Data`
Lombok 라이브러리의 어노테이션입니다. 이 어노테이션을 클래스에 붙이면 `getter`, `setter`, `equals()`, `hashCode()`, `toString()` 등의 메소드를 자동으로 생성해줍니다. 


## `@Entity`
**클래스가 엔티티임을 JPA에게 알려**줍니다. 이 어노테이션이 지정된 클래스는 JPA가 관리하며, 데이터베이스의 테이블과 매핑됩니다.


## `@Table`
엔티티가 매핑될 **테이블에 대한 정보**를 지정합니다. 
1. `name` 테이블 이름을 지정 
2. `indexes` 인덱스를 생성할 컬럼을 지정 
3. `uniqueConstraints` 유니크 제약 조건을 지정


## `@Id`
해당 필드가 테이블의 **기본 키(Primary Key)에 매핑**된다는 것을 나타냅니다.


## `@GeneratedValue`
주로 엔티티의 **기본 키 값(primary key)을 자동으로 생성**하기 위해 사용됩니다.

`strategy` 속성을 통해 사용할 기본 키 생성 전략을 지정할 수 있습니다.

1. `AUTO`: (기본값) 특정 DB에 맞게 자동 선택됩니다. 대부분의 경우, `IDENTITY` 전략을 선택합니다.
2. `IDENTITY`: 데이터베이스의 IDENTITY 컬럼을 이용해 기본 키 값을 생성합니다. **데이터베이스에 값을 저장하면서 동시에 자동 생성된 키를 반환**합니다. MySQL, PostgreSQL, SQL Server, DB2 등에서 사용됩니다.
3. `SEQUENCE`: 데이터베이스의 시퀀스를 이용해 기본 키 값을 생성합니다. 이 전략은 시퀀스를 지원하는 Oracle, PostgreSQL, DB2, H2 등에서 사용됩니다. `@SequenceGenerator` 어노테이션과 함께 사용하여 시퀀스 생성기를 정의할 수 있습니다.


## IDENTITY에 대해서
```java
@Id 
@GeneratedValue(strategy = GenerationType.IDENTITY) 
private Long id;
```
이 전략은 **기본키 생성을 데이터베이스에게** **위임**한다. 즉, **DB까지 가서야 자신의 PK 값을 알게되는 것** 이다.

하지만 영속성 컨텍스트에서 관리되려면 무조건 **PK값이 있어야** 1차 캐시에 저장될수가 있다. 즉, IDENTITY는 PK값을 DB에 들어가봐야 알수 있는것 이다. 
그래서 IDENTITY 전략에서만 **persist()를 호출하자마자 바로 DB에 쿼리가 전송**된다.

![[Pasted image 20231121011954.png]]
![[Pasted image 20231121012006.png]]

▶코드로 확인해보기
```java
Member member = new Member(); 
member.setUsername("A"); 

System.out.println("=========="); 
entityManager.persist(member); 
System.out.println("member ID : " + member.getId()); System.out.println("=========="); 

transaction.commit();
```

![[Pasted image 20231121164543.png]]
persist()를 호출하자 마자, 우선 INSERT 쿼리문이 생성되어 DB에 전달되게 된다.


## `@Column`
필드가 매핑될 **컬럼에 대한 정보**를 지정합니다. 
![[Pasted image 20231121162343.png]]



## `@NonNull`
**필드 값이 null이 아니어야 함**을 나타냅니다. 


## `@Enumerated`
자바의 **열거형 타입**을 데이터베이스와 매핑하기 위해 사용합니다. 

- `EnumType.ORDINAL` **열거형의 순서**(0부터 시작하는 정수)가 데이터베이스에 저장됩니다. 하지만 enum 변경의 취약해서 사용 X
- `EnumType.STRING` **열거형의 이름**이 데이터베이스에 저장함.


## `@Transient`
어노테이션이 붙은 필드는 **JPA가 데이터베이스에 매핑하지 않습**니다. 즉, 해당 필드는 데이터베이스 테이블의 컬럼에 해당하지 않으며, 데이터베이스에 저장되거나 검색되지 않습니다.

주로 **임시 상태를 유지하거나, 계산에 의해 얻어진 값을 보관**할 필요가 있는 경우에 사용됩니다.


## @Column(unique = true) vs @Table 의 uniqueConstraints 차이
둘 다 컬럼에 **유니크 제약 조건을 설정**하는 방법이지만, 사용하는 상황과 목적이 약간 다릅니다.

- `@Column(unique = true)` 단일 컬럼에 대한 유니크 제약 조건을 설정할 때 주로 사용

- `@Table(uniqueConstraints = ...)`는 하나 이상의 컬럼을 포함하는 복합 유니크 제약 조건을 설정할 때 사용


## 복합인덱스 설정하는 방법은?
복합 인덱스는 여러 개의 컬럼을 하나의 인덱스로 묶어 성능을 향상시키는 방법입니다. 

`@Index` 어노테이션을 사용하여 인덱스의 이름과 해당 인덱스가 포함할 컬럼 이름을 지정할 수 있습니다. 여러 개의 컬럼 이름은 쉼표로 구분합니다.

```java
@Entity
@Table(name = "users", 
       indexes = {@Index(name = "index_user_name_email", columnList = "name,email")})
public class User {
    // ...
}
```
위의 코드는 `User` 클래스를 "users"라는 이름의 테이블과 매핑하고, "name"과 "email" 컬럼에 대해 "index_user_name_email"이라는 이름의 복합 인덱스를 생성하도록 지정하고 있습니다.


## `@RequiredArgsConstructor`
`final`이나 `@NonNull`이 붙은 필드들에 대한 **생성자를 자동으로 만들어**주는 것이 `@RequiredArgsConstructor`의 역할임.

```java
@Entity
public class SampleClass {

	@Id  
	@GeneratedValue(strategy = GenerationType.IDENTITY)  
	private Long id;  
	  
	@NonNull  
	private String name;  
	  
	private final String email;
	
    private int age;
}
```

```java
public SampleClass(String name, String email) {
    this.name = name;
    this.email = email;
}
```
이 클래스에 대해 아래와 같은 생성자를 자동으로 생성해줌.

## 생성된 SQL구문
```
Hibernate: 
create table sp_crew (
	id bigint not null auto_increment, 
	email varchar(255), 
	gender varchar(255), 
	name varchar(255), 
	created_at datetime(6), 
	updated_at datetime(6), 
	primary key (id)
) 
engine=InnoDB


Hibernate: 
create index IDXdeqmb2jrb629tqnb900jvv40b on sp_crew (name)

Hibernate: alter table sp_crew add constraint UKmrh50mj24vj3t0jk963wdre75 unique (email)
```


## primitive type vs wrapper typer
```java
@Entity  
@NoArgsConstructor  
@Data  
@ToString(callSuper = true)  
@EqualsAndHashCode(callSuper = true)  
public class BookReviewInfo extends BaseEntity {  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
//    private Long bookId;  
  
    @OneToOne(optional = false)  
    private Book book;  
  
    private float averageReviewScore;  
  
    private int reviewCount;  
}
```

▶기본형 타입(Primitive type)
- null 값을 가질 수 없으므로, 필드 값이 항상 명확합니다. 
- 래퍼 클래스에 비해 메모리 사용량이 적고 속도가 빠릅니다.

▶래퍼 클래스(Wrapper type)  [[래퍼 클래스 메소드]]
- null 값을 가질 수 있습니다.
- 다양한 메서드를 제공하여 추가적인 기능을 사용할 수 있습니다.
