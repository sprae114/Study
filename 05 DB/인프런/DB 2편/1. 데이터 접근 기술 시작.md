링크 : [[[인프런]스프링DB 2편.pdf]]

----

## 데이터 접근 기술 두가지는?
#### 📌SQL Mapper
- 개발자는 **SQL만 작성**하면 해당 SQL의 결과를 **객체로 편리하게 매핑**해준다.  
- ex ) JdbcTemplate, MyBatis

#### 📌ORM(Object Relational Mapping)
- SQL 매퍼 기술은 SQL을 개발자가 직접 작성해야 하지만, JPA를 사용하면 **기본적인 SQL은 JPA가 대신 작성하고 처리**해준다. 개발자는 저장하고 싶은 객체를 마치 자바 컬렉션에 저장하고 조회하듯이 사용하면 ORM 기술이 데이터베이스에 해당 객체를 저장하고 조회해준다.
- `spring data JPA`, `Querydsl`은 JPA를 더 편리하게 사용할 수 있게 도와주는 프로젝트이다.
-  ex) JPA, Hibernate

  
##  (코드) 프로젝트 설정
#### 0) 프로젝트 그림으로 보기
![[Pasted image 20230101182520.png]]
상품 이름과 가격제한을 적용하여 검색하는 기능이 추가되었다.

#### 1) 추가된 도메인 - 검색 조건
```java
@Data // cond -> condition
public class ItemSearchCond {
	//상품명의 일부만 포함되어도 검색이 가능해야 한다. ( like 검색)
 	private String itemName;
 	private Integer maxPrice;
    
 	public ItemSearchCond() {}
    
 	public ItemSearchCond(String itemName, Integer maxPrice) {
 		this.itemName = itemName;
 		this.maxPrice = maxPrice;
 	}
}
```


#### 2) 추가된 도메인 - DTO
DTO는 기능은 없고 데이터를 전달만 하는 용도로 사용되는 객체를 뜻한다.
```java
@Data
public class ItemUpdateDto {
 	private String itemName;
 	private Integer price;
 	private Integer quantity;
    
 	public ItemUpdateDto() {}
    
	 public ItemUpdateDto(String itemName, Integer price, Integer quantity) {
 		this.itemName = itemName;
 		this.price = price;
 		this.quantity = quantity;
 	}
}
```


#### 3) 초기 테스트 데이터 추가
=> 애플리케이션을 실행할 때 초기 데이터를 저장함.
```java
public class TestDataInit {
 private final ItemRepository itemRepository;
 //확인용 초기 데이터 추가
 //스프링 컨테이너가 완전히 초기화를 다 끝내고, 실행 준비가 되었을 때 발생하는 이벤트
 @EventListener(ApplicationReadyEvent.class)
 public void initData() {
 		log.info("test data init");
 		itemRepository.save(new Item("itemA", 10000, 10));
 		itemRepository.save(new Item("itemB", 20000, 20));
 	}
}
```
- `@EventListener(ApplicationReadyEvent.class)` : 스프링 컨테이너가 완전히 초기화를 다 끝내고, 실행 준비가 되었을 때 발생하는 이벤트이다. 스프링이 이 시점에 해당 애노테이션이 붙은 initData() 메서드를 호출해준다. 
	- 왜 사용하는 거지?`@EventListener` 대신 `@PostConstruct` 를 사용할 경우 AOP 같은 부분이 아직 다 처리되지 않은 시점에 호출될 수 있기 때문에, 간혹 문제가 발생할 수 있다.
- TestDataInit 은 프로필이 local 일때만 동작하는데, **테스트 케이스를 실행할 때**는 프로필이 spring.profiles.active=test 이기 때문에 **초기화 데이터가 추가되지는 않는다.**

#### 4) 프로필
```java
// Application 실행 클래스
@Import(MemoryConfig.class) 
public class ItemServiceApplication {
	public static void main(String[] args) {
		SpringApplication.run(ItemServiceApplication.class, args);
	}
    
	@Bean
	@Profile("local")
	public TestDataInit testDataInit(ItemRepository itemRepository) {
		return new TestDataInit(itemRepository);
	}
}
```

```java
spring.profiles.active=local // or test
```
- `@Import(MemoryConfig.class)` : 앞서 설정한 **MemoryConfig 를 설정 파일로 사용**한다.
- `@Profile("local")` : **특정 프로필의 경우에만 해당 스프링 빈을 등록**한다. 여기서는 local 이라는 이름의 프로필이 사용되는 경우에만 testDataInit 이라는 스프링 빈을 등록한다. 편의상 **초기 데이터를 만들어서 저장하는 빈**이다.
	-   프로필 2가지 종류  
	    -   main 프로필  -> 자바 객체를 실행할 때 (주로 main() ) 동작하는 스프링 설정  
	        -   ![[Pasted image 20230102073245.png]]
	    -   test 프로필  -> 테스트 케이스를 실행할 때 동작한다  
	        
	        -   ![[Pasted image 20230102073253.png]]


#### 5) 데이터베이스 테이블 생성
H2 데이터베이스에 접근해서 item 테이블을 생성하자.
```sql
drop table if exists item CASCADE;
create table item
(
 	id bigint generated by default as identity,
 	item_name varchar(10),
 	price integer,
 	quantity integer,
 	primary key (id)
);
```

- `generated by default as identity` : **기본 키 생성을 데이터베이스에 위임하는 방법**이다. MySQL의 `Auto Increment`와 같은 방법이다. 여기서 PK로 사용되는 id 는 개발자가 직접 지정하는 것이 아니라 비워두고 저장하면 **데이터베이스가 순서대로 증가하는 값을 사용해서 넣어**준다.

  

## 기본 키의 필수 3가지 조건은?
-   null 값은 허용하지 않는다.
-   유일해야 한다.
-   변해선 안 된다.

## 기본 키를 선택하는 전략 2가지는?
1) 자연 키(natural key)
- 비즈니스에 의미가 있는 키  
- 예: 주민등록번호, 이메일, 전화번호

2) 대리 키(surrogate key)
- 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로도 불린다.  
- 비즈니스 환경은 언젠가 변하므로, 대리 키를 권장한다
- 예: 오라클 시퀀스, auto_increment, identity, 키생성 테이블 사용