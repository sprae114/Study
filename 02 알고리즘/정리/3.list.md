# 1.리스트 의미

#### list mean


```python
A = [[1,2,3],[4,5,6],[7,8,9]]
logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig"]

#🧨🧨항상 A[r][c] or A[y][x]로 생각하기
#🧨 시작은 항상 0부터
#행렬 자리 의미
print(A[1])
print(A[1][2])

#실수했던 것
#🧨list에서 split을 사용할때는 같은 갯수가 나오는지 확인!!
print(logs[0])
print(logs[0][1])
print(logs[0].split())
print(logs[0].split()[1])
```

    [4, 5, 6]
    6
    dig1 8 1 5 1
    i
    ['dig1', '8', '1', '5', '1']
    8
    

#### index vs slicing 조회

    🧨조회할때 type이 int인지 string인지 구별하기


```python
arr = [0,1,2,3,4,5]

##index만 이용하는 경우
#index가 벗어나는 경우 indexerror
print(arr[-3], arr[0])

#slicing을 이용하는 경우
#slicing의 경우 (열림,닫힘]을 기억하자
print(arr[:-1], arr[-2:], arr[:4:2], arr[5:6])

#🧨index가 벗어나는 경우 빈 리스트 반환!!
print(arr[6:7], arr[6:], arr[:-7])
```

    3 0
    [0, 1, 2, 3, 4] [4, 5] [0, 2] [5]
    [] [] []
    


```python
#2차일때 slicing
#https://programmers.co.kr/learn/courses/30/lessons/68645
```

#### list use % to cycle


```python
# %은 순회
pattern = [1,2,3,4,5]
answer = [1,1,2,2,3,3,4,4]

for num in range(12):
    if pattern[num%5] == answer[num%8]:
        print("Yes")
```

#### list bool

    파이썬에서는 아래 요소에 대해서는 거짓(False)으로 판단
     - 숫자 0 (zero)
     - 빈 문자열 '', "", '''''' 
     - 빈 리스트 [ ]
     - 빈 튜플 ( )
     - 빈 사전 { }
     - None


```python
#list bool
print(bool([]), bool([1]), bool([0]))

#list type
if type([]) == list:
    print("type true")
    
#list len
print(len([]) == 0,  len([2]) == 0)
```

    False True True
    type true
    True False
    

# 2. 리스트 생성

#### make list


```python
##일차 리스트생성
#set,tuple,string -> list 만들기
print(list({1,2,3,4,5,"a", "b", "c"}))
print(list((1,2,3,4,5,"a", "b", "c")))
print(list("dfs  sf fs f"))

#list를 list()함수 쓰면 메모리 저장위치 변함
A = [23,12,34,"FA"]
print(list(A), id(list(A)))
print(A, id(A))
```

    [1, 2, 3, 4, 5, 'c', 'b', 'a']
    [1, 2, 3, 4, 5, 'a', 'b', 'c']
    ['d', 'f', 's', ' ', ' ', 's', 'f', ' ', 'f', 's', ' ', 'f']
    [(1, 'A'), (2, 'B'), (3, 'C')]
    [23, 12, 34, 'FA'] 1666338241280
    [23, 12, 34, 'FA'] 1666337873792
    

#### 2-demensional list caution


```python
#1차원 리스트 생성
A1 = [0]*3
A2 = [0 for _ in range(3)]

A1[1] = 1
A2[1] = 1
print(A1, A2)

#2차원 리스트 생성의 주의점
B1 = [[0] * 3] * 3
B2 = [[0] * 3 for _ in range(3)]

B1[0][0] = 1
B2[0][0] = 1

print(B1, B2)
```

    [0, 1, 0] [0, 1, 0]
    [[1, 0, 0], [1, 0, 0], [1, 0, 0]] [[1, 0, 0], [0, 0, 0], [0, 0, 0]]
    

#### Tips for using "range"


```python
#[2,4,6,8,10] 2칸씩 생성하기
#처음 숫자와 끝 숫자를 알아야 구함
#🧨range(2,2*5+1,2) 이렇게 하면 좀더 갯수와 범위를 한꺼번에 알수 있음.
print(list(x for x in range(2,11,2)))
print(list(x for x in range(10,-3,-2)))

#갯수로만 구함
print(list(x*2 for x in range(1,6)))
```

    [2, 4, 6, 8, 10]
    [10, 8, 6, 4, 2, 0, -2]
    [2, 4, 6, 8, 10]
    

#### list using "itertools"
    
    combinations(list_ex, 2)


```python
#itertools
#when? 모든 경우의 수를 따져야 할때
import itertools 

list_ex = [1, 2, 3, 5, 2, 7]

print(itertools.combinations(list_ex, 2))       #object로 반환
print(list(itertools.combinations(list_ex, 2)))
print(list(itertools.permutations(list_ex[:4], 2)))
```

    <itertools.combinations object at 0x000001C0241E71D0>
    [(1, 2), (1, 3), (1, 5), (1, 2), (1, 7), (2, 3), (2, 5), (2, 2), (2, 7), (3, 5), (3, 2), (3, 7), (5, 2), (5, 7), (2, 7)]
    [(1, 2), (1, 3), (1, 5), (2, 1), (2, 3), (2, 5), (3, 1), (3, 2), (3, 5), (5, 1), (5, 2), (5, 3)]
    

#### list using "Counter"


```python
#collections를 이용한 list생성
#when? 세는 것을 따져야할때
from collections import Counter

string_ex = 'aaaaabbbbbbccccccaaaaddddd'
list_ex = [1, 2, 3, 3, 3, 5, 2, 7]

print(list(map(list, Counter(string_ex).most_common())))
print(list(Counter(string_ex).most_common()))
print(list(map(list, Counter(list_ex).most_common())))
```

    [['a', 9], ['b', 6], ['c', 6], ['d', 5]]
    [('a', 9), ('b', 6), ('c', 6), ('d', 5)]
    [[3, 3], [2, 2], [1, 1], [5, 1], [7, 1]]
    

#### deque


```python
#collections를 이용한 list생성
#when? 앞뒤로 빈번히 뺴야될때
import collections 

q1 = collections.deque()

for x in [1,2,3,4,5,1,2,3,4,5,3,42,1]:
    q1.append(x)
    
print(q1)
print(list(q1))
```

    deque([1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 3, 42, 1])
    [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 3, 42, 1]
    

#### list using "heapq"


```python
#when? 자동으로 순서 나열이 필요할때
#🧨리스트가 힙구조로 바뀐다 직접해보기
import heapq

heap = [4, 1, 7, 3, 8, 5]
heapq.heapify(heap)

print(heap)

heapq.heappush(heap, 0)

print(heap)
```

    [1, 3, 5, 4, 8, 7]
    [0, 3, 1, 4, 8, 7, 5]
    

#### list using "copy"


```python
##copy
## shallow copy
A1 = [1, 2, 3, 4, 5]

B1 = A1
#값을 할당하면 새로운 id가 부여되며, 서로 영향을 받지 않음.
B2 = A1[:]

#A1, B1은 같은 메모리 주소를 바라보고 있기 때문에 둘다 영향줌
A1.pop()
B1.pop()
print(B1, B2)
#B1에 다른 값을 할당하면 재할당이 이루어지며 메모리 주소가 변경
B1 = B2
print(B1, B2)
```

    [1, 2, 3] [1, 2, 3, 4, 5]
    [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]
    


```python
import copy
##🧨🧨이차 행렬일때 복사
A1 = [[1,2], [3,4]]

B1 = A1[:]
B2 = copy.deepcopy(A1)

A1[0].append(3)
A1[1].append(5)
print(B1, B2)
```

    [[1, 2, 3], [3, 4, 5]] [[1, 2], [3, 4]]
    

#### transpose and list using "zip"
    zip(*iterable)은 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수이다.
    여기서 사용한 *iterable은 반복 가능(iterable)한 자료형 여러 개를 입력할 수 있다는 의미이다.
    
    반복 가능한 객체에 별표(Asterisk, *)를 함께 사용한다면, 언패킹되어 묶여있던 객체들이 나눠지게 됩니다. 즉, 2차원 리스트는 1차원 리스트 만큼 나눠서 반환하게 됩니다.
    이 때, zip 함수를 사용하여 다시 패킹한다면 각 원소마다 묶기 때문에 여러 반복문을 구성하지 않아도 다시 패킹 할 수 있습니다. 
    zip(*n차원 객체)는 zip(n-1차원 객체1, n-1차원 객체2, ...)로 볼 수 있습니다.


```python
##zip를 이용한 생성
#두개의 list로 zip함수 
print(list(zip([1, 2, 3], ["A", "B", "C"])))
print(list(map(list, zip([1, 2, 3], ["A", "B", "C"]))))

#*의 유무 차이
print(list(map(list, zip([[7,8,9],[4,5,6],[1,2,3]]))))
print(list(map(list, zip(*[[7,8,9],[4,5,6],[1,2,3]]))))
print(zip(*[[7,8,9],[4,5,6],[1,2,3]]))
print(list(zip(*[[7,8,9],[4,5,6],[1,2,3]])))

#zip 행과열이 갯수가 다른경우
print(list(map(list, zip(*[[7,8,9,10],[4,5],[1,2,3,4,5]]))))

#x[0]를 기준으로 오름차순 정렬후 zip
print(list(map(list, zip(*[[7,8,9,10],[4,5],[1,2,3,4,5]][::-1]))))
```

    [(1, 'A'), (2, 'B'), (3, 'C')]
    [[1, 'A'], [2, 'B'], [3, 'C']]
    [[[7, 8, 9]], [[4, 5, 6]], [[1, 2, 3]]]
    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]
    <zip object at 0x0000020B6FB7AD80>
    [(7, 4, 1), (8, 5, 2), (9, 6, 3)]
    [[7, 4, 1], [8, 5, 2]]
    [[1, 4, 7], [2, 5, 8]]
    


```python
#2차 리스트 zip
arr1 =[[1,2], [3,4]]
arr2 =[[5,6], [7,8]]

for a, b in zip(arr1, arr2):
    print(a,b)
    for c, d in zip(a, b):
        print(c, d)
```

    [1, 2] [5, 6]
    1 5
    2 6
    [3, 4] [7, 8]
    3 7
    4 8
    

####  list to use "Asky code"


```python
#아스키 코드를 활용한 리스트만들기
#🧨🧨chr과 ord 꼭알기
#🧨🧨'A' : 65, 'Z' : 90 , 'a' : 97, 'z' : 122 알파벳 개수 : 26개
print([chr(i) for i in range(ord('A'), ord('Z') + 1)])
print([chr(i) for i in range(ord('a'), ord('z') + 1)])
```

    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
    

# 3. 리스트변환

#### list -> list


```python
#단일 or 다중 list -> list
print(list(map(list, ['23123342342342'])))
print(list(map(list, ['23123', '34234', '2342'])))


print(list(map(str, ['23123', '34234', '2342'])))
print(list(map(str, '23123 34234 2342'.split())))
```

    [['2', '3', '1', '2', '3', '3', '4', '2', '3', '4', '2', '3', '4', '2']]
    [['2', '3', '1', '2', '3'], ['3', '4', '2', '3', '4'], ['2', '3', '4', '2']]
    ['23123', '34234', '2342']
    ['23123', '34234', '2342']
    

#### str or pre-treatment str  -> list


```python
import re

##🧨🧨두자리 숫자 이상 항상 생각하기
print(list(map(int, re.sub("[\{\}]", "", "{{20,111},{111},{20,111,3245}}").split(","))))

##🧨🧨slicing 이용해서 규칙 아닌 범위 자르기 + split을 이용한 구분
nums = []
for num in "{{20,111},{111},{20,111,3245}}"[2:-2].split("},{"):
    nums.append(list(map(int, num.split(","))))
print(nums)
```

    [20, 111, 111, 20, 111, 3245]
    [[20, 111], [111], [20, 111, 3245]]
    


```python
#낱개 + 공백 포함 + list(str)
#list('23123 34234 2342')과 동일
print(list(map(str, '23123 34234 2342')))

#문자열 전처리 후 단일 문자열 -> list
print(list(map(str, '23123 34234 2342'.replace(' ',''))))

#split후 + list(list(str))
print(list(map(list, '23123 34234 2342'.split())))

#str->list로 바꾸면서 순서를 조절 가능!!
print(sorted('23123342342342'))
```

    ['2', '3', '1', '2', '3', ' ', '3', '4', '2', '3', '4', ' ', '2', '3', '4', '2']
    ['2', '3', '1', '2', '3', '3', '4', '2', '3', '4', '2', '3', '4', '2']
    [['2', '3', '1', '2', '3'], ['3', '4', '2', '3', '4'], ['2', '3', '4', '2']]
    ['1', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '4', '4', '4']
    

#### int -> list


```python
#각각 하나씩 따로 int형
##.🧨🧨list(int(23123342342342)) 안됌!!
#🧨정수일때도 list면 분해됌
print(list(map(int, '23123342342342')))

#split을 한 후에는 하나의 리스트로 만든 상태임
print(list(map(int, ['23123342342342'])))

#🧨어떤 형태로 나오는지 기억!! -> [23123, 34234, 2342]
# list(int(x) for x in '23123 34234 2342'.split()) 같은 결과
print(list(map(int, '23123 34234 2342'.split())))

#1차 행렬일때 str -> int로 바꾸기
print(list(map(int, ['100', '140', '8' ,'209', '50' '92', '3'])))

#🧨2차 행렬일때 str -> int로 바꾸기
o5 = []
for x in [['2', '3', '1', '2', '3'], ['3', '4', '2', '3', '4']]:
    o5.append(list(map(int, x)))
print(o5)
```

    [2, 3, 1, 2, 3, 3, 4, 2, 3, 4, 2, 3, 4, 2]
    [23123342342342]
    [23123, 34234, 2342]
    [100, 140, 8, 209, 5092, 3]
    [[2, 3, 1, 2, 3], [3, 4, 2, 3, 4]]
    

#### list -> str


```python
#list(str) -> str로 바꾸기
print(','.join(['100', '140', '8' ,'209', '50' '92', '3']))

#🧨''.join([100, 140, 8 ,209]) -> list(int)일때는 사용할 수 x why? int일때 합을 할꺼야 or 이어 붙일거야?
#list(str) -> int로 바꾸기
print(int(''.join(['100', '140', '8' ,'209', '50' '92', '3'])))

#이어 붙이기
print("".join(map(str,[100, 140, 8 ,209])))
print("".join([str(n) for n in [100, 140, 8 ,209]])) ##같은 결과

#🧨이어 붙이기 2차 행렬일때
q3 = ''
for x in [['2', '3', '1', '2', '3'], ['3', '4', '2', '3', '4']]:
    q3 += '/'.join(x)
print(q3)
```

    100,140,8,209,5092,3
    100140820950923
    1001408209
    1001408209
    2/3/1/2/33/4/2/3/4
    

#### dict -> list


```python
#dict 함수를 이용해 list 만들기
d = {'key2': 'value2','key1': 'value1',  'key3': 'value3'}
print(list(d.keys()))
print(list(d.values()))
print(list(d.items()))  #why?tuple 못 바꾸게 할라고

#sorted를 이용한 list
print(sorted(d))
```

    ['key2', 'key1', 'key3']
    ['value2', 'value1', 'value3']
    [('key2', 'value2'), ('key1', 'value1'), ('key3', 'value3')]
    ['key1', 'key2', 'key3']
    

#### list -> dict


```python
#zip을 dict로 생성
#when? 두 리스트를 빠르게 dict 만들고 싶을때
animals = ['cat', 'dog', 'lion']
sounds = ['meow', 'woof', 'roar']
nums = [1,2,3]

print(dict(zip(animals, sounds)))
print(dict(zip(animals, [sounds, nums])))

# Dict Comprehesion
string_list = ['A','B','C']
dictionary = {string : i for i,string in enumerate(string_list)}
print(dictionary)
```

    {'cat': 'meow', 'dog': 'woof', 'lion': 'roar'}
    {'cat': ['meow', 'woof', 'roar'], 'dog': [1, 2, 3]}
    {'A': 0, 'B': 1, 'C': 2}
    

#### tuple -> list


```python
import itertools
#튜플 형태 인것
print(list(map(list, ('23123', '34234', '2342'))))
print(list(('23123', '34234', '2342')))
print(list(map(int, ('23123', '34234', '2342'))))

#itertools의 tuple형태를 바꿔줌 
print(list(map(list, itertools.combinations('abcd',2))))
print(list(itertools.combinations('abcd',2)))
```

    [['2', '3', '1', '2', '3'], ['3', '4', '2', '3', '4'], ['2', '3', '4', '2']]
    ['23123', '34234', '2342']
    [23123, 34234, 2342]
    [['a', 'b'], ['a', 'c'], ['a', 'd'], ['b', 'c'], ['b', 'd'], ['c', 'd']]
    [('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd'), ('c', 'd')]
    

#### set -> list


```python
#set -> list(str)
print(list(map(str, {'23123' ,'34234 23ab'})))

#set -> list(int)
print(list(map(int, {23123, 34234, 2342})))

#🧨list(map(int, set(23123, 34234, 2342)))는 왜 안될까??
print(list(map(int, set([23123, 34234, 2342]))))
```

    ['34234 23ab', '23123']
    [34234, 23123, 2342]
    [34234, 23123, 2342]
    

## 4. 리스트 연산

#### list expend


```python
##리스트 덧셈
A1 =[[1,2], [3,4]]
B1 = [5,6]

#리스트 안에 넣기
#🧨덧셈이용
print(A1 + B1)

A1 += B1
print(A1)

#함수이용
A1.extend(B1)
print(A1)
```

    [[1, 2], [3, 4], 5, 6]
    [[1, 2], [3, 4], 5, 6]
    [[1, 2], [3, 4], 5, 6, 5, 6]
    

#### list append


```python
A2 =[[1,2], [3,4]]
B2 = [5,6,7]
##행렬 이어붙이기
#덧셈이용
A2 += B2,
print(A2)

#함수이용
A2.append(B2)
print(A2)

#원하는 위치에 추가하기
A2.insert(2,[5,6])
print(A2)
```

    [[1, 2], [3, 4], [5, 6, 7]]
    [[1, 2], [3, 4], [5, 6, 7], [5, 6, 7]]
    [[1, 2], [3, 4], [5, 6], [5, 6, 7], [5, 6, 7]]
    

#### list value plus


```python
##값 연산
#더하기(빼기/ 곱하기/ 나누기 방식 동일)
arr1 =[[1,2], [3,4]]
arr2 =[[1,2], [3,4]]

#2중 for문을 이용
for i in range(len(arr1)):
    for j in range(len(arr1[0])):
        arr1[i][j]+=arr2[i][j]

print(arr1)

#zip함수 이용
print([[c + d for c, d in zip(a, b)] for a, b in zip(arr1, arr2)])
```

    [[2, 4], [6, 8]]
    [[3, 6], [9, 12]]
    

#### list make set to use |,&


```python
##중복된 값이 없는 경우
lst1 = ['A', 'B', 'C', 'D']
lst2 = ['C', 'D', 'E', 'F']

#합집합
print(list(set(lst1) | set(lst2)), list(set().union(lst1,lst2)))

#교집합
print(list(set(lst1) & set(lst2)), list(set(lst1).intersection(lst2)))

#차집합
print(list(set(lst1) - set(lst2)), list(set(lst1).difference(lst2)))
```

    ['A', 'E', 'C', 'D', 'B', 'F'] ['A', 'E', 'C', 'D', 'B', 'F']
    ['D', 'C'] ['D', 'C']
    ['B', 'A'] ['A', 'B']
    


```python
#중복된 값이 있는 경우

https://wwlee94.github.io/category/algorithm/competition/2018-kakao/news-clustering/

```

#### list remove

        pop은 index를 이용해 값제거, 값 반환 O
        del은 index를 이용해 값제거 + sling 이용 가능, 값 반환 X 
        slicing은 원본데이터 유지하면 원하는 범위 추출
        remove는 value를 이용해 값제거, 값이 중복된다면 앞에꺼부터 제거


```python
#뺄셈
arr3 = [1,"A",2,"B",3,4,5,"R",6,7,8,"I",9]

#맨뒤 하나 제거
#arr.pop(index) 
print(arr3.pop())         #9제거
print(arr3)

#원하는거 index를 이용해 제거

del arr3[1]      #"A" 제거
del arr3[:2]     #"1,2" 제거
print(arr3)

#index를 이용해 원본 데이터 유지하며 범위 출력
print(arr3[:-3])
print(arr3[::2])


#원하는 value 제거
arr3.remove(7)        #7 제거
print(arr3)
```

    9
    [1, 'A', 2, 'B', 3, 4, 5, 'R', 6, 7, 8, 'I']
    ['B', 3, 4, 5, 'R', 6, 7, 8, 'I']
    ['B', 3, 4, 5, 'R', 6]
    ['B', 4, 'R', 7, 'I']
    ['B', 3, 4, 5, 'R', 6, 8, 'I']
    


```python
arr4 = [[1,2,3],["D", "G"],[4,5,6],[7,8,9],[10,'A'],["$",13,2]]
#2차 리스트에 핵심은 A[i]로 묶어서 봐야한다

#맨뒤 하나 제거
print(arr4.pop())         #[10, 'A']
print(arr4)

#원하는거 index를 이용해 제거
del arr4[1]      #[4,5,6] 제거
print(arr4)

#여러개 제거
print(arr4[::2])

#원하는 곳 value를 이용해 제거
arr4.remove([1,2,3])        #[1,2,3] 제거
#🧨🧨[1,2] 나 [1] 같이 arr4[i]에 포함되지 않은 것을 오류 뜬다 (x not in list)
print(arr4)
```

    ['$', 13, 2]
    [[1, 2, 3], ['D', 'G'], [4, 5, 6], [7, 8, 9], [10, 'A']]
    [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 'A']]
    [[1, 2, 3], [7, 8, 9]]
    [[4, 5, 6], [7, 8, 9], [10, 'A']]
    

#### list banned


```python
#원하는 조건 제거
print(list(x for x in arr3 if str(x).isalpha()))


#👍👍re+원하는 조건 제거하기
import re

str1 = 'AAsA@!#12A'
print([str1[i:i+2].lower() for i in range(0, len(str1)-1) if not re.findall('[^a-zA-Z]+', str1[i:i+2])])


#원하는 조건 제거에 del과 remove를 사용하지 않는 이유
#🧨🧨 del과 remove를 쓰면 리스트 자체에 영향을 주어 index가 줄어드는 문제가 발생!!
arr4 = [[1,2,3],["D", "G"],[4,5,6],[7,8,9],[10,'A'],["$",13,2]]
result = []

for index in range(len(arr4)):
    store = []
    for w in arr4[index]:
        if str(w).isdigit():
            store.append(w)
    result.append(store)
print(result)
```

    ['B', 'R', 'I']
    ['aa', 'as', 'sa']
    [[1, 2, 3], [], [4, 5, 6], [7, 8, 9], [10], [13, 2]]
    

## 5. 리스트 합과 max/min

#### list sum


```python
#정수로 합치기
#1차 행렬일때
print(sum([100, 140, 8 ,209]))

#2차 이상 고차행렬일때
r3 = [[1,[11,1,1],1],[1,1]]

def sum_list(lists, res = 0):
    for i in lists:
        #재귀함수를 이용해서 풀이
        if type(i) == list:
            res += sum_list(i)
        else:
            res += i
    return res

print(sum_list(r3))
```

    457
    17
    

#### list max/min


```python
#2차 리스트
s = [[1, 7, 12], [4, 7, 13], [1, 5, 17], [3, 5, 20], [2, 4, 24], [1, 4, 28], [3, 6, 37], [5, 6, 45], [2, 5, 62], [1, 2, 67], [5, 7, 73]]
#🧨🧨 2차 리스트일때, max는 s[i]중 최대값인줄 알았는데, [s[0][i], s[1][i], s[2][i]] 이런 값으로 나온다
#최대값 구하기
print(max(s), max(max(s)))

#🧨같은행 최대/소값 구하고 싶으면?
for x in s:
    print(max(x), end=" ")
print()

#최솟값 구하기
print(min(s), min(min(s)))
```

    [5, 7, 73] 73
    12 13 17 20 24 28 37 45 62 67 73 
    [1, 2, 67] 1
    


```python
#str[0]의 값의 크기를 기준으로
print(max(['abc','bd']))

#str 길이를 기준으로
print(max(['abc','bd', 's'], key = len))

#str[1]의 값의 크기를 기준으로
#🧨x[n]에서 길이가 n보다 작은 것이 있으면 (error : string index out of range)
print(max(['avc','bd', 'ss'], key = lambda x : x[1]))

#🧨조건문으로 활용가능
for x in range(3, -3, -1):
    print(max(x, 0), end= ' ')
```

    bd
    abc
    avc
    3 2 1 0 0 0 

## 6. 리스트 정렬

        key의 연산을 이용하는 경우
            1)x[1] - x[0]
            2)x[1]//x[0]
            3)...

### 문제유형


```python
#🧨lambda가 두개로 구분할때는 (선순위, 후순위)
#선수위가 같은 경우만 후순위로 넘어감!!
A = ["let1 art can","let4 own kit dig","let2 own kit dig","let3 art zero"]

print(sorted(A, key = lambda x : x.split()[0]))
print(sorted(A, key = lambda x : x.split()[1:]))
print(sorted(A, key = lambda x : (x.split()[1:], x.split()[0])))
```

    ['let1 art can', 'let2 own kit dig', 'let3 art zero', 'let4 own kit dig']
    ['let1 art can', 'let3 art zero', 'let4 own kit dig', 'let2 own kit dig']
    ['let1 art can', 'let3 art zero', 'let2 own kit dig', 'let4 own kit dig']
    


```python
#👍자리수를 문자로 늘려 3보다 30이 앞에 갈 수 있게 했다
print(sorted([3, 30, 34, 5, 9], key = lambda x : str(x)*3))
print(sorted([3, 30, 34, 5, 9], key = lambda x : x*4))
```

    [30, 3, 34, 5, 9]
    [3, 5, 9, 30, 34]
    


```python
##1차원 행렬 정렬
#정수 정렬
A1 = [3,5,1,2,6]
A1.sort()
print(A1)

#아스키 코드로 x[0]기준 오름차순
print(sorted(['masd', 'dssf', 'ensd', 'aks', '33','55','11','24','62']))

#x[i]의 길이순으로 오름차순
print(sorted(['masd', 'dssf', 'ensd', 'aks', '33','55','11','24','62'], key = len))

#x[i]의 아스키 코드중 가장 높은 값 기준
print(sorted(['masd', 'dssf', 'ensd', 'aks', '33','55','11','24','62'], key = max))
```

    [1, 2, 3, 5, 6]
    ['11', '24', '33', '55', '62', 'aks', 'dssf', 'ensd', 'masd']
    ['33', '55', '11', '24', '62', 'aks', 'masd', 'dssf', 'ensd']
    ['11', '33', '24', '55', '62', 'masd', 'dssf', 'ensd', 'aks']
    


```python
##2차원 행렬 정렬
#A[i][0]를 기준으로 정리한다. A[i]안에는 정렬x
A = [[9,7,8],[3,1,2],[6,4,5]]
print(sorted(A))

#🧨다른 것을 기준으로 하고 싶으면? 
#A[i][-1]를 기준으로 정리
print(sorted(A, key = lambda x : x[-1]))

#행렬 안과 전체 정렬
C = []
for array in A:
    C.append(sorted(array))    #행렬안 정렬
print(sorted(C))    #행렬 밖 정렬
```

    [[3, 1, 2], [6, 4, 5], [9, 7, 8]]
    [[3, 1, 2], [6, 4, 5], [9, 7, 8]]
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    

## 7. 리스트 count


```python
##복수 문자 일때
#여러 단어를 세기 위한 방법
a = ['q', 'w', 'w', 'q', 'q']
a_set = {'w', 'q'}
result = []
for x in a_set:
    result.append(a.count(x))

print(result)
```

    [2, 3]
    


```python
#👍count를 이용한 교집합,합집합 구하기
str1 = ["aa","aa","DA","TR"]
str2 = ["aa", "aa", "aa", "GR", "DA"]

union_set = set(str1)|set(str2)
interection_set = set(str1)&set(str2)

print(sum(list(min(str1.count(x), str2.count(x)) for x in interection_set))) #교집합
print(sum(list(max(str1.count(y), str2.count(y)) for y in union_set))) #합집합
```

    3
    6
    

## 8. 리스트 찾기

#### list searching


```python
#1차 리스트
#in 포함 여부만 확인
print(3 in [1,2,3,4,5,6,7])
print("3" not in [1,2,3,4,5,6,7])

#value를 이용한 index추출
print([1,2,3,4,5,6,7].index(3))

#index를 이용한 value 추출
print([1,2,3,4,5,6,7][2])

#반복문을 이용한 구현 (모든 경우에 사용가능)
for n in [1,2,3,4,5,6,7]:
    if n == 5:
        print(n)
        break
```

    True
    True
    2
    3
    5
    

#### bisect search


```python
#정렬된 경우 이분탐색 직접 구현
nums = [0,1,2,3,4,5,6,7,8,9]
search_n = 5 
result = -1 
start, end = 0, len(nums)-1 

while start <= end: 
    mid = (start+end) // 2 
    if nums[mid] >= n:
        result = mid
        end = mid - 1 
        
    else: 
        start = mid + 1
        
print(result)
```

    5
    


```python
from bisect import bisect_left, bisect_right 
nums1 = [0,1,2,3,4,5,6,7,8,9]
print(bisect_left(nums1, 5), bisect_right(nums1, 5)) 

nums2 = [4, 5, 5, 5, 5, 5, 5, 5, 5, 6]
print(bisect_left(nums2, 5), bisect_right(nums2, 5)) 
```

    5 6
    1 9
    


```python
#특정범위에 안에 있는 숫자 구하기
#5~7안에 있는 갯수
from bisect import bisect_left, bisect_right 

def calCountsByRange(nums, left_value, right_value): 
    r_i = bisect_right(nums, right_value) 
    l_i = bisect_left(nums, left_value) 
    return r_i - l_i 

print(calCountsByRange(sorted([-1, -3, 5, 5, 4, 7, 1, 7, 2, 5, 6]), 5, 7))
```

    6
    
