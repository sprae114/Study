-   데이터 접근기술 시작  
    
    -   데이터 접근 기술 진행 방식 소개  
        
        -   SQL Mapper  
            -   SQL만 작성하면 해당 SQL의 결과를 객체로 편리하게 매핑  
                
        
        -   ORM  
            -   기본적인 SQL은 JPA가 대신 작성하고 처리  
                
    
    -   프로젝트 구조 설명1 - 기본  
        -   코드로 설명하기  
            
            -   ItemRepository 인터페이스  
                -   ItemUpdateDto와 ItemSearchCond의 역할은 무엇일까?  
                    
                    -   DTO가 사용되는 이유는 무엇일까?  
                        -   데이터를 수정하는 경우 기존 데이터와 바꿀데이터 2가지가 있어야 한다. 이때 바꿀 데이터를 의미하는 것이 DTO.  
                            
                    
                    -   DTO 위치 어떻게 해야할까?  
                        -   마지막으로 쓰는 코드가 어디인지 알고난 후 그 패키지에 넣기  
                            
                            -   controller -> Service -> Repository순으로 동작한다.  
                                
                            
                            -   지금은 Repository에서 마지막으로 호출 되었기 때문에 Repository패키지에 넣는 것이 타당함.  
                                
                    
                    -   ItemUpdateDto  
                        
                        -   상품을 수정할 때 사용하는 객체  
                            
                        
                        -   단순히 데이터를 전달하는 용도로 사용되므로 DTO.  
                            
                        
                        -   그래서 set은 불가능하게 설정함.  
                            
                    
                    -   ItemSearchCond  
                        -   검색 조건으로 사용되는 객체  
                            
            
            -   MemoryItemRepository  
                -   findAll  
                    -   ItemSearchCond 이라는 검색 조건을 받아서 내부에서 데이터를 검색하는 기능  
                        
            
            -   ItemService  
                -   서비스에 인터페이스를 잘 도입하지는 않는다. => 순수 자바코드로 작성되어있기 때문  
                    
            
            -   ItemController  
                -   MVC 1편 내용 참고  
                    
    
    -   프로젝트 구조 설명2 - 설정  
        -   코드로 보기  
            
            -   MemoryConfig  
                -   서비스와 리포지토리는 구현체를 편리하게 변경하기 위해, 이렇게 수동으로 빈을 등록  
                    
            
            -   TestDataInit  
                
                -   애플리케이션을 실행할 때 초기 데이터를 저장  
                    
                
                -   @ EventListener vs @ PostConstruct  
                    
                    -   @ EventListener -> AOP를 포함한 스프링 컨테이너가 완전히 초기화 된 이후에 호출함.  
                        
                    
                    -   @ PostConstruct -> AOP 같은 부분이 아직 다 처리되지 않은 시점에 호출될 수 있기 때문에, 간혹 문제가 발생할 수 있다  
                        
            
            -   ItemServiceApplication  
                
                -   scanBasePackages -> 컴포넌트 범위 설정  
                    
                
                -   @ Profile  
                    
                    -   특정 프로필의 경우에만 해당 스프링 빈을 등록한다.  
                        
                    
                    -   프로필 2가지 종류  
                        
                        -   main 프로필  
                            
                            -   자바 객체를 실행할 때 (주로 main() ) 동작하는 스프링 설정  
                                
                            
                            -   사용법![](https://api.transno.com/v3/document_image/8a57ffe0-625a-49dd-ac74-311170b1e6a1-10826299.jpg)  
                                
                        
                        -   test 프로필  
                            
                            -   테스트 케이스를 실행할 때 동작한다  
                                
                            
                            -   사용법![](https://api.transno.com/v3/document_image/fd390b6d-29b5-48bd-a5b5-53df623fbf49-10826299.jpg)  
                                
                    
                    -   왜 test프로필을 사용했을까?  
                        
                        -   main 프로필 테스트 케이스를 실행할 때는 문제가 될 수 있다.  
                            
                        
                        -   예를 들어서 데이터를 하나 저장하고 전체 카운트를 확인하는데 1이 아니라 testDataInit 때문에 데이터가 2건 추가되어서 3이 되는 것이다.  
                            
    
    -   프로젝트 구조 설명3 - 테스트  
        -   코드로 보기  
            -   ItemRepositoryTest  
                
                -   인터페이스를 테스트하자  
                    
                
                -   검증 테스트를 어떻게 해야되는지![](https://api.transno.com/v3/document_image/3c7f8159-5d45-4295-ab66-711fcf49a70a-10826299.jpg)  
                    
    
    -   데이터베이스 테이블 생성  
        
        -   item 테이블 생성  
            -   generated by default as identity  
                -   identity 전략이고 하는데, 기본 키 생성을 데이터베이스에 위임하는 방법이다. MySQL의 Auto Increment와 같은 방법이다.  
                    
        
        -   식별자 선택 전략  
            
            -   기본키 필수조건 3가지  
                
                -   1. null 값은 허용하지 않는다.  
                    
                
                -   2. 유일해야 한다.  
                    
                
                -   3. 변해선 안 된다.  
                    
            
            -   선택하는 전략은 2가지  
                
                -   자연 키(natural key)  
                    
                    -   비즈니스에 의미가 있는 키  
                        
                    
                    -   예: 주민등록번호, 이메일, 전화번호  
                        
                
                -   대리 키(surrogate key) -> 선호  
                    
                    -   비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로도 불린다.  
                        
                    
                    -   예: 오라클 시퀀스, auto_increment, identity, 키생성 테이블 사용  
                        
-   JdbcTemplate  
    
    -   소개와 설정  
        -   JdbcTemplate  
            
            -   장점  
                
                -   설정의 편리함  
                    -   별도의 복잡한 설정 없이 바로 사용  
                        
                
                -   반복 문제 해결  
                    
                    -   커넥션 획득  
                        
                    
                    -   statement 를 준비하고 실행  
                        
                    
                    -   결과를 반복하도록 루프를 실행  
                        
                    
                    -   커넥션 종료, statement , resultset 종료  
                        
                    
                    -   트랜잭션 다루기 위한 커넥션 동기화  
                        
                    
                    -   예외 발생시 스프링 예외 변환기 실행  
                        
            
            -   단점  
                -   동적 SQL을 해결하기 어렵다.  
                    
    
    -   기본  
        
        -   JdbcTemplate을 사용해서 데이터베이스에 저장하기  
            
        
        -   코드로 보기  
            -   JdbcTemplateItemRepositoryV1  
                
                -   dataSource 를 의존 관계 주입 받고 생성자 내부에서 JdbcTemplate 을 생성![](https://api.transno.com/v3/document_image/bd7c9de9-072a-455c-8040-dc1ec2014672-10826299.jpg)  
                    
                
                -   save  
                    
                    -   코드![](https://api.transno.com/v3/document_image/ef648f4e-74bb-4843-8279-6673ceb923b8-10826299.jpg)  
                        template.update에서 왜 파라미터가 두개지?  
                        그리고 형태가 원래 update(sql, ?갯수만큼 )인데 이건...  
                        자동키 증가때문에 어쩔수 없는 경우...  
                        
                    
                    -   1. 순서를 이용한 SQL  
                        
                    
                    -   2. new GeneratedKeyHolder()를 이용해 DB에서 자동으로 ID값을 생성하기.  
                        
                    
                    -   3. keyHolder로 DB에서 ID값 가져와서 반환  
                        
                
                -   findByID  
                    
                    -   코드![](https://api.transno.com/v3/document_image/f93f4437-58b2-4668-a9d5-65943bb6301a-10826299.jpg)  
                        
                    
                    -   optional 부분은 자바 정리에서 확인하기  
                        
                
                -   findAll  
                    -   이 부분은 어쩌피 나중에 교체되어서(실수도 많고 너무 복잡함) 간단하게 나타낼 수 있다는 것만 알아두기  
                        
                
                -   RowMapper  
                    
                    -   ResultSet에 값을 담아와서 User 객체에 저장  
                        
                    
                    -   [RowMapper에 대해! (velog.io)](https://velog.io/@seculoper235/RowMapper%EC%97%90-%EB%8C%80%ED%95%B4)  
                        
    
    -   동적 쿼리 문제  
        -   사용자가 검색하는 값에 따라서 실행하는 SQL이 동적으로 달려져야 한다는 점  
            -   sql 예시![](https://api.transno.com/v3/document_image/722891ff-9674-4861-aede-962b27c75267-10826299.jpg)  
                
    
    -   이름 지정 파라미터 1,2,3  
        
        -   JdbcTemplate을 기본으로 사용하면 파라미터를 순서대로 바인딩되는 문제점  
            -   why? 누군가 SQL 코드의 순서를 변경했다고 가정하면 심각한 오류에 빠짐  
                
        
        -   그래서 NamedParameterJdbcTemplate 라는 이름을 지정해서 파라미터를 바인딩 하는 기능을 제공함.  
            
        
        -   이름 지정 바인딩 파라미터 3종류  
            
            -   Map  
                -   코드![](https://api.transno.com/v3/document_image/534bf7ca-a8b3-47fe-afce-c7517b7727c7-10826299.jpg)  
                    
            
            -   MapSqlParameterSource  
                
                -   코드![](https://api.transno.com/v3/document_image/c2f0d45f-7603-44a5-8ef7-4164922c101c-10826299.jpg)  
                    
                
                -   Map 과 유사한데, SQL 타입을 지정할 수 있는 등 SQL에 좀 더 특화된 기능을 제공  
                    
            
            -   BeanPropertySqlParameterSource  
                
                -   코드![](https://api.transno.com/v3/document_image/64fc1a0a-fd7c-4a47-b9e0-6350be33ee9b-10826299.jpg)  
                    
                
                -   자바빈 프로퍼티 규약을 통해서 자동으로 파라미터 객체를 생성한다.  
                    
                
                -   예) ( getXxx() -> xxx, getItemName() -> itemName )  
                    
                
                -   BeanPropertySqlParameterSource를 사용할 수 없는 경우![](https://api.transno.com/v3/document_image/5d40b58d-213f-490e-8b8f-74ab0c86276d-10826299.jpg)![](https://api.transno.com/v3/document_image/cf6f517f-3fd7-4cf2-8035-5be7847b4236-10826299.jpg)  
                    DTO에 경우에는 id가 존재하지 않아서 별도로 필요하다. 그래서 이 함수를 사용할 수가 없음.
                
                -     
                    
        
        -   코드로 보기  
            -   JdbcTemplateItemRepositoryV2  
                
                -   save  
                    
                    -   코드![](https://api.transno.com/v3/document_image/f9f79d71-d965-4f10-b840-54af21715540-10826299.jpg)  
                        
                    
                    -   SQL 바뀐 부분![](https://api.transno.com/v3/document_image/88a1cd35-a732-4295-b5c5-3cfff9117744-10826299.jpg)  
                        
                    
                    -   [SqlParameterSource](https://velog.io/@lacomaco/Spring-Jdbc-Template-%EC%8B%A4%EC%8A%B5-%EC%A0%95%EB%A6%AC)는 Sql에 들어갈 parameter Map 객체를 처리하는 인터페이스  
                        
                    
                    -   sql에 + 부분은 가독성을 위해서 나눠준거임  
                        
                
                -   itemRowMapper  
                    
                    -   바뀌기 전![](https://api.transno.com/v3/document_image/78e39657-9fdb-40df-9c85-aae9737a9126-10826299.jpg)  
                        
                    
                    -   바뀐 이후![](https://api.transno.com/v3/document_image/72e45799-6f60-4ea5-a7a9-88ad5e109b5a-10826299.jpg)  
                        
                    
                    -   BeanPropertyRowMapper 는 ResultSet 의 결과를 받아서 자바빈 규약에 맞추어 데이터를 변환함.  
                        
                    
                    -   IF 자바빈 규약이 아닌 스네이크 기법으로 한다면 어떻게 해야할까?  
                        
                        -   이정도는 자동으로 변환 해준다.  
                            
                        
                        -   그래도 문제가 되는 경우 별칭을 사용하여 이름을 바꿔준다. ![](https://api.transno.com/v3/document_image/559ac4ad-074e-49cc-bfa9-2ebb33f4bde5-10826299.jpg)  
                            
        
        -   테스트는 직접 가서 보기  
            
    
    -   SimpleJdbcInsert기능 정리  
        
        -   JdbcTemplate은 INSERT SQL만!! 직접 작성하지 않아도 되도록 SimpleJdbcInsert 라는 편리한 기능을 제공  
            
        
        -   코드로 보기  
            
            -   this.jdbcInsert = new SimpleJdbcInsert(dataSource) 주입해주기  
                
            
            -   save  
                
                -   바뀌기전![](https://api.transno.com/v3/document_image/38994976-fedc-4290-add9-7fb489ddc611-10826299.jpg)  
                    
                
                -   바뀐 후![](https://api.transno.com/v3/document_image/23ff85d5-2fc8-444b-b4c3-9cd869830fc3-10826299.jpg)  
                    
    
    -   JdbcTemplate 기능 정리  
        
        -   주요 기능  
            
            -   JdbcTemplate  
                -   순서 기반 파라미터 바인딩을 지원한다.  
                    
            
            -   NamedParameterJdbcTemplate -> 선호  
                -   이름 기반 파라미터 바인딩을 지원한다.  
                    
            
            -   SimpleJdbcInsert  
                -   INSERT SQL을 편리하게 사용할 수 있다.  
                    
            
            -   SimpleJdbcCall  
                -   스토어드 프로시저를 편리하게 호출할 수 있다.  
                    -   [[MySQL] 스토어드 프로시저(Stored Procedure) 기본 (tistory.com)](https://spiderwebcoding.tistory.com/7)  
                        
        
        -   JdbcTemplate 사용법 정리  
            
            -   [람다식 만들기](https://www.youtube.com/watch?v=3wnmgM4qK30)  
                -   타입, 함수명, 리턴 지우기  
                    
            
            -   단건 조회  
                
                -   단건 조회 - 숫자 조회![](https://api.transno.com/v3/document_image/c29242d4-8253-4a40-bcc2-66eaabc2c5f4-10826299.jpg)  
                    조회 대상이 객체가 아니라 단순 데이터 하나라면 타입을 Integer.class , String.class 와 같이 지정
                
                -   단건 조회 - 숫자 조회, 파라미터 바인딩![](https://api.transno.com/v3/document_image/cf6c5b13-c7c5-4f94-9399-2dc36d4c6469-10826299.jpg)  
                    
                
                -   단건 조회 - 문자 조회![](https://api.transno.com/v3/document_image/afbf5669-c77c-4223-b800-b00e96873720-10826299.jpg)  
                    
                
                -   단건 조회 - 객체 조회![](https://api.transno.com/v3/document_image/59a5e1b3-81e2-427e-a982-5dbdd8e1af0f-10826299.jpg)  
                    결과를 객체로 매핑해야 하므로 RowMapper 를 사용함.
            
            -   목록 조회  
                
                -   목록 조회 - 객체![](https://api.transno.com/v3/document_image/ce85903a-cdb0-47ab-b463-9bfbeb427260-10826299.jpg)  
                    
                
                -   목록 조회 - 객체![](https://api.transno.com/v3/document_image/00246852-1779-4840-ba4c-c7ae111edab0-10826299.jpg)  
                    
            
            -   변경(INSERT, UPDATE, DELETE)  
                
                -   등록![](https://api.transno.com/v3/document_image/02693bb3-6367-4fe0-9144-8a3c3c42524f-10826299.jpg)  
                    
                
                -   수정![](https://api.transno.com/v3/document_image/e4dd9240-9b71-479a-9704-c452ff137086-10826299.jpg)  
                    
                
                -   삭제![](https://api.transno.com/v3/document_image/6672e26b-e20f-42c8-8ac9-5fc692dc3434-10826299.jpg)  
                    
                
                -   DDL![](https://api.transno.com/v3/document_image/42263dbb-f343-4c9d-a227-73bfc3b7075d-10826299.jpg)  
                    
-   테스트  
    
    -   데이터베이스 연동  
        
        -   데이터베이스에 연동하는 테스트를 해보자  
            
        
        -   설정은 직접가서 보기  
            
        
        -   테스트의 문제점  
            -   H2 데이터베이스에 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문에 현재 테스트에 영향을 준다.  
                
    
    -   데이터베이스 분리  
        
        -   테스트 전용 데이터베이스를 별도로 운영하기  
            
        
        -   사용방법  
            
            -   1) 데이터베이스 용도 구별하기  
                
                -   jdbc:h2:tcp://localhost/~/test local에서 접근하는 서버 전용 데이터베이스  
                    
                
                -   jdbc:h2:tcp://localhost/~/testcase test 케이스에서 사용하는 전용 데이터베이스  
                    
            
            -   2)데이터베이스 파일 생성 방법  
                
                -   데이터베이스 서버를 종료하고 다시 실행한다.  
                    
                
                -   사용자명은 sa 입력  
                    
                
                -   JDBC URL에 다음 입력,  
                    
                
                -   jdbc:h2:~/testcase (최초 한번)  
                    
                
                -   ~/testcase.mv.db 파일 생성 확인  
                    
                
                -   이후부터는 jdbc:h2:tcp://localhost/~/testcase 이렇게 접속  
                    
            
            -   3)테이블 생성하기  
                
            
            -   4) 접속 정보 변경  
                -   test - application. properties![](https://api.transno.com/v3/document_image/883deb6d-a3d3-497a-a9cd-de6c018f6312-10826299.jpg)  
                    
        
        -   문제점  
            -   별도로 운영하지만 반복해서 실행할 수 없음 => 데이터 롤백하자  
                
    
    -   데이터 롤백  
        
        -   테스트가 끝나고 나서 트랜잭션을 강제로 롤백해버리면 데이터가 깔끔하게 제거된다  
            -   why? 지우기 않고 롤백하는 이유는?  
                -   테스트가 실행되는 도중에 예외가 발생하거나 애플리케이션이 종료되어 버려서 테스트 종료 시점에 DELETE SQL 을 호출하지 못할 수 도 있다!  
                    
        
        -   코드로 보기  
            
            -   @ BeforeEach  
                -   트랜잭션 시작하기 => transactionManager.getTransaction(new DefaultTransactionDefinition())  
                    
            
            -   @ AfterEach  
                -   트랜잭션을 롤백하기 => transactionManager.rollback(status)  
                    
    
    -   @ Transactional  
        
        -   롤백하는 방식을 @ Transactional 애노테이션 하나로 깔끔하게 해결  
            
        
        -   @ Transactional 의 원리  
            
            -   그림으로 이해하기![](https://api.transno.com/v3/document_image/2935784b-902e-4a8c-9ea4-5616c0bcd42c-10826299.jpg)  
                
            
            -   1. @ Transactional 애노테이션이 테스트 메서드나 클래스에 있으면 먼저 트랜잭션을 시작  
                
            
            -   2. 테스트를 로직을 실행한다. 테스트가 끝날 때 까지 모든 로직은 트랜잭션 안에서 수행  
                
            
            -   3. @ Transactional 이 테스트에 있으면 테스트가 끝날때 트랜잭션을 강제로 롤백  
                
        
        -   강제로 커밋하기  
            -   @ Commit을 붙이면 커밋할 수 있음  
                
    
    -   임베디드 모드  
        
        -   DB를 JVM안에서 메모리 모드로 포함해서 애플리케이션과 함께 실행함.  
            
        
        -   임베디드 모드 직접 사용하는 방법  
            
            -   1) ItemServiceApplication - 빈 추가 => 메모리 DB 환경 설정하기![](https://api.transno.com/v3/document_image/22ae2878-3c4a-441f-b11f-8ffab87371a5-10826299.jpg)  
                
            
            -   2)메모리 DB에 테이블 생성하기![](https://api.transno.com/v3/document_image/75f6f20f-16e8-4261-b4ee-b9f671413a07-10826299.jpg)  
                
    
    -   DB스프링 부트와 임베디드 모드  
        
        -   스프링 부트는 데이터베이스에 대한 별다른 설정이 없으면 임베디드 데이터베이스를 사용함  
            
        
        -   그 전까지 설정한 직접설정은 주석처리하기  
            
-   MyBatis  
    
    -   소개  
        
        -   MyBatis를 쓰는 이유?  
            -   SQL을 XML에 편리하게 작성하도록 도와줌 (특히 동적쿼리)  
                
        
        -   JdbcTemplate와 MyBatis의 차이는?  
            
            -   SQL 여러줄일때  
                
                -   JdbcTemplate![](https://api.transno.com/v3/document_image/185906a4-91f2-46cc-b0aa-9348519e00e7-10826299.jpg)  
                    
                
                -   MyBatis![](https://api.transno.com/v3/document_image/d8843ca4-65ac-402f-a0d6-133c2d497e95-10826299.jpg)  
                    
            
            -   SQL 여러줄일때  
                
                -   JdbcTemplate![](https://api.transno.com/v3/document_image/1cd36cd4-fe3e-4985-b1cd-b0f0b82eaaf9-10826299.jpg)  
                    
                
                -   MyBatis![](https://api.transno.com/v3/document_image/38463b6a-28aa-45c6-8bb1-4511ebcdf84d-10826299.jpg)![](https://api.transno.com/v3/document_image/d81a6589-df51-4a00-b53b-8a592ea9cc2a-10826299.jpg)  
                    
    
    -   설정  
        -   의존관계 설정 및 properties 설정 해야함  
            
    
    -   적용1 - 기본  
        -   코드로 보기  
            
            -   ItemMapper  
                -   마이바티스 매핑 XML을 호출해주는 매퍼 인터페이스  
                    
            
            -   ItemMapper.xml  
                
                -   사실상 거의 구현체  
                    
                
                -   같은 위치에 실행할 SQL이 있는 XML 매핑 파일을 만들어야함.  
                    
                
                -   insert - save  
                    
                    -   코드![](https://api.transno.com/v3/document_image/c6d5f35b-4fe6-4b07-80e9-5314c607075c-10826299.jpg)  
                        
                    
                    -   useGeneratedKeys 는 데이터베이스가 키를 생성해 주는 IDENTITY 전략일 때 사용  
                        
                    
                    -   파라미터는 # {} 문법을 사용  
                        
                
                -   update - update  
                    
                    -   코드![](https://api.transno.com/v3/document_image/4f9fb074-3ece-4911-9785-b052f2f49873-10826299.jpg)![](https://api.transno.com/v3/document_image/688717f0-0d31-4a66-a59d-c5d8acff7490-10826299.jpg)  
                        
                    
                    -   파라미터가 2개 이상이면 @ Param 으로 이름을 지정해서 파라미터를 구분 해야함  
                        
                
                -   select - findById  
                    
                    -   코드![](https://api.transno.com/v3/document_image/f962b991-38b1-4b7f-b887-f65ae0c3a7a6-10826299.jpg)  
                        
                    
                    -   resultType 은 반환 타입을 명시하면 된다. 여기서는 결과를 Item 객체에 매핑함.  
                        
                    
                    -   반환 객체가 하나이면 Item , Optional 과 같이 사용하면 되고, 반환 객체가 하나이상이면 컬렉션을 사용하면 된다. 주로 List 를 사용함.  
                        
                
                -   select - findAll  
                    
                    -   코드![](https://api.transno.com/v3/document_image/7ff4dca5-0558-479e-be26-dd652a9c3cae-10826299.jpg)![](https://api.transno.com/v3/document_image/4347845f-db0b-4847-9477-102543ea1cf1-10826299.jpg)  
                        
                    
                    -   <if>, <where>같은 동적 쿼리 문법을 통해 편리한 동적 쿼리를 지원한다.  
                        
                    
                    -   <where>은 적절하게 where 문장을 만들어준다.  
                        
                        -   <if>가 모두 실패하게 되면 SQL where 를 만들지 않는다.  
                            
                        
                        -   <if>가 하나라도 성공하면 처음 나타나는 and 를 where 로 변환해준다.  
                            
                
                -   XML 특수문자  
                    
                    -   XML에서는 데이터 영역에 < , > 같은 특수 문자를 사용할 수 없음  
                        
                    
                    -   특수문자![](https://api.transno.com/v3/document_image/f1e91e87-1f57-4f6c-a052-877a55ebde96-10826299.jpg)  
                        
                    
                    -   CDATA![](https://api.transno.com/v3/document_image/f4bdfaec-3762-4244-b237-a7ee859357ff-10826299.jpg)  
                        
    
    -   적용2 - 설정과 실행  
        -   보면서 따라해보자  
            
    
    -   적용3 - 분석  
        -   ItemMapper 매퍼 인터페이스의 구현체가 없는데 어떻게 동작한 것일까?  
            
            -   MyBatis 스프링 연동 모듈에서 자동으로 처리  
                
            
            -   과정  
                
                -   그림![](https://api.transno.com/v3/document_image/489a2e98-ee79-4109-a65b-5c79aea061f8-10826299.jpg)  
                    
                
                -   매커니즘  
                    
                    -   1. 애플리케이션 로딩 시점에 MyBatis 스프링 연동 모듈은 @Mapper 가 붙어있는 인터페이스를 조사한다.  
                        
                    
                    -   2. 해당 인터페이스가 발견되면 동적 프록시 기술을 사용해서 ItemMapper 인터페이스의 구현체를 만든다.  
                        
                    
                    -   3. 생성된 구현체를 스프링 빈으로 등록한다.  
                        
    
    -   기능 정리1 - 동적 쿼리  
        
        -   if -> 해당 조건에 따라 값을 추가할지 말지 판단![](https://api.transno.com/v3/document_image/56728742-8919-489c-b065-c3e184f953d5-10826299.jpg)  
            
        
        -   choose, when, otherwise -> 자바의 switch와 비슷![](https://api.transno.com/v3/document_image/acdceba1-34b4-466e-aea1-d734a947797c-10826299.jpg)  
            
        
        -   trim, where -> if에서 처음에 And가 나오는 문제를 해결하기 위함![](https://api.transno.com/v3/document_image/5b37bfff-14a1-4d2c-8b16-8c61762a3397-10826299.jpg)![](https://api.transno.com/v3/document_image/8e1ead51-5fba-41c6-8526-b85a5a9aa0ec-10826299.jpg)  
            
        
        -   foreach -> 컬렉션을 반복 처리할 때 사용한다. where in (1,2,3,4,5,6) 와 같은 문장을 쉽게 완성![](https://api.transno.com/v3/document_image/13f0e80a-cb3b-4161-989b-ee54e6ea80c8-10826299.jpg)  
            
    
    -   기능 정리2 - 기타 기능  
        
-   JPA  
    
    -   ORM 개념  
        -   SQL 중심적인 개발의 문제점  
            -   패러다임의 불일치  
                
                -   객체와 관계형 데이터베이스의 차이  
                    
                    -   1. 상속![](https://api.transno.com/v3/document_image/163bd85f-3c65-44dd-a947-80e77a1303a0-10826299.jpg)  
                        -   테이블은 상속이 존재하지 X  
                            
                    
                    -   2. 연관관계![](https://api.transno.com/v3/document_image/bc7eb5e0-230a-4477-a74c-980800904a39-10826299.jpg)  
                        
                        -   객체는 참조를 사용  
                            
                        
                        -   테이블은 외래 키를 사용  
                            
                    
                    -   3. 객체 그래프 탐색  
                        
                
                -   객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까? => JPA 등장  
                    
                
                -   ORM  
                    
                    -   그림![](https://api.transno.com/v3/document_image/8104f991-e315-4377-85c8-7379fb03b128-10826299.jpg)  
                        
                    
                    -   객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스대로 설계 하지만 ORM 프레임워크가 중간에서 매핑함  
                        
    
    -   개발 및 분석  
        -   객체와 테이블을 매핑해보자  
            
            -   Item - ORM  
                
                -   코드로보기![](https://api.transno.com/v3/document_image/d61df971-243d-426f-9d43-e83a58a11eec-10826299.jpg)  
                    
                
                -   @ Entity  
                    -   JPA가 사용하는 객체  
                        
                
                -   @ Id  
                    -   테이블의 PK와 해당 필드를 매핑  
                        
                
                -   @ GeneratedValue(strategy = GenerationType.IDENTITY)  
                    -   PK 생성 값을 데이터베이스에서 생성하는 IDENTITY 방식을 사용  
                        
                
                -   @ Column  
                    -   객체의 필드를 테이블의 컬럼과 매핑  
                        
            
            -   JpaItemRepositoryV1  
                
                -   코드로 보기![](https://api.transno.com/v3/document_image/9e8b85d8-6cd0-44fa-8bd1-7c3297420e04-10826299.jpg)  
                    
                
                -   private final EntityManager em  
                    
                    -   JPA의 모든 동작은 엔티티 매니저를 통해서 이루어진다.  
                        
                    
                    -   엔티티매니저는 내부에 데이터소스를 가지고 있고, 데이터베이스에 접근할 수 있다.  
                        
                
                -   @ Transactional  
                    
                    -   JPA의 모든 데이터 변경(등록, 수정, 삭제)은 트랜잭션 안에서 이루어져야 한다. 조회는 없어도 가능  
                        
                    
                    -     
                        
                
                -   save()  
                    -   em.persist(item)  
                        -   JPA에서 객체를 테이블에 저장할 때 사용  
                            
                
                -   update()  
                    
                    -   JPA는 트랜잭션이 커밋되는 시점에, 변경된 엔티티 객체가 있는지 확인 가능  
                        
                    
                    -   트랜잭션 커밋 시점에 JPA가 변경된 엔티티 객체를 찾아서 UPDATE SQL을 수행한다고 이해  
                        
                
                -   findById()  
                    -   엔티티 객체를 PK를 기준으로 조회할 때 사용  
                        
                
                -   findAll - 목록 조회  
                    
                    -   코드로 보기![](https://api.transno.com/v3/document_image/12321da6-1c35-4029-a8bf-2ecee06a9222-10826299.jpg)  
                        
                    
                    -   JPQL  
                        
                        -   객체지향 쿼리 언어로 주로 여러 데이터를 복잡한 조건으로 조회할 때 사용  
                            
                        
                        -   SQL이 테이블을 대상으로 한다면, JPQL은 엔티티 객체를 대상으로 SQL을 실행한다 생각하면 된다.  
                            
    
    -   예외 변환  
        
        -   EntityManager 는 순수한 JPA 기술이고, 스프링과는 관계가 없다. 그래서 JPA 관련 예외를 발생.  
            
        
        -   스프링이 JPA 예외 -> 스프링 예외 로 변환해주는 원리는?  
            
            -   @ Repository  
                
                -   1. 컴포넌트 스캔의 대상  
                    
                
                -   2. 예외 변환 AOP의 적용 대상  
                    
            
            -   예외 변환전![](https://api.transno.com/v3/document_image/0c0270d8-30f9-4a01-9236-bf91c2be64c3-10826299.jpg)  
                
            
            -   예외 변환후![](https://api.transno.com/v3/document_image/d00544cd-3239-4782-8928-de5e9808f82c-10826299.jpg)  
                
-   스프링 데이터 JPA  
    
    -   [[JPA] 객체지향 쿼리, JPQL](https://ict-nroo.tistory.com/116)  
        
    
    -   소개  
        
        -   기능  
            
            -   CRUD+쿼리  
                
            
            -   동일한 인터페이스  
                
            
            -   메서드 이름으로 쿼리생성  
                
            
            -   페이징 처리  
                
            
            -   스프링 MVC에서 id값만 넘겨도 도메인 클래스로 바인딩  
                
        
        -   JPA 도입 전 이해도테스트  
            
            -   본인이 작성한 JPQL이 어떤 쿼리로 생성 될지 이해해야함.  
                
            
            -   즉시,지연로딩 전략이해  
                
            
            -   영속성 컨텍스트 이해  
                
            
            -   변경 감지  
                
            
            -   언제 영속성 컨텍스트가 플러시 되는가  
                
            
            -   연관관계 매핑중에 mappedBy(inverse) 이해  
                
            
            -   JPQL 한계 인식  
                
    
    -   주요 기능  
        
        -   스프링 데이터 JPA는 JPA를 편리하게 사용할 수 있도록 도와주는 라이브러리  
            
        
        -   공통 인터페이스 기능  
            
            -   그림![](https://api.transno.com/v3/document_image/f2b0d0ca-1340-4d3f-93b1-3d618509859b-10826299.jpg)  
                
            
            -   코드 -> JpaRepository 인터페이스를 통해서 기본적인 CRUD 기능 제공![](https://api.transno.com/v3/document_image/7901ac50-93b2-4174-9997-f75bc6b77976-10826299.jpg)  
                
            
            -   구현체는?  
                -   스프링 데이터 JPA가 프록시 기술을 사용해서 구현 클래스를 만들어줌![](https://api.transno.com/v3/document_image/e8c787d6-985b-4066-8ed8-a731754597fa-10826299.jpg)  
                    
        
        -   쿼리 메서드 기능  
            
            -   코드 -> 메서드 이름을 분석해서 쿼리를 자동으로 만들고 실행해주는 기능![](https://api.transno.com/v3/document_image/9cfd2e73-0c6b-4d43-b456-fa18a888e3e5-10826299.jpg)  
                
            
            -   메소드 만드는 규칙  
                -   [스프링 데이터 JPA 메소드 만드는 규칙](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)![](https://api.transno.com/v3/document_image/8a466eb3-1f4c-4094-93c9-ee43c5d616e3-10826299.jpg)  
                    
            
            -   직접 JPQL을 사용하고 싶을 때는 @ Query 와 함께 JPQL을 작성  
                
    
    -   적용  
        -   코드로 보기  
            
            -   SpringDataJpaItemRepository  
                
                -   코드![](https://api.transno.com/v3/document_image/66c900de-54ac-4209-83b5-c18b3c7029f4-10826299.jpg)  
                    
                
                -   함수 예시  
                    
                    -   모든 데이터 조회![](https://api.transno.com/v3/document_image/fa77ed5f-c3d1-4026-9ee8-3f09f5e2c203-10826299.jpg)  
                        
                    
                    -   이름 조회![](https://api.transno.com/v3/document_image/05a08529-ad6a-4a87-b868-16c0d6de8b3d-10826299.jpg)  
                        
                    
                    -   가격 조회![](https://api.transno.com/v3/document_image/e2c15b5e-72eb-4b36-aff5-21951f6b7720-10826299.jpg)  
                        
                    
                    -   이름 + 가격 조회![](https://api.transno.com/v3/document_image/ae02ad3e-4f91-44b6-b44f-bdae7dc677f7-10826299.jpg)  
                        
            
            -   JpaItemRepositoryV2  
                
                -   코드![](https://api.transno.com/v3/document_image/4370c762-d06c-4660-9f48-f8e1f26064bb-10826299.jpg)  
                    
                
                -   ItemService 는 ItemRepository 에 의존하기 때문에 SpringDataJpaItemRepository 를 다음과 같이 사용함  
                    -   어떤 효과가 있는거야?  
                        -   중간에서 JpaItemRepository 가 어댑터 역할을 해준 덕분에 인터페이스를 그대로 유지할 수 있음![](https://api.transno.com/v3/document_image/da9f24c5-f686-443e-9ac7-3515c808feb4-10826299.jpg)  
                            
                
                -   함수 예시  
                    
                    -   save![](https://api.transno.com/v3/document_image/3d1630f4-4c06-4c80-bd2f-527ea7b58581-10826299.jpg)  
                        
                    
                    -   update -> commit 될때 데이터 베이스가 반영됌![](https://api.transno.com/v3/document_image/837d28ec-9aec-43d4-a2bc-50a81ac87ea0-10826299.jpg)  
                        
                    
                    -   findById![](https://api.transno.com/v3/document_image/666b31bd-644d-4acc-8c0c-6825269f8bd7-10826299.jpg)  
                        
                    
                    -   이전 내용  
                        
                        -   모든 데이터 조회![](https://api.transno.com/v3/document_image/fa77ed5f-c3d1-4026-9ee8-3f09f5e2c203-10826299.jpg)  
                            
                        
                        -   이름 조회![](https://api.transno.com/v3/document_image/05a08529-ad6a-4a87-b868-16c0d6de8b3d-10826299.jpg)  
                            
                        
                        -   가격 조회![](https://api.transno.com/v3/document_image/e2c15b5e-72eb-4b36-aff5-21951f6b7720-10826299.jpg)  
                            
                        
                        -   이름 + 가격 조회![](https://api.transno.com/v3/document_image/ae02ad3e-4f91-44b6-b44f-bdae7dc677f7-10826299.jpg)  
                            
-   Querydsl  
    
    -   소개  
        
        -   정의  
            -   쿼리에 특화된 프로그래밍 언어  
                
        
        -   문제점  
            -   QUREY는 문자여서 실행하기 전까지는 Type-check 불가능함  
                
        
        -   장점  
            
            -   Type-safe  
                -   컴파일시 에러 체크 가능  
                    
            
            -   code assistant  
                -   동적쿼리 작성 도와줌  
                    
    
    -   설정  
        -   직접 찾아보면서 하기  
            
    
    -   적용  
        -   코드로 보기  
            
            -   시작부분![](https://api.transno.com/v3/document_image/163a8244-0f46-4149-abbf-856ff4983d91-10826299.jpg)  
                -   Querydsl을 사용하려면 JPAQueryFactory 가 필요함. 그래서 선언해주고 생성자에서 주입해줬음.  
                    
            
            -   findAll  
                
                -   리팩토링 전![](https://api.transno.com/v3/document_image/4588f8d5-622c-4fcd-a8a3-7daaf0ce0bb5-10826299.jpg)  
                    -   매커니즘  
                        
                        -   1. 검색 조건을 변수에 각각 담는다  
                            
                        
                        -   2. 검색 조건을 where절에 넣기 위해, builder로 객체를 만들고 원하는 검색조건을 IF로 만들기 ( 동적 쿼리 작성 부분)  
                            
                        
                        -   3. 쿼리부분을 Type-safe로 작성  
                            
                
                -   리팩토링 후![](https://api.transno.com/v3/document_image/0efc34b8-197e-4352-9df5-63f01af7e386-10826299.jpg)  
                    
                    -   where절을 모듈화하여 코드를 알아보기 쉽게 하였음  
                        
                    
                    -   type-safe를 바로 리턴  
                        
-   데이터 접근 기술 - 활용 방안  
    
    -   스프링 데이터 JPA 예제와 트레이드 오프  
        
        -   간단한 프로젝트인데 구조가 너무 복잡하다  
            -   스프링 데이터 JPA 그림![](https://api.transno.com/v3/document_image/bf9e6e09-6d92-40ae-8d05-8a268ca3fb37-10826299.jpg)  
                
        
        -   좀더 간단하게 할 수 없을까?  
            -   구조 단순화 그림![](https://api.transno.com/v3/document_image/a4d11459-236f-4cda-9afb-60475b9feb72-10826299.jpg)![](https://api.transno.com/v3/document_image/3f1f301f-f102-4de4-925a-ad230673de47-10826299.jpg)  
                -   어댑터를 제거하고 구조를 단순하게 가져가지만, DI, OCP를 포기함  
                    
        
        -   트레이드 오프는 구조의 안정성 vs 단순한 구조와 개발의 편리성 사이의 선택  
            
    
    -   실용적인 구조  
        
        -   복잡한 쿼리 분리하기  
            -   스프링 데이터 JPA + Querydsl![](https://api.transno.com/v3/document_image/08397c5f-e31c-4642-9224-d3ac9e573ca4-10826299.jpg)  
                -   둘을 분리하면 기본 CRUD와 단순 조회는 스프링 데이터 JPA가 담당하고, 복잡한 조회 쿼리는 Querydsl이 담당  
                    
        
        -   코드로 보기  
            
            -   ItemRepositoryV2  
                -   코드![](https://api.transno.com/v3/document_image/f6440eda-d0c6-49c6-84f7-8d1b2e141c31-10826299.jpg)  
                    
            
            -   ItemQueryRepositoryV2  
                -   동적쿼리 코드![](https://api.transno.com/v3/document_image/0df67d41-4b32-4c9e-8d00-de7109d452ef-10826299.jpg)  
                    
            
            -   ItemServiceV2  
                -   코드![](https://api.transno.com/v3/document_image/deebc9c3-8ae7-4845-84a5-8289c1c3d8e9-10826299.jpg)  
                    
    
    -   다양한 데이터 접근 기술 조합  
        
        -   추천하는 방향은 JPA, 스프링 데이터 JPA, Querydsl을 기본으로 사용, 복잡한 쿼리를 써야 하는데, 해결이 잘 안되면 해당 부분에는 JdbcTemplate이나 MyBatis를 함께 사용하기  
            
        
        -   JPA와 JdbcTemplate 두 기술을 함께 사용하면 트랜잭션 매니저가 달라지는데?  
            -   JPA라는 기술도 결국 내부에서는 DataSource와 JDBC 커넥션을 사용하기 때문에 함께 사용가능.  
                
        
        -   JPA의 플러시 타이밍에 주의하기  
            -   JPA는 데이터를 변경하면 변경 사항을 즉시 데이터베이스에 반영하지 않는다. 기본적으로 트랜잭션이 커밋되는 시점에 변경 사항을 데이터베이스에 반영한다. (update 쪽 내용)  
                
-   스프링 트랜잭션 이해  
    
    -   스프링 트랜잭션 소개  
        
        -   트랜잭션 추상화  
            
            -   스프링은 PlatformTransactionManager 라는 인터페이스를 통해 트랜잭션을 추상화함![](https://api.transno.com/v3/document_image/a55bcf7b-b805-48a3-9ff7-aad5f796a2a0-10826299.jpg)  
                
            
            -   우리는 필요한 구현체를 스프링 빈으로 등록하고 주입 받아서 사용하기만 하면 된다.  
                
        
        -   스프링 트랜잭션 사용 방식  
            
            -   선언적 트랜잭션 관리  
                -   @ Transactional 애노테이션 하나만 선언해서 매우 편리하게 트랜잭션을 적용하는 것  
                    
            
            -   프로그래밍 방식의 트랜잭션 관리  
                -   트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용해서 트랜잭션 관련 코드를 직접 작성하는 것  
                    
        
        -   선언적 트랜잭션과 AOP  
            
            -   @ Transactional는 기본적으로 프록시 방식의 AOP가 적용된다.  
                
            
            -   프록시 적용전  
                
                -   그림![](https://api.transno.com/v3/document_image/24d0a752-c35d-44ac-a868-0a3b57101421-10826299.jpg)  
                    
                
                -   코드![](https://api.transno.com/v3/document_image/e1e0555d-3d50-4391-8d97-94ffbf9498d2-10826299.jpg)  
                    
            
            -   프록시 도입후  
                
                -   그림![](https://api.transno.com/v3/document_image/7c7a96da-0e65-4258-ad4e-9b0515c81993-10826299.jpg)  
                    
                
                -   트랜잭션 프록시 코드![](https://api.transno.com/v3/document_image/b3c294ed-ba3f-4d44-8326-6542e8ca2dfc-10826299.jpg)  
                    
                
                -   서비스 코드![](https://api.transno.com/v3/document_image/3468b602-83ec-42b0-9b91-a528d3f36d2e-10826299.jpg)  
                    
            
            -   전체과정![](https://api.transno.com/v3/document_image/64ff217b-eb06-4b8c-b59c-fecc4ef91655-10826299.jpg)  
                
    
    -   트랜잭션 적용 확인  
        
        -   스프링 트랜잭션이 실제 적용되고 있는지 확인하는 방법  
            
        
        -   트랜잭션 프록시 등록하는 방법  
            
            -   그림![](https://api.transno.com/v3/document_image/a15406ad-f28f-42ec-9463-69b1842cf008-10826299.jpg)  
                
            
            -   @ Transactional 을 메서드나 클래스에 붙이면 해당 객체는 트랜잭션 AOP 적용의 대상  
                
        
        -   코드로 보기  
            -   TxApplyBasicTest  
                
                -   proxyCheck()  
                    -   프록시 클래스인지 확인하는 함수  
                        
                
                -   txTest()  
                    
                    -   그림![](https://api.transno.com/v3/document_image/586594e3-b6f2-4666-8e6f-61cdca2a297a-10826299.jpg)  
                        
                    
                    -   basicService.tx() 호출  
                        -   @ Transactional 이붙어있으므로 트랜잭션 적용 대상이다. 따라서 트랜잭션을 시작한 다음에 실제 basicService.tx() 를 호출한다.  
                            
                    
                    -   basicService.nonTx() 호출  
                        -   @ Transactional 이 없으므로 적용 대상이 아니다. 따라서 트랜잭션을 시작하지 않고, basicService.nonTx() 를 호출하고 종료한다.  
                            
    
    -   트랜잭션 적용 위치  
        -   @ Transactional 의 적용 위치에 따른 우선순위는?  
            -   우선순위는 항상 더 구체적이고 자세한 것이 높은 우선순위를 가진다.  
                
    
    -   트랜잭션 AOP 주의 사항 - 프록시 내부 호출1  
        
        -   @ Transactional 을 사용하면 스프링의 트랜잭션 AOP가 적용된다. 하지만 프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP가 적용되지 않고, 트랜잭션도 적용되지 않는다.  
            -   when? @ Transactional이 없는 내부 호출일때, 대상 객체를직접 호출하는 경우  
                
        
        -   코드로 보기  
            -   InternalCallV1Test  
                -   CallService  
                    
                    -   코드![](https://api.transno.com/v3/document_image/dfe2c51d-064a-4e03-bb7e-54bedc1a3eb2-10826299.jpg)  
                        
                    
                    -   internal 호출일때  
                        
                        -   그림![](https://api.transno.com/v3/document_image/cc189db8-ab4f-4db0-872d-14e09da17ed3-10826299.jpg)  
                            
                        
                        -   매커니즘  
                            
                            -   1. 클라이언트인 테스트 코드는 callService.internal() 을 호출한다. 여기서 callService 는 트랜잭션 프록시이다.  
                                
                            
                            -   2. callService 의 트랜잭션 프록시가 호출된다.  
                                
                            
                            -   3. internal() 메서드에 @ Transactional 이 붙어 있으므로 트랜잭션 프록시는 트랜잭션을 적용한다.  
                                
                            
                            -   4. 트랜잭션 적용 후 실제 callService 객체 인스턴스의 internal() 을 호출한다.실제 callService 가 처리를 완료하면 응답이 트랜잭션 프록시로 돌아오고, 트랜잭션 프록시는트랜잭션을 완료한다.  
                                
                        
                        -   정상적인 프록시와 트랜잭션 사용가능  
                            
                    
                    -   external 호출일때  
                        
                        -   그림![](https://api.transno.com/v3/document_image/d7a0c743-cb2d-4287-8f6b-f829b9b16964-10826299.jpg)  
                            
                        
                        -   매커니즘  
                            
                            -   1. 클라이언트인 테스트 코드는 callService.external() 을 호출한다. 여기서 callService는 트랜잭션 프록시이다.  
                                
                            
                            -   2. callService 의 트랜잭션 프록시가 호출된다.  
                                
                            
                            -   3. external() 메서드에는 @ Transactional 이 없다. 따라서 트랜잭션 프록시는 트랜잭션을 적용하지 않는다.  
                                
                            
                            -   4. 트랜잭션 적용하지 않고, 실제 callService 객체 인스턴스의 external() 을 호출한다.  
                                
                            
                            -   5. external() 은 내부에서 internal() 메서드를 호출한다. 그런데 여기서 문제가 발생한다.  
                                
                        
                        -   발생 원인?  
                            -   별도의 참조가 없으면 this 라는 뜻으로 자기 자신의 인스턴스를 가리킨다.  
                                
    
    -   트랜잭션 AOP 주의 사항 - 프록시 내부 호출2  
        
        -   문제를 해결하기 위해 internal() 메서드를 별도의 클래스로 분리하자  
            
        
        -   코드로 보기  
            
            -   InternalService  
                
                -   코드![](https://api.transno.com/v3/document_image/1cbe719f-6b84-4b22-aab3-6e6f3e679636-10826299.jpg)  
                    
                
                -   기존 Internal과 동일하게 동작함  
                    
            
            -   CallService  
                
                -   코드![](https://api.transno.com/v3/document_image/c75830fc-de88-4c4c-93ab-8bf5aeeb795d-10826299.jpg)  
                    
                
                -   그림![](https://api.transno.com/v3/document_image/ac53df01-3df0-4aa2-903d-8979c3f1336f-10826299.jpg)  
                    
                
                -   매커니즘  
                    
                    -   1. 클라이언트인 테스트 코드는 callService.external() 을 호출한다.  
                        
                    
                    -   2. callService 는 실제 callService 객체 인스턴스이다.  
                        
                    
                    -   3. callService 는 주입 받은 internalService.internal() 을 호출한다.  
                        
                    
                    -   4. internalService 는 트랜잭션 프록시이다. internal() 메서드에 @ Transactional 이 붙어 있으므로 트랜잭션 프록시는 트랜잭션을 적용한다.  
                        
                    
                    -   5. 트랜잭션 적용 후 실제 internalService 객체 인스턴스의 internal() 을 호출한다.  
                        
        
        -   public 메서드만 트랜잭션 적용  
            -   why? 트랜잭션을 의도하지 않는 곳 까지 트랜잭션이 과도하게 적용된다. 트랜잭션은 주로 비즈니스 로직의 시작점에 걸기 때문에 대부분 외부에 열어준 곳을 시작점으로 사용함.  
                
    
    -   트랜잭션 AOP 주의 사항 - 초기화 시점  
        
        -   스프링 초기화 시점에는 트랜잭션 AOP가 적용되지 않을 수 있다.  
            
        
        -   코드로보기  
            -   코드![](https://api.transno.com/v3/document_image/02c570b5-edee-4748-8b93-f6392255dc93-10826299.jpg)  
                
                -   호출하는 시점에는 문제없이 프록시 생성되어 동작함.  
                    
                
                -   initV1  
                    -   초기화만 했을때는 초기화 코드가 먼저 호출되고, 그 다음에 트랜잭션 AOP가 적용되기 때문이다. 따라서 초기화 시점에는 해당 메서드에서 트랜잭션을 획득할 수 없다.  
                        
                
                -   initV2  
                    
                    -   이 이벤트는 트랜잭션 AOP를 포함한 스프링이 컨테이너가 완전히 생성되고 난 다음에 이벤트가 붙은 메서드를 호출해준다.  
                        
                    
                    -   [스프링 부트 애플리케이션에서 초기화 코드를 넣는 3가지 방법](https://jeong-pro.tistory.com/206)  
                        
    
    -   트랜잭션 옵션 소개  
        
        -   value, transactionManager  
            
            -   예시![](https://api.transno.com/v3/document_image/dffc7bd4-e242-4c9d-86fd-695201eeaec6-10826299.jpg)  
                애노테이션에서 속성이 하나인 경우 위 예처럼 value 는 생략하고 값을 바로 넣을 수 있다.
            
            -   기본으로 등록된 트랜잭션 매니저를 사용하기 때문에 대부분 생략한다.  
                
            
            -   하지만, 트랜잭션 매니저가 둘 이상이라면 다음과 같이 트랜잭션 매니저의 이름을 지정해서 구분해서 트랜잭션 매니저의 스프링 빈의 이름을 적어주면 된다.  
                
        
        -   스프링 트랜잭션의 기본 정책  
            
        
        -   rollbackFor  
            
            -   예시![](https://api.transno.com/v3/document_image/7f44e0d2-88ab-4f87-a4ea-831d2ec53765-10826299.jpg)  
                
            
            -   체크 예외인 Exception 이 발생해도 롤백하게 된다.  
                
            
            -   noRollbackFor은 그와 반대  
                
        
        -   propagation  
            -   트랜잭션 전파에 대한 옵션  
                
        
        -   timeout  
            -   트랜잭션 수행 시간에 대한 타임아웃을 초 단위로 지정한다.  
                
        
        -   readOnly  
            
            -   읽기 전용 트랜잭션이 생성된다. 이 경우 등록, 수정, 삭제가 안되고 읽기 기능만 작동한다  
                
            
            -   프레임워크  
                
                -   JdbcTemplate은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다.  
                    
                
                -   JPA(하이버네이트)는 읽기 전용 트랜잭션의 경우 커밋 시점에 플러시를 호출하지 않는다. + 스냅샷 객체도 생성하지 않는다. 그래서 최적화가 발생  
                    
            
            -   JDBC 드라이버  
                -   변경 쿼리가 발생하면 예외를 던진다.  
                    
            
            -   데이터베이스  
                -   읽기만 하면 되므로, 내부에서 성능 최적화가 발생  
                    
    
    -   예외와 트랜잭션 커밋, 롤백 - 기본  
        
        -   트랜잭션 범위 밖으로 예외를 던지면 어떻게 될까?  
            
        
        -   상황별 예외 처리 보기  
            
            -   그림![](https://api.transno.com/v3/document_image/ba5d3ec7-a267-4534-9535-52f681c66be5-10826299.jpg)  
                
            
            -   언체크 예외인 RuntimeException , Error 와 그 하위 예외가 발생하면 롤백한다.  
                
            
            -   체크 예외인 Exception 과 그 하위 예외들은 커밋한다.  
                
            
            -   정상 응답(리턴)하면 트랜잭션을 커밋한다.  
                
        
        -   코드 -> RollbackTest  
            
    
    -   예외와 트랜잭션 커밋, 롤백 - 활용  
        
        -   스프링은 왜 체크 예외는 커밋하고, 언체크(런타임) 예외는 롤백할까?  
            
        
        -   스프링 기본 정책  
            
            -   체크 예외: 비즈니스 의미가 있을 때 사용  
                -   시스템은 문제 없이 동작한 것이고, 비즈니스 상황이 예외인 것이다.  
                    
            
            -   언체크 예외: 복구 불가능한 예외  
                
        
        -   비즈니스 예외라는 것이 무슨 뜻일까?  
            
            -   1. 정상: 주문시 결제를 성공하면 주문 데이터를 저장하고 결제 상태를 완료로 처리한다.  
                
            
            -   2. 시스템 예외: 주문시 내부에 복구 불가능한 예외가 발생하면 전체 데이터를 롤백한다.  
                
            
            -   3. 비즈니스 예외: 주문시 결제 잔고가 부족하면 주문 데이터를 저장하고, 결제 상태를 대기로 처리한다.  
                
                -   이 경우 고객에게 잔고 부족을 알리고 별도의 계좌로 입금하도록 안내한다.  
                    
                
                -   if 롤백을 한다면? 다시 첨부터 상품을 찾고 담는 것부터 해야되는...  
                    
        
        -   코드로 보기  
            -   OrderServiceTest  
                
-   스프링 트랜잭션 전파  
    
    -   트랜잭션 두 번 사용  
        
        -   트랜잭션이 둘 이상 있을 때 어떻게 동작하는지 알아보자 => 트랜잭션 전파  
            
        
        -   서로 다른 커넥션을 사용할때  
            -   그림으로 이해하기![](https://api.transno.com/v3/document_image/311c7030-bcd7-4c97-b825-432ab30ada17-10826299.jpg)  
                
                -   언제 서로 다른 커넥션을 사용하지?  
                    
                    -   트랜잭션1이 롤백/커밋을 사용한 후, 트랜잭션2를 사용하는 경우  
                        
                    
                    -   트랜잭션1이 사용중이지만, 트랜잭션2에서 REQUIRES_NEW를 사용할때  
                        
                
                -   트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 각각 다르다.  
                    
                
                -   코드로 보기  
                    
                    -   트랜잭샌 1 커밋, 트랜잭션 2 롤백![](https://api.transno.com/v3/document_image/20ad3778-2747-4885-9fbb-a1b2a5560718-10826299.jpg)  
                        
                    
                    -   결과![](https://api.transno.com/v3/document_image/60758a68-7fb0-45f8-a6a1-31d51a567c17-10826299.jpg)  
                        
    
    -   전파 기본  
        
        -   트랜잭션을 각각 사용하는 것이 아니라, 트랜잭션이 이미 진행중인데, 여기에 추가로 트랜잭션을 수행하면 어떻게 될까?  
            
        
        -   전파의 기본  
            
            -   외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어준다. ![](https://api.transno.com/v3/document_image/bdca33f8-b21f-4848-bf70-e270e8048452-10826299.jpg)  
                
                -   물리 트랜잭션은 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다  
                    
                
                -   논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다  
                    
            
            -   원칙  
                
                -   모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.  
                    
                
                -   하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.  
                    
    
    -   전파 예제  
        
        -   외부 내부 트랜잭션 모두 커밋될때  
            
            -   외부 트랜잭션만 물리 트랜잭션을 시작하고, 커밋한다. 그래서 처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리함  
                
            
            -   그림과 코드  
                
                -   그림![](https://api.transno.com/v3/document_image/212b5ba3-f9a5-4748-9e4f-8ef4cb3adecf-10826299.jpg)  
                    
                
                -   코드![](https://api.transno.com/v3/document_image/33b84e2b-1372-40da-96d4-6219becbb8fa-10826299.jpg)  
                    
                
                -   결과![](https://api.transno.com/v3/document_image/94045514-3d67-433e-a47d-f719634050de-10826299.jpg)![](https://api.transno.com/v3/document_image/b3e0a1dd-b475-44a5-bfe5-673459bb4187-10826299.jpg)  
                    
                    -   isNewTransaction=false  
                        -   코드를 잘 보면 커밋을 두 번 호출했다. 하지만 내부 트랜잭션은 신규 트랜잭션이 아니다.  
                            
                    
                    -   Participating in existing transaction  
                        -   내부 트랜잭션이 기존에 존재하는 외부 트랜잭션에 참여한다는 뜻  
                            
            
            -   매커니즘  
                
                -   요청 매커니즘  
                    
                    -   그림![](https://api.transno.com/v3/document_image/9b47ad8b-e5a8-4312-b4a9-7846e20615cf-10826299.jpg)  
                        
                    
                    -   요청 흐름 - 외부 트랜잭션  
                        
                        -   1. txManager.getTransaction() 를 호출해서 외부 트랜잭션을 시작한다.  
                            
                        
                        -   2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.  
                            
                        
                        -   3. 생성한 커넥션을 수동 커밋 모드( setAutoCommit(false) )로 설정한다. - 물리 트랜잭션 시작  
                            
                        
                        -   4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.  
                            
                        
                        -   5. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨 있다. isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있다. 트랜잭션을 처음 시작했으므로 신규 트랜잭션이다.( true )  
                            
                        
                        -   6. 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용한다.  
                            
                    
                    -   요청 흐름 - 내부 트랜잭션  
                        
                        -   7. txManager.getTransaction() 를 호출해서 내부 트랜잭션을 시작한다.  
                            
                        
                        -   8. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인한다.  
                            
                        
                        -   9. 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여한다. 기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻이다. 이미 기존 트랜잭션인 외부 트랜잭션에서 물리 트랜잭션을 시작했다. 그리고 물리 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 담아두었다. 따라서 이미 물리 트랜잭션이 진행중이므로 그냥 두면 이후 로직이 기존에 시작된 트랜잭션을 자연스럽게 사용하게 되는 것이다. 이후 로직은 자연스럽게 트랜잭션 동기화 매니저에 보관된 기존 커넥션을 사용하게 된다.  
                            
                        
                        -   10. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 여기에서 isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있다. 여기서는 기존 트랜잭션에 참여했기 때문에 신규 트랜잭션이 아니다. ( false )  
                            
                        
                        -   11. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용한다  
                            
                
                -   응답 매커니즘  
                    
                    -   그림![](https://api.transno.com/v3/document_image/8d8618b4-b4c3-4633-a54b-9be65275f072-10826299.jpg)  
                        
                    
                    -   응답 흐름 - 내부 트랜잭션  
                        
                        -   12. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.  
                            
                        
                        -   13. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다. 이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다. 아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다. 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다  
                            
                    
                    -   응답 흐름 - 외부 트랜잭션  
                        
                        -   14. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다.  
                            
                        
                        -   15. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션이다. 따라서 DB 커넥션에 실제 커밋을 호출한다.  
                            
                        
                        -   16. 트랜잭션 매니저에 커밋하는 것이 논리적인 커밋이라면, 실제 커넥션에 커밋하는 것을 물리 커밋이라 할 수 있다. 실제 데이터베이스에 커밋이 반영되고, 물리 트랜잭션도 끝난다.  
                            
        
        -   외부 롤백  
            
            -   논리 트랜잭션이 하나라도 롤백되면 전체 물리 트랜잭션은 롤백된다  
                
            
            -   그림과 코드  
                
                -   그림![](https://api.transno.com/v3/document_image/88addec0-794c-45af-81e8-a1be016689c7-10826299.jpg)  
                    
                
                -   코드![](https://api.transno.com/v3/document_image/f857c2f8-a4a4-4933-b085-d5e89cfe1474-10826299.jpg)  
                    
                
                -   결과![](https://api.transno.com/v3/document_image/9c02cffc-3daa-4b0d-9196-1de8312b7fca-10826299.jpg)  
                    
            
            -   매커니즘  
                
                -   요청 매커니즘은 동일  
                    
                
                -   응답 매커니즘  
                    
                    -   그림![](https://api.transno.com/v3/document_image/e998f5a8-5069-404d-90d2-fdf531a06276-10826299.jpg)  
                        
                    
                    -   응답 흐름 - 내부 트랜잭션 => 앞과 동일  
                        
                        -   1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.  
                            
                        
                        -   2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다. 이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다. 아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다. 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다.  
                            
                    
                    -   응답 흐름 - 외부 트랜잭션 => 커밋에서 롤백으로 바뀐것뿐  
                        
                        -   3. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 롤백한다.  
                            
                        
                        -   4. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션이다. 따라서 DB 커넥션에 실제 롤백을 호출한다.  
                            
                        
                        -   5. 트랜잭션 매니저에 롤백하는 것이 논리적인 롤백이라면, 실제 커넥션에 롤백하는 것을 물리 롤백이라 할 수 있다. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.  
                            
        
        -   내부 롤백  
            
            -   내부 트랜잭션은 롤백되는데, 외부 트랜잭션이 커밋되는 상황은 간단하지 않음  
                
                -   why? 외부 트랜잭션만 물리 트랜잭션에 영향을 주기 때문에 물리 트랜잭션이 커밋될 것 같다.  
                    
                
                -   해결책 ->트랜잭션 동기화 매니저에 롤백 마크 남기기  
                    
            
            -   그림과 코드  
                
                -   그림![](https://api.transno.com/v3/document_image/005b2e8d-1f83-4611-8c13-c365c3665dd2-10826299.jpg)  
                    
                
                -   코드![](https://api.transno.com/v3/document_image/d4d1969a-3529-4904-a87b-28834bc581d8-10826299.jpg)  
                    
                
                -   결과![](https://api.transno.com/v3/document_image/58e430c2-4cea-4f79-a42a-2b5a453f7eac-10826299.jpg)  
                    
            
            -   매커니즘  
                
                -   그림![](https://api.transno.com/v3/document_image/015b5a8d-a5a5-4abc-abc9-68b947c44071-10826299.jpg)  
                    
                
                -   응답 흐름 - 내부 트랜잭션  
                    
                    -   1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다. (로직2에 문제가 있어서 롤백한다고 가정한다.)  
                        
                    
                    -   2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 이 경우 신규 트랜잭션이 아니기 때문에 실제 롤백을 호출하지 않는다. 이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면물리 트랜잭션이 끝나버린다. 아직 트랜잭션이 끝난 것이 아니기 때문에 실제 롤백을 호출하면 안된다. 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다.  
                        
                    
                    -   3. 내부 트랜잭션은 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 rollbackOnly=true 라는 표시를 해둔다.  
                        
                
                -   응답 흐름 - 외부 트랜잭션  
                    
                    -   4. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다.  
                        
                    
                    -   5. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션이다. 따라서 DB 커넥션에 실제 커밋을 호출해야 한다. 이때 먼저 트랜잭션 동기화 매니저에 롤백 전용( rollbackOnly=true ) 표시가 있는지 확인한다. 롤백 전용 표시가 있으면 물리 트랜잭션을 커밋하는 것이 아니라 롤백한다.  
                        
                    
                    -   6. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.  
                        
                    
                    -   7. 트랜잭션 매니저에 커밋을 호출한 개발자 입장에서는 분명 커밋을 기대했는데 롤백 전용 표시로 인해 실제로는 롤백이 되어버렸다.  
                        
                        -   이것은 조용히 넘어갈 수 있는 문제가 아니다. 시스템 입장에서는 커밋을 호출했지만 롤백이 되었다는 것은 분명하게 알려주어야 한다.  
                            
                        
                        -   예를 들어서 고객은 주문이 성공했다고 생각했는데, 실제로는 롤백이 되어서 주문이 생성되지 않은 것이다.  
                            
                        
                        -   스프링은 이 경우 UnexpectedRollbackException 런타임 예외를 던진다. 그래서 커밋을 시도했지만, 기대하지 않은 롤백이 발생했다는 것을 명확하게 알려준다.  
                            
        
        -   REQUIRES_NEW  
            
            -   외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 사용하는 방법  
                
            
            -   그림과 코드  
                
                -   그림![](https://api.transno.com/v3/document_image/321bcde2-b480-4834-9b2a-fbad87e30133-10826299.jpg)  
                    
                
                -   코드![](https://api.transno.com/v3/document_image/6a2ceb95-a75a-4ecd-adce-bfa38f1e2f67-10826299.jpg)  
                    PROPAGATION_REQUIRES_NEW 옵션을 사용했기 때문에 완전히 새로운 신규 트랜잭션으로 생성된다
                
                -   결과![](https://api.transno.com/v3/document_image/7c4918ff-f33d-4ae5-8375-5d9115d99c33-10826299.jpg)![](https://api.transno.com/v3/document_image/358b1443-4490-4c37-ac05-8ae5da3c0fc2-10826299.jpg)  
                    
            
            -   매커니즘  
                
                -   요청  
                    
                    -   그림![](https://api.transno.com/v3/document_image/b8acf088-e206-4da1-b346-c31c8681b6bc-10826299.jpg)  
                        
                    
                    -   요청 흐름 - 외부 트랜잭션  
                        
                        -   1. txManager.getTransaction() 를 호출해서 외부 트랜잭션을 시작한다.  
                            
                        
                        -   2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.  
                            
                        
                        -   3. 생성한 커넥션을 수동 커밋 모드( setAutoCommit(false) )로 설정한다. - 물리 트랜잭션 시작  
                            
                        
                        -   4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.  
                            
                        
                        -   5. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨 있다. isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있다. 트랜잭션을 처음 시작했으므로 신규 트랜잭션이다.( true )  
                            
                        
                        -   6. 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을획득해서 사용한다  
                            
                    
                    -   요청 흐름 - 내부 트랜잭션  
                        
                        -   7. REQUIRES_NEW 옵션과 함께 txManager.getTransaction() 를 호출해서 내부 트랜잭션을 시작한다. 트랜잭션 매니저는 REQUIRES_NEW 옵션을 확인하고, 기존 트랜잭션에 참여하는 것이 아니라 새로운 트랜잭션을 시작한다.  
                            
                        
                        -   8. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.  
                            
                        
                        -   9. 생성한 커넥션을 수동 커밋 모드( setAutoCommit(false) )로 설정한다. - 물리 트랜잭션 시작  
                            
                        
                        -   10. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다. 이때 con1 은 잠시 보류되고, 지금부터는 con2 가 사용된다. (내부 트랜잭션을 완료할 때 까지 con2가 사용된다.)  
                            
                        
                        -   11. 트랜잭션 매니저는 신규 트랜잭션의 생성한 결과를 반환한다. isNewTransaction == true  
                            
                        
                        -   12. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저에 있는 con2 커넥션을 획득해서 사용한다.  
                            
                
                -   응답  
                    
                    -   그림![](https://api.transno.com/v3/document_image/7e6004e2-ff18-40ac-bb60-945089a61df9-10826299.jpg)  
                        
                    
                    -   응답 흐름 - 내부 트랜잭션  
                        
                        -   1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다. (로직2에 문제가 있어서 롤백한다고 가정한다.)  
                            
                        
                        -   2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 현재 내부 트랜잭션은 신규트랜잭션이다. 따라서 실제 롤백을 호출한다.  
                            
                        
                        -   3. 내부 트랜잭션이 con2 물리 트랜잭션을 롤백한다. 트랜잭션이 종료되고, con2 는 종료되거나, 커넥션 풀에 반납된다. 이후에 con1 의 보류가 끝나고, 다시 con1 을 사용한다.  
                            
                    
                    -   응답 흐름 - 외부 트랜잭션  
                        
                        -   4. 외부 트랜잭션에 커밋을 요청한다.  
                            
                        
                        -   5. 외부 트랜잭션은 신규 트랜잭션이기 때문에 물리 트랜잭션을 커밋한다.  
                            
                        
                        -   6. 이때 rollbackOnly 설정을 체크한다. rollbackOnly 설정이 없으므로 커밋한다.  
                            
                        
                        -   7. 본인이 만든 con1 커넥션을 통해 물리 트랜잭션을 커밋한다. 트랜잭션이 종료되고, con1 은 종료되거나, 커넥션 풀에 반납된다.  
                            
    
    -   다양한 전파 옵션  
        
        -   REQUIRED  
            -   가장 많이 사용하는 기본 설정이다. 기존 트랜잭션이 없으면 생성하고, 있으면 참여한다.  
                
        
        -   REQUIRES_NEW  
            -   항상 새로운 트랜잭션을 생성한다.  
                
-   트랜잭션 전파 활용  
    
    -   예제 프로젝트 시작  
        
        -   비즈니스 요구사항  
            
            -   회원을 등록하고 조회  
                
            
            -   회원에 대한 변경 이력을 추적할 수 있도록 회원 데이터가 변경될 때 변경 이력을 DB LOG 테이블에 남겨야 한다.  
                
        
        -   직접가서 코드로 보기  
            
            -   JPA의 구현체인 하이버네이트가 테이블을 자동으로 생성  
                
            
            -   메모리 DB이기 때문에 모든 테스트가 완료된 이후에 DB는 사라진다.  
                
            
            -   각각의 테스트가 완료된 시점에 데이터를 삭제하지 않는다. 따라서 username 은 테스트별로 각각 다르게 설정해야 한다.  
                
    
    -   커밋, 롤백  
        
        -   서비스 계층에 트랜잭션이 없을 때 트랜잭션이 각각 어떻게 작동하는지 확인  
            
        
        -   서비스 계층에 트랜잭션이 없을 때 - 커밋  
            
            -   상황![](https://api.transno.com/v3/document_image/e57951f3-2b39-4613-8b88-3b00dd0f775d-10826299.jpg)  
                
            
            -   코드  
                -   outerTxOff_success  
                    -   회원, 로그 리포지토리 둘다 커밋에 성공한다.  
                        
            
            -   매커니즘  
                -   그림![](https://api.transno.com/v3/document_image/a191f178-4410-4175-992d-c011b9f1be57-10826299.jpg)  
                    
        
        -   서비스 계층에 트랜잭션이 없을 때 - 롤백  
            
            -   상황![](https://api.transno.com/v3/document_image/0a1cc8d8-324e-44e4-873e-98b2c4299c9a-10826299.jpg)  
                
            
            -   코드  
                -   outerTxOff_fail  
                    -   회원 리포지토리는 정상 동작하지만 로그 리포지토리에서 런타임 예외가 발생한다.  
                        
            
            -   매커니즘  
                -   그림![](https://api.transno.com/v3/document_image/9e061a7d-0c66-4ca3-8f6a-c0287dc11781-10826299.jpg)  
                    
    
    -   단일 트랜잭션  
        -   서비스에만 트랜잭션을 한 경우  
            
            -   상황 ![](https://api.transno.com/v3/document_image/f307e4c4-0631-4ffb-9758-c475811267fe-10826299.jpg)  
                
            
            -   코드  
                -   singleTx  
                    
            
            -   매커니즘![](https://api.transno.com/v3/document_image/d4daa3a2-80e6-4595-8487-c5092228ad3d-10826299.jpg)  
                
    
    -   전파 커밋  
        -   각각 트랜잭션이 필요한 상황 + 모두 커밋  
            
            -   상황![](https://api.transno.com/v3/document_image/c91c2830-ec08-4b72-8545-5288bc7cb4f7-10826299.jpg)  
                MemberService, MemberRepository, LogRepository 모두 @ Transactional이 있는 상황
                -   이떄, 외부에 있는 신규 트랜잭션만 실제 물리 트랜잭션을 시작하고 커밋하는 경우는 내부에 있는 트랜잭션은 물리 트랜잭션 시작하거나 커밋하지 않는다.  
                    
            
            -   코드  
                -   outerTxOn_success  
                    
            
            -   매커니즘![](https://api.transno.com/v3/document_image/78487829-a3f0-4b59-9c08-0484e9599da2-10826299.jpg)  
                
    
    -   전파 롤백  
        -   로그 리포지토리에서 예외가 발생해서 전체 트랜잭션이 롤백되는 경우  
            
            -   상황![](https://api.transno.com/v3/document_image/858e0951-85a6-4f04-917e-346a7fa6a984-10826299.jpg)  
                
            
            -   코드  
                -   outerTxOn_fail  
                    
            
            -   매커니즘![](https://api.transno.com/v3/document_image/726d9f7e-bed8-4af1-9adf-c96d1d601e10-10826299.jpg)  
                
    
    -   복구 REQUIRED  
        -   회원 가입을 시도한 로그를 남기는데 회원가입이 안되는 문제상황  
            
            -   상황![](https://api.transno.com/v3/document_image/3cd9afef-e1a9-4aeb-8a34-9d2033d3b1aa-10826299.jpg)  
                -   LogRepository 에서 예외가 발생하면 그것을 MemberService 에서 예외를 잡아서 처리로 해결 X  
                    -   Why? RollBack-only 때문에  
                        
            
            -   코드  
                -   recoverException_fail  
                    
            
            -   매커니즘![](https://api.transno.com/v3/document_image/3f248f11-e088-499e-aef8-307cfbc26110-10826299.jpg)  
                
    
    -   복구 REQUIRES_NEW  
        
        -   회원 가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 유지되어야 한다  
            
            -   상황![](https://api.transno.com/v3/document_image/97903669-088d-4445-bfed-62013594c362-10826299.jpg)  
                
            
            -   코드  
                -   recoverException_success  
                    
            
            -   매커니즘![](https://api.transno.com/v3/document_image/a3433d3c-0767-4028-adfa-ec8406689cb5-10826299.jpg)  
                
        
        -   방법2 참고만  
            -   그림![](https://api.transno.com/v3/document_image/d5a7c2e6-5750-46fa-8b72-22983e327a07-10826299.jpg)