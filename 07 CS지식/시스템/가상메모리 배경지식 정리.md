출처 : [[10분 테코톡] 🧚🏻 배럴의 가상 메모리 - YouTube](https://www.youtube.com/watch?v=5pEDL6c--_k&t=221s)  ,  [짧게 개념만 이해하는! 가상 메모리 구조 - YouTube](https://www.youtube.com/watch?v=rmm2_MkAuxk)  ,  [[운영체제] 가상 메모리의 이해 (tistory.com)](https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4) ,  [💵 캐시가 동작하는 아주 구체적인 원리](https://parksb.github.io/article/29.html)   

#### 컴퓨터의 구조로 보는 실행구조는?
![[Pasted image 20230519082301.png]]
- **cpu가 연산할려면 메모리의 값을 참조**해야함. 그래서 레지스터, 메인 메모리의 값을 참조함.  
- ​**보조 기억장치(disk)의 값을 참조할려면 OS의 도움을 받아 IO작업**을 해야함.  


#### '로드' 한다는 의미는?
"로드한다"는 용어는 **특정 데이터나 프로그램을 메모리로 이동되어 실행을 위한  준비**가 되었음을 미합니다. 프로그램이 디스크에 저장되어 있을 때, 그 프로그램을 실행하려면 운영체제가 먼저 그 프로그램을 메모리로 로드해야 합니다. 이 프로세스는 다음과 같은 단계를 포함할 수 있습니다

1. 프로그램의 실행 파일을 디스크에서 읽습니다. 
![[Pasted image 20230519082444.png]]
![[Pasted image 20230519082450.png]]
=> 실행 되기 위해서는 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야함. 그래서 fork와 exec를 통해서 **프로세서 형태로 메모리**에 올림.

2. 프로그램에 필요한 **메모리 공간을 할당**합니다. 
![[Pasted image 20230519094821.png]]
=> 프로세스마다 독자적인 주소공간 생성함. 그리고 이 주소를 바라보는데 이것을 **논리주소**라고함.

3. 프로그램 코드와 **데이터를 메모리로 이동**시킵니다.
![[Pasted image 20230519112918.png]]
=> CPU가 일을 하기 위해서는 논리주소가 메인 메모리상에 올라와 있어야함. 이 작업을 **주소 바인딩**이라고함.

4. 프로그램의 시작 지점(주로 `main` 함수)에서 실행을 시작합니다.


####  디스크에서 메모리로 할때 실행하는 함수의 역할은?
디스크에서 메모리로 프로그램이 **로드되는 과정은 일반적으로 `fork`와 `exec` 두 가지 시스템 호출**을 통해 이루어집니다. 이 두 가지 시스템 호출은 유닉스 및 유닉스 계열 운영체제(예: 리눅스)에서 자주 사용되며, 새로운 프로세스를 생성하고 실행하는 데 사용됩니다.

1. `fork`: 현재 실행 중인 **프로세스의 복사본을 생성**합니다. 이 복사본은 부모 프로세스라고 하는 원본 프로세스와 거의 동일하며, 메모리 공간, CPU 레지스터, 열린 파일 디스크립터 등을 복사합니다. 그러나 부모와 자식 프로세스의 프로세스 ID(PID)는 다릅니다.
2. `exec`: 현재 실행 중인 프로세스를 완전히 새로운 프로그램으로 대체합니다. 이 호출이 이루어지면, 현재 프로세스의 메모리 공간은 새로운 프로그램으로 대체되고, **새 프로그램이 메모리에서 실행을 시작**합니다.

프로세스는 자신을 복제(`fork`)하고 복제본은 새 프로그램을 로드(`exec`)하여 실행합니다. 이렇게 하면 원본 프로세스는 계속 실행을 계속하거나 다른 작업을 수행할 수 있습니다. 이러한 방식은 유닉스 및 리눅스에서 새 프로세스를 생성하고 실행하는 일반적인 방법입니다.


#### 여러개의 프로세스가 메모리에 올라오면?
![[Pasted image 20230519232033.png]]
=> 이렇게 프로세스가 많이 올라와 메모리공간이 부족하면 메모리 공간 확장 영역으로 **스왑 영역**을 사용함

#### 스왑이란?
![[Pasted image 20230520054118.png]]
=> 물리 메모리의 확장개념으로, 메모리 공간이 부족하니깐 실행중인 **프로세스의 주소공간을 일시적으로 메모리에서 디스크로 내려 놓은 것**을 말함. 그렇기 때문에 I/O작업이 일어남

#### 가상 메모리란?
=> 메모리 관리 기법중 하나로 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법으로 **필요한 부분만 올림**.
![[Pasted image 20230520055139.png]]

#### 가상 메모리를 사용하는 이유는?
1. **효율적인 메모리 관리**: 가상 메모리를 사용하면 실제 물리적 메모리보다 **큰 메모리 공간을 프로그램에 사용**할 수 있습니다. 이는 실제로 사용되는 데이터나 코드만 물리 메모리에 로드해 사용하므로 메모리 사용의 효율성을 높입니다.
![[Pasted image 20230520054945.png]]

2. **메모리 과부하 관리**: 가상 메모리는 프로세스가 **실제 물리 메모리보다 더 큰 메모리 공간을 사용**할 수 있게 해줍니다. 이는 시스템이 더 많은 프로세스를 동시에 처리할 수 있게 하며, 특히 메모리가 부족한 시스템에서 유용합니다.
![[Pasted image 20230520055003.png]]

#### 가상 메모리의 장점은?
1. 사용자 프로그램이 **물리 메모리의 제약에서 벗어남**  
2. 각 프로그램이 **더 작은 메모리를 차지**하기 때문에 **더 많은 프로그램을 동시수행** 가능 한 것처럼 보임)  
3. 프로그램을 메모리에 올리고 swap 하는데 필요한 **IO 횟수가 줄어듦**

#### 어떻게 가상메모리는 필요한 부분만 올릴까?
=> 주소공간을 여러개의 페이지로 나누는 **요구페이징기법**을 사용함. 그래서 지금 당장 필요한 페이지만 물리 페이지에 올림.
![[Pasted image 20230520055246.png]]

#### 동작하는 과정은?
=> 페이지 테이블에서 페이지의 바인딩 정보를 확인할 수 있음(V:사용함, I:사용하지않음). 페이지 테이블에서 찾아낸 물리 페이지 번호에 가상 주소의 오프셋(특정 페이지 내부의 위치)을 더하여 최종 물리 주소에 올림.
![[Pasted image 20230520055450.png]]
