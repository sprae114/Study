# git 설치법 (윈도우 / 맥북)
## 깃을 쓰는 이유는?
![[캡처.jpg]]

코드를 짜든 디자인을 하든 레포트를 쓰든 **파일 변경내역을 보존하고 관리**하는 과정이 필요합니다. 
그러고 싶을 때 프로그래머들은 git을 사용합니다. 이거 쓰면 위 사진처럼 파일 복사본을 귀찮게 만들지 않고도 깔끔하게 버전관리가 가능합니다.

## 깃 설치 ✔
1) 깃 다운 받기

2) 깃 설치 확인
윈도우는 shift + 우클릭하면 powershell 열기, 맥은 손가락 2개 클릭하면 터미널열기가 나오는데 거기서 git --version 이라고 입력해봅시다.

```sh
git --version
```
버전이 아무거나 뜨면 git 설치성공입니다.

3) git 유저 이름셋팅
```sh
git config --global user.email "홍길동@naver.com"
git config --global user.name "홍길동"
```
컴퓨터에서 git을 처음 사용한다면 위 코드를 터미널에 차례로 입력하면 되는데, 누가 지금 git을 쓰고있는지 구분하기 위한 로그인 같은겁니다.


# git add, commit으로 파일 기록해놓을 수 있음
## 코드를 실수로 날렸을 때
코드 짜다가 실수해서 2일 전으로 돌아가고 싶으면 어쩌죠? 파일저장만 주구장창 했으면 다시 돌아갈 수는 없습니다.

해결 방법이 2개 있는데
- 매일매일 손수 파일 복사본을 만들어두거나
- git 쓰거나
둘 중 선택하면 됩니다.

git의 **commit 기능을 쓰면 쓰면 파일의 현재상태를 매일매일 기록**해둘 수 있습니다.(파일의 스냅샷)
그럼 원할 때 쉽게 되돌아가거나 그럴 수 있음


## git 시작하기
일단 작업폴더에서 git을 이용하고 싶으면 거기서 터미널을 열어서 다음 명령어 입력하고 시작하면 됩니다.

```sh
git init
```
이러면, git이 여러분이 파일생성하는거, 코드작성하는걸 추적하기 시작합니다. 


## 파일 저장하기
이제 파일 하나를 생성하고 코드를 아무렇게나 짜봅시다. test.txt 파일을 생성해서 대충 아무거나 코드짜봤습니다. 오늘 짠 코드가 맘에 들어서 따로 기록을 해두고 싶은겁니다.
그러면 아까 설치한 **git을 이용해서 "이 파일 현재상태를 기록 좀 해줘~" 라고 부탁**하면 되는데

▶ 파일 저장하는 명령어
```sh
git add 파일명 
git commit -m '아무메세지'
```
이러면 방금 파일의 내용을 몰래 어딘가에 기록해줍니다. 이제 한참 뒤에도 이 파일상태 그대로 되돌리거나 그럴 수 있고 나중에 파일변경 히스토리가 궁금하면 열람할 수도 있습니다.


## staging area & repository ✔
버전만들 땐 `git add`, `git commit` 차례로 하면 된다고 했습니다.

![[그림1 1.png]]

그림으로 그리자면 이런 식인데 여기서 가운데 부분을 staging area, 파일버전이 저장되는 곳을 repository (저장소) 라고 합니다.

1. **staging area**는 commit을 하기 전에 **commit할 파일들을 골라놓는 곳**입니다.
그리고 staging area에 파일넣는 행위를 staging이라고 합니다.
git add 명령어로 staging 할 수 있습니다.

2. **repository**는 **commit된 파일의 버전들을 모아놓는 곳**입니다.
repository의 실체를 구경하고 싶으면 작업폴더안에 숨겨져 있는 .git 폴더 열어보면 됩니다.
아무튼 staging area & repository 2개는 자주 쓰는 용어니까 잘 외워둡시다.


## 다른 명령어들 ✔
▶ 여러 파일을 동시에 스테이징
```sh
git add 파일명1 파일명2
```

▶ 작업폴더의 모든 파일을 전부 스테이징
```sh
git add .
```

▶ 파일 상태 확인
```sh
git status
```
지금 **뭐 하는지 까먹었을 때**도 자주 입력하게 됩니다. 지금 변경된 파일, 스테이징된 파일 이런걸 쭉 알려줍니다.

▶ 스테이징된 파일 취소
```sh
git restore --staged 파일명
```

▶ 스테이징된 파일 전체 취소
```sh
git restore --staged .
```

▶ commit 메세지 입력
```sh
git commit -m '메세지'
```
메세지에 코드에 무슨기능 추가했는지 이런거 적으면 됩니다.

▶ commit 기록을 한 눈에 파악
```sh
git log --all --oneline 
git log --all --oneline --graph
```
commit 기록을 한 눈에 파악하고 싶으면 git log 명령어 입력하면 됩니다.
--graph 옵션을 넣으면 그래프로 그려줍니다. 

# git add와 git commit의 효율적 사용

## 터미널 사용의 한계
요즘은 터미널에 직접 `git add` 이거 입력하는게 뻘짓일 수 있습니다. **웬만한 에디터들 보면 git 기능**이 내장되어있어서 그거 쓰면 터미널 켤 필요없이 편리하게 add, commit 가능합니다.


## git diff 명령어
`git diff`로 **차이점 출력**해줄 수 있음.바로 전 commit과 현재 코드의 차이점을 비교해줍니다. 
하지만 거의 사용 X


## git difftool 명령어
`git difftool` 이용하면 **비주얼적으로 훌륭하게 차이점을 분석**해줍니다. 하지만 이것도 에디터가 잘되어 있어서 사용 X
![[git-difftool-vim 1.png]]

- `git difftool`: 입력하면 현재 파일과 최근 commit의 차이점을 비교해줍니다.
- `git difftool 커밋id`: 입력하면 현재 파일과 특정 commit의 차이점을 비교해줍니다.
- `git difftool 커밋id1 커밋id2`: 입력하면 특정 commit 2개의 차이점을 비교해줍니다.


# Git 브랜치 기능 활용하기
## 기능 추가를 위한 안전한 방법 ✔
![[Pasted image 20240524031609.png]]
코드를 작성하다 보면 새로운 기능을 추가해야 할 필요성이 생기곤 합니다. 이때 원본 파일에 코드를 추가하고 커밋하는 것도 방법이지만, 잘못해서 지금까지의 작업이 손상될 수도 있습니다. 

![[Pasted image 20240524031624.png]]
이를 방지하기 위해 **프로젝트의 복사본을 만들어서 새로운 기능을 먼저 개발**해보는 것이 좋습니다. 
예를 들어, 쇼핑몰을 만들고 있는데 새로운 쿠폰 기능을 추가하고 싶을 때, 위험을 피하기 위해 프로젝트 사본에서 먼저 개발을 시작할 수 있습니다.


## Branch 명령어 ✔
▶ 브랜치 생성
```sh
git branch 브랜치이름
```
프로젝트 사본이 하나 생성함.


▶ 브랜치 이동
```sh
git switch 브랜치이름
```
방금 만든 coupon 브랜치로 이동하고 싶으면 git switch coupon 하면 됩니다.

브랜치 과정을 나타내면,
1) 브랜치 생성하기 전 상태(head는 현재 위치를 나타냄)
![[Pasted image 20240524034242.png]]

2) Commit2에서 브랜치 생성(복사본 생성, 위치는 메인 그대로)
![[Pasted image 20240524034259.png]]

3) 브랜치 이동(Head가 branch로 이동)
![[Pasted image 20240524034311.png]]


▶ 현재 어떤 브랜치에 있는지 확인
```sh
git status
```


▶ 브랜치와 커밋 내역을 그래프로 확인
```sh
git log --graph --oneline --all
```


## Branch에서 개발 후 커밋
![[Pasted image 20240524034636.png]]
coupon 브랜치로 이동한 후 새로운 파일을 생성하고 코드를 작성한 후 커밋합니다. 이렇게 하면 main/master 브랜치와는 **독립적으로 개발을 진행**할 수 있습니다.


## Branch 합치기 (Merge) ✔
branch에서 개발이 완료되고 만족스러운 결과가 나왔다면, 원본 코드가 있는 master 또는 main 브랜치에 합칠 수 있습니다. 이를 merge라고 합니다.
![[Pasted image 20240524034945.png]]

```sh
git switch main
git merge 브랜치명 
```
merge 하고 싶으면
1. main/master 브랜치로 다시 이동하고
2. git merge 브랜치명 입력하면 합쳐집니다.
예를 들어 git merge coupon 이러면 coupon 브랜치의 코드들이 main/master 브랜치에 합쳐집니다.


## Merge Conflict ✔
근데 합칠 때 주의사항이 있는데 master 브랜치와 coupon 브랜치에서 **같은 파일, 같은 줄을 수정했을 경우 merge conflict 가 발생**합니다.

해결방법
1) 해당 파일을 열어 충돌 사항을 확인하고, 불필요한 표시(<<<<, >>>>, ==== 등)를 지우고 **원하는 코드만 남깁**니다.
![[캡처3.png]]

2) 수정 후 `git add 파일명` 및 `git commit -m '메세지'`로 **새로운 커밋을 생성하여 merge conflict를 해결**하고 브랜치를 합칩니다.


## 협업 시 Branch의 유용성
여러 개발자와 **협업할 때도 branch를 만들어 개발하면 편리**합니다. 기능을 추가하고자 할 때 branch로 프로젝트 사본을 만들어 거기서 먼저 개발을 진행하고, 테스트 후에 main branch에 합칩니다.


# 브랜치 합치기 방법
## 3-way merge ✔
![[Pasted image 20240524145502.png]]
브랜치에 각각 신규 commit이 1회 이상 있는 경우, `merge` 명령을 내리면 **두 브랜치의 코드를 합쳐서 새로운 commit을 자동으로 생성**합니다. 이를 `3-way merge`라 부릅니다. 이것이 `merge`의 기본 동작방식입니다.

`3-way merge`는 **많이 쓰면 나중에 깃히스토리할때 엄청 복잡**해짐.
![[Pasted image 20240524152002.png]]


## fast-forward merge ✔
![[Pasted image 20240524145537.png]]
**새로운 브랜치에만 commit이 있고, 기준이 되는 브랜치에는 신규 commit이 없는 경우**, "fast-forward merge 되었습니다"라고 알려줍니다.

강제로 3-way merge를 하고 싶다면 `git merge --no-ff 브랜치명`을 사용합니다.


## rebase and merge ✔
`rebase`는 **브랜치의 시작점을 다른 commit으로 옮기는 행위**입니다.
![[그림11-2.png]]

이 방법은 **강제로 fast-forward** 하고 싶거나, **commit 내역을 한 줄로 이어서 남기고 싶을 때** 유용합니다. 그래서깃 히스토리에서 깔끔하게 정리해서 보임. 

하지만, 브랜치끼리 차이가 너무 많은 경우 rebase하면 충돌이 많이 발생할 수 있는데 그거 하나하나 해결하기 귀찮습니다.

▶ rebase and merge 사용법
```sh
git switch 새로운브랜치 
git rebase main 

git switch main 
git merge 새로운브랜치
```


#### 원리
1) 기본상태(검은색 : 기준이 되는 브랜치, 파란색 : 새로운 브랜치)
![[Pasted image 20240524151431.png]]

2) 검은색 브랜치에 새로운 커밋이 있기 때문에 `fast-forward merge` 안됨. 그래서 파란색 브랜치를 새로운 커밋으로 이동. (rebase)
![[Pasted image 20240524151451.png]]

```sh
git switch 새로운브랜치 
git rebase main 
```


3) fast-forward merge
![[Pasted image 20240524151514.png]]

```sh
git switch main 
git merge 새로운브랜치
```


## squash and merge ✔
모든 브랜치를 `3-way merge` 해버리면 나중에 git log 그래프가 복잡해질 수 있습니다.
![[Pasted image 20240524152207.png]]

**`rebase and merge`와 원리는 동일**하지만, 세부 내역을 모두 옮기는 것이 아닌 **새 브랜치에 있던 commit들을 하나로 합쳐서 새로운 메시지를 만들어 main 브랜치에 추가**합니다.

▶ squash and merge 사용법
```sh
git switch main 
git merge --squash 브랜치명 
git commit -m '메세지'
```


## 브랜치 삭제하기
`3-way`, `fast-forward` 아무 방식으로 merge 해도 브랜치는 자동으로 삭제되지 않습니다.

▶ 브랜치 삭제
```sh
git branch -d 브랜치이름
git branch -D 브랜치이름
```
- 병합이 완료된 브랜치 삭제 시 `-d`, 병합하지 않은 브랜치 삭제 시 `-D`를 사용합니다.


## 어떻게 merge 할 지 판단하기 ✔
- 중요한 브랜치마다 merge 방법 가이드라인이 있으니 참고하세요. 취향일 뿐이고 알아서합시다.
1) 기록을 남겨야하는 중요한 브랜치를 merge할 땐 3-way merge
2) 기록을 남길 필요없는 쓸데없는 브랜치를 merge할 땐 squash, rebase 쓰면 됩니다. 


# Git 복구 명령어 사용법
## Git은 버전관리 프로그램
Git은 버전관리 프로그램이기 때문에 언제든지 이전 commit으로 되돌아가거나 문제가 되는 commit 내역을 취소할 수 있습니다. `git restore`, `git revert`, `git reset` 명령어를 사용하여 **파일을 복구하는 법**을 알아봅시다.

![[캡처3-1.png]]
왼쪽에 있는 노란 문자들은 commit의 고유 ID입니다. 고유 ID를 이용해야 "그 고유 ID로 되돌려주세요~" 이런 명령들이 가능합니다.


## git restore 명령어 ✔
**파일 하나가 잘못되었을 경우** `ctrl + z` 여러 번 눌러도 되겠지만, 수정사항이 너무 많다면 명령어 하나로 처리할 수 있습니다.

```sh
git restore 파일명
```
최근 commit 된 상태로 현재 파일의 수정내역을 되돌릴 수 있습니다.

```sh
git restore --source 커밋아이디 파일명
```
입력한 파일이 특정 커밋아이디 시점으로 복구됩니다.

```sh
git restore --staged 파일명
```
복구랑 상관없지만 특정 파일을 staging 취소할 수 있습니다.


## git revert ✔
코드를 열심히 짜다가 갑자기 **과거 commit 하나가 문제를 일으키면** 어떻게 하죠?

![[캡처3-1 1.png]]
위 사진을 보면 지금 commit이 3개 있는데 여기서 b 파일이 문제가 많아서 b 파일을 만든 `d874b2b` **commit을 취소하고 싶어진 겁니다.** 

![[Pasted image 20240524164719.png]]
**commit 자체를 없앨 순 없고, 제거하는 commit은 생성가능하다.**

```sh
git revert 커밋아이디
```
이거 입력하면 그 커밋아이디에서 일어난 일만 취소해줍니다. 그 후, 커밋메세지 수정하고 닫으면 끝입니다.

![[캡처5-2.png]]

![[Pasted image 20240524185911.png]]


## git reset ✔
지옥같은 개발에 대해 아무것도 모르던 어린시절로 되돌아가고 싶습니까? 현실에선 불가능하지만 git에선 가능합니다. `git reset` 명령어 사용하면 **특정 commit 시절로 아예 모든 걸 되돌릴 수** 있습니다.

```sh
git reset --hard 커밋아이디
```
입력하면 그 커밋이 생성될 때로 시간을 되돌려줍니다. 작업폴더 내의 파일도 그 시절로 돌아갑니다. 커밋 이후의 미래 기억을 모두 잃습니다.


## reset시 옵션 설정 가능 ✔
a, b, c 파일을 만들면서 각각 commit을 했다고 칩시다. `git reset` 뒤에 `hard` / `soft` / `mixed` 설정을 넣을 수 있는데
![[캡처3-1 2.png]]

▶ hard 옵션
```sh
git reset --hard d874b2b
```
이러면 a, b 파일은 남아있고 c **파일이 삭제**됩니다.

▶ soft 옵션
```sh
git reset --soft d874b2b
```
이러면 a, c 파일은 남아있고 b **파일은 staging area에 남아**있습니다. 이제 commit 하거나 그럴 수 있습니다.

▶ mix 옵션
```sh
git reset --mixed d874b2b
```
이러면 a, c 파일은 남아있고 b **파일은 Unstaging 상태**가 됩니다. 이제 `git add` 하고 commit 하거나 그럴 수 있습니다.


# Git 기본 배우기
## 원격 Repository의 개념
Repository란 **git이 파일 버전을 저장해두는 장소**를 말하며, 로컬 작업 폴더에는 .git 폴더가 있고, 이 폴더가 바로 repository입니다. Repository는 한국말로 '저장소'라고 합니다.

실제 개발 시에는 온라인 repository를 주로 사용합니다. 이는 내 컴퓨터에 만들어둔 git repository를 온라인으로 저장해두는 것으로, 컴퓨터가 랜섬웨어에 감염되더라도 안심할 수 있으며, 다른 사람과의 협업도 가능해집니다. 


## Github 가입 및 Repository 생성
![[캡처1.png]]
1. github.com에 접속하여 가입한 후, 원격 저장소를 하나 만듭니다. 로그인 후 우측 상단의 + 버튼을 눌러 repository를 생성할 수 있습니다.
2. 이름을 설정하고 확인을 누르면 됩니다.


## 작업 폴더에서 Git으로 Commit하기
원격 저장소를 사용하는 이유는 내 컴퓨터에서 만든 저장소를 백업할 수 있기 때문입니다. 로컬 저장소를 원격 저장소로 백업하는 과정을 해보겠습니다.

1. 새로운 작업 폴더를 만들고 터미널에서 **`git init`을 입력하여 로컬 리포지토리를 생성**합니다.
2. github.com은 이제 기본 브랜치 이름을 master가 아닌 main으로 사용하도록 하고 있습니다. 따라서 로컬 작업 폴더의 **기본 브랜치 이름을 main으로 변경**합니다. 터미널에서 `git branch -M main`을 입력하면 기본 브랜치 이름이 변경됩니다.
3. 파일을 만들고 commit을 몇 번 해봅니다.


## git push : 원격 저장소에 올리기 ✔
**로컬저장소 -> 원격저장소 이렇게 업로드**하고 싶으면 작업폴더에서 터미널켜서 입력합니다.
```sh
git push -u <원격저장소주소> <브랜치명>
```

`-u` 옵션은 입력한 주소를 기억하라는 뜻으로, 다음부터는 주소를 길게 입력하지 않고 `git push`만 입력해도 됩니다.


## 변수 사용 : 원격 저장소 주소 간편하게 사용하기
그니까 `https://github.com/codingapple1/lesson.git` 이거 매번 입력하기 귀찮으면 어떻게 하냐는 겁니다.  그럴 땐 그 **주소를 변수에 저장**해서 사용할 수 있습니다.

▶ 변수 저장하는 방법
```sh
git remote add <변수명> <저장소주소>
```
이제 `git push -u <변수명> main`으로 짧게 사용할 수 있습니다.


## 원격 저장소에 있던 것 그대로 내려받기
새로운 컴퓨터에서 개발을 시작하고 싶을 때, **원격 저장소에 있던 내용을 그대로 내려받으**면 편리합니다. 
```sh
git clone <원격저장소 주소>
```


## 저장소에 올리지 않는 파일들 (.gitignore)
원격 저장소를 효율적으로 사용하기 위해서는 쓸데없는 파일은 commit해서 올리지 않는 것이 좋습니다. `.gitignore` 파일을 만들어 **저장소에 올리지 않을 파일들을 쉽게 명시**할 수 있습니다.

예를 들어, 웹 개발 시 `node_modules` 폴더나 개인 정보가 담긴 `.env` 파일 등은 올리지 않습니다.


# Git 협업 기초
## 원격 저장소의 장점
원격저장소의 장점은 **남들과 협업**할 수 있다는 겁니다. 어려운건 아니고 개발자 10명이서 각각 작업한 내용을 원격저장소에 올리면 그게 협업 아니겠습니까 협업해봅시다.

가상의 팀원을 하나 만들어봅시다. 코딩노예 팀원이 원격저장소에 있던 코드를 같이 짜고 싶다면 어떻게할까요. 그 팀원도 github 아이디가 있어야하고 그 팀원의 아이디를 Collaborators 메뉴에 등록해놔야 협업가능합니다.

![[캡처1-1 1.png]]
그리고, 그 친구도 코드짜서 `git push` 어쩌구 하면 그게 협업 끝입니다.


## 협업 중 commit 문제 ✔
`git push`는 맘대로 할 수 있는게 아닙니다. 갑자기 다른 놈이 만든 파일이 원격저장소에 생기면 `git push` 못합니다.

1) 초기 상태
![[Pasted image 20240525034321.png]]

2) `clone` 명령어를 통해 로컬 저장소에 각각 다운 받음
![[Pasted image 20240525034348.png]]

3) 개발자 A, B가 각각 코드 작성함.
![[Pasted image 20240525034359.png]]

3) 개발자B가 먼저 원격저장소에 `push`함.
![[Pasted image 20240525034412.png]]

4) **개발자 A가 `push`하려고 하면, 원격 저장소가 초기 상태가 아니기 때문에 `commit` 문제 발생.**
![[Pasted image 20240525034423.png]]
![[캡처3-2.png]]


## 협업 중 commit 해결책 ✔
**`push` 하기 전에 항상 `pull` 먼저 해 원격 저장소의 바뀐 코드를 가져오자**
![[Pasted image 20240525034433.png]]

![[Pasted image 20240525034443.png]]


## git pull 명령어 ✔
`git pull` 명령어는 `git fetch` + `git merge` 축약어임. 
`git fetch`는 원격저장소에 있는 **commit 중에 로컬에 없는 신규 commit을 가져오라는 뜻**이고, 
`git merge`는 그걸 merge 하라는 뜻입니다.

```sh
git pull 원격저장소주소
```


# 신기능 개발 시 브랜치 활용하기
## 신기능 개발의 안전한 방법
신기능을 만들고 싶으면 main 브랜치에 코드를 짜다가 프로젝트를 망치지 않기 위해 **다른 브랜치를 만들어서 거기에 개발**하는 것이 안전하고 좋습니다.


## 원격 repository에 브랜치 생성하기
원격 repository(저장소)에도 브랜치를 만들 수 있습니다. 브랜치 생성 방법은 다음과 같습니다.

1. `github.com` 사이트에서 직접 브랜치 생성 가능
main 브랜치명 버튼을 누르면 브랜치를 바꾸거나 새로 만들 수 있습니다. 심심하면 하나 만들어보거나 하면 됩니다.

2. 로컬 repository에서도 브랜치 생성 가능
로컬 저장소에서 브랜치를 생성해서 원격 저장소로 `git push` 해도 됩니다.
```sh
//브랜치 생성
git branch <브랜치명>

//브랜치 이동
git switch <브랜치명>

...commit 작성

// 브랜치 푸쉬
git push <원격저장소주소> <브랜치명>
```


## Pull request 하기 ✔
브랜치를 만들고 나서 그것을 **main 브랜치와 합쳐야 기능이 완성**됩니다. 합치려면 `git merge` 명령어로 합치고 `git push` 하면 됩니다. 
그러나 팀끼리 일하는 경우 merge 하기 전에 토론하거나 검토할 필요가 있습니다. 이를 위해  `pull request` 기능을 제공합니다.

예시) mining 브랜치 -> main 브랜치로 `pull request` 하는 방법
![[캡처1-2 2.png]]

![[캡처2-2.png]]

![[캡처4-2.png]]
Pull requests 메뉴에서 이렇게 확인가능한데 누르면 코딩노예들이 토론할 수 있는 곳도 있습니다. 거기서 코드를 리뷰하면 됩니다.


## Merge 옵션
잘 된것 같아서 merge하기로 했으면 merge 할 때 여러가지 옵션이 있는데 택1 하면 됩니다.
![[캡처5-3.png]]

# Git 브랜치 관리 방법론
## 브랜치 관리의 필요성
개발자 10명이서 브랜치를 대충 아무렇게나 만들면 개발과정이 매우 복잡해지고 추적도 어려워서 `git branch` **깔끔하게 브랜치 만들도록 도와주는 방법론**같은게 있습니다.
git flow, github flow, gitlab flow, trunk-based 등 다양한 것들이 있습니다.


## 안정적인 운영이 필요하면 git flow ✔
님들이 만드는 프로그램이 항상 안정적인 release를 해야한다면 (예를 들면 게임개발) git flow 전략을 쓰면 됩니다.

git flow 전략은 크게 5개 브랜치를 운영하는데
- main 브랜치
- develop 브랜치 (개발용)
- feature 브랜치 (develop에 기능추가용)
- hotfix 브랜치 (main 브랜치 버그해결용)
- 가끔 release 브랜치 (develop 브랜치를 main 브랜치에 합치기 전에 최종 테스트용) 를 운영합니다.

## git flow 예시 ✔
이제부터 여러분은 게임개발 팀장입니다. 지금까지는 대충 주먹구구식으로 협업해서 0.9버전까지 만들어놨다고 칩시다. 근데 1.0 버전부터는 신기능도 많고 해서 제대로 개발을 진행하고 싶은겁니다. 그래서 이번엔 git flow를 도입해서 개발을 진행해봅시다.

#### 1. develop 브랜치부터 생성합니다.
![[그림4.png]]
신기능 개발해서 바로 main브랜치에 합칠 것입니까? 일단 실험용 **프로젝트 사본을 만들고 거기다가 먼저 개발**해봅시다. 그러기 위해 main 브랜치에 있던 기존 프로젝트를 복사한 develop 브랜치를 생성합니다. 


#### 2. 신기능개발은 feature 브랜치에서 진행
![[그림1 2.png]]
신기능을 만들고 싶으면 develop 브랜치를 복사한 **feature 브랜치에서 각각 개발**합니다. feature/guild 브랜치 만들어서 길드기능 만들고 feature/friend 브랜치 만들어서 친구기능 만들고 하면 됩니다. (브랜치 작명할 때 여러 단어가 필요하면 보통 대시나 / 기호 씁니다)

- 완성되면 develop 브랜치에 merge 합니다.
- 중요한 내용이 아니면 squash and merge도 괜찮습니다.


#### 3. 신버전 출시 준비는 release 브랜치
![[그림2.png]]
develop에서 만든 2개 기능들이 완성된 것 같습니다. 이걸 바로 main 브랜치에 합치기엔 또 불안하기 때문에 develop -> release 브랜치 이렇게 프로젝트를 복사한 다음 **테스트나 QA같은거 진행**하면 됩니다.

- 버그를 발견하면 알아서 임시 브랜치 만들어서 수정하거나 합니다.
- release/1.0 이런 식으로 이쁘게 브랜치 이름을 짓는 경우가 많습니다.

완성된 것 같으면 main 브랜치로 merge 합니다. 그리고 그거 유저들에게 배포하면 됩니다. 개발은 계속 진행되어야하니 완성본은 develop 브랜치에도 merge 해줍시다.


#### 4. hotfix 브랜치
![[그림5.png]]
1.0 버전에서 갑자기 골드 무한복사 **버그를 발견**했습니다. 그런 급한 것들은 main 브랜치에서 hotfix 이런 **브랜치 하나 만들어서 바로바로 버그수정**하면 됩니다.

- 수정이 완료되면 main 브랜치에 직접 merge 하면 됩니다.
- 당연히 develop 브랜치에도 merge 해줘야합니다.

이제 유저들에겐 "잡다한 버그 수정" 공지만 올리고 점검보상 쪼금 주면 됩니다. 게임 뿐만 아니라 웹이나 앱도 비슷하게 운영할 수 있습니다.


## Q. 꼭 저거 따라해야하나요?
맨날 남들이 하는거 앵무새처럼 따라할 생각하지 말고 본인 마음대로 변형해서 쓰십시오. 

예를 들면 release 브랜치 쓰지 않고 바로 main 브랜치에 merge 해서 배포하거나 그래도 됩니다. 그 선택에 합당한 이유와 근거가 있으면 됩니다. 물론 책임도 져야합니다.


## Trunk-based 전략
님들이 만드는게 코드짠걸 바로 대중에 배포를 해도 상관없는 프로그램이면 그리고 크게 대격변 업데이트를 안하는 안정적인 프로그램이면 굳이 많은 브랜치를 만들 필요가 없습니다.

그냥 main 브랜치와 기능추가용 **feature 브랜치만 운영**하면 됩니다. 이게 trunk-based 전략입니다. 
![[그림7.png]]

# git stash 사용법
## git stash 사용해서 코드 잠깐 다른 곳에 보관하기 ✔
그 코드를 잠깐 치워놓고 개발하고 싶으면 주석처리해도 되겠지만 `git stash` 입력하면 **방금 작성한 코드는 잠깐 다른 공간에 보관**됩니다. (그래서 파일들이 최근 commit 상태로 되돌아갑니다.)
![[Pasted image 20240525155124.png]]
- staging 된 것이든 안된 것이든 추적중인 파일은 다 이동됩니다.
- 새로 만든 파일인데 staging 안되었다면 이동 안 됩니다. 

▶ 방금 작성한 코드를 잠깐 다른 공간에 보관
```sh
git stash
```

▶ git stash 할 때 메모도 함께 입력할 수도 있습니다.
```sh
git stash save "메모"
```

▶ 현재 stash 되어있는 코드 목록을 전부 출력
```sh
git stash list
```


## 보관했던 코드 다시 불러오기
▶ 잠깐 보관했던 코드를 다시 불러오기
```sh
git stash pop
```
![[Pasted image 20240525155452.png]]
**가장 최근에 들어온 것부터 먼저** 나갑니다. 물론 현재 코드와 겹치는 부분이 있으면 conflict 나니까 알아서 해결하면 됩니다. 


## stash 관련 여러 명령어들
```sh
//특정 stash 삭제
git stash drop <삭제할id>

//모든 stash 삭제
git stash clear
```


## Q&A
Q. 주석처리해놓는게 더 쉬울듯?
실은 코드를 주석처리하는 거랑 용도가 비슷하긴 한데 주석처리된 코드는 commit할 때 반영됩니다. 그렇게 되면 주석도 **commit 기록에 남아서 기록이 더러워**질 수 있습니다

Q. 브랜치 새로 만들어서 거기다 코드 짜놓는 거랑 다를 바 없는데요?
간단히 브랜치 만들어서 거기 보관하는 것도 나쁘지 않습니다.
